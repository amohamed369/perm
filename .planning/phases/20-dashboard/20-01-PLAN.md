# Phase 20-01: Dashboard Data Layer & Deadline Queries

---
phase: 20-dashboard
plan: 01
type: execute
---

<objective>
Build the Convex queries and data transformations for the dashboard using TDD.

Purpose: Provide reliable, tested data layer before any UI is built.
Output: Dashboard queries with 100% test coverage, test fixtures, and helper functions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-dashboard/20-CONTEXT.md
@.planning/V2_DEADLINE_SYSTEM.md
@.planning/V2_BUSINESS_RULES.md
@perm_flow.md
@v2/convex/schema.ts
@v2/convex/cases.ts
@v2/convex/lib/auth.ts
@v2/test-utils/convex.ts
@v2/src/lib/perm-engine/index.ts

**Prior decisions:**
- ISO date strings (YYYY-MM-DD) for all dates
- UTC handling to avoid DST issues
- Soft delete pattern (deletedAt field)
- User isolation via RLS (getCurrentUserId)
- Audit logging on all mutations

**Test infrastructure:**
- Vitest + convex-test for Convex function testing
- createTestContext() and createAuthenticatedContext() utilities
- fixtures pattern for test data factories
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dashboard Test Fixtures</name>
  <files>v2/test-utils/dashboard-fixtures.ts</files>
  <action>
Create reusable test fixtures for dashboard testing. This is the foundation for all dashboard tests.

```typescript
// v2/test-utils/dashboard-fixtures.ts
import { Id } from '../convex/_generated/dataModel';

export type TestCaseData = {
  employerName: string;
  beneficiaryIdentifier: string;
  positionTitle: string;
  caseStatus: 'pwd' | 'recruitment' | 'eta9089' | 'i140' | 'closed';
  progressStatus: 'working' | 'waiting_intake' | 'filed' | 'approved' | 'under_review' | 'rfi_rfe';
  // All date fields (ISO strings or null)
  pwdFilingDate?: string | null;
  pwdDeterminationDate?: string | null;
  pwdExpirationDate?: string | null;
  eta9089FilingDate?: string | null;
  eta9089CertificationDate?: string | null;
  eta9089ExpirationDate?: string | null;
  i140FilingDate?: string | null;
  i140ApprovalDate?: string | null;
  rfiReceivedDate?: string | null;
  rfiDueDate?: string | null;
  rfiSubmittedDate?: string | null;
  rfeReceivedDate?: string | null;
  rfeDueDate?: string | null;
  rfeSubmittedDate?: string | null;
  recruitmentEndDate?: string | null;
  // Metadata
  isFavorite?: boolean;
  priorityLevel?: 'low' | 'normal' | 'high' | 'urgent';
  deletedAt?: number;
};

// Factory function with sensible defaults
export function createTestCase(overrides: Partial<TestCaseData> = {}): TestCaseData {
  return {
    employerName: 'Test Employer Inc',
    beneficiaryIdentifier: 'John Doe',
    positionTitle: 'Software Engineer',
    caseStatus: 'pwd',
    progressStatus: 'working',
    pwdFilingDate: null,
    pwdDeterminationDate: null,
    pwdExpirationDate: null,
    eta9089FilingDate: null,
    eta9089CertificationDate: null,
    eta9089ExpirationDate: null,
    i140FilingDate: null,
    i140ApprovalDate: null,
    rfiReceivedDate: null,
    rfiDueDate: null,
    rfiSubmittedDate: null,
    rfeReceivedDate: null,
    rfeDueDate: null,
    rfeSubmittedDate: null,
    recruitmentEndDate: null,
    isFavorite: false,
    priorityLevel: 'normal',
    ...overrides,
  };
}

// Pre-built scenarios for common test cases
export const fixtures = {
  // PWD stage cases
  pwdWorking: () => createTestCase({
    caseStatus: 'pwd',
    progressStatus: 'working',
  }),

  pwdWithExpiration: (expirationDate: string) => createTestCase({
    caseStatus: 'pwd',
    progressStatus: 'filed',
    pwdFilingDate: '2025-01-01',
    pwdDeterminationDate: '2025-01-15',
    pwdExpirationDate: expirationDate,
  }),

  pwdExpiringSoon: (daysUntil: number) => {
    const expDate = addDays(new Date(), daysUntil);
    return createTestCase({
      caseStatus: 'pwd',
      progressStatus: 'filed',
      pwdFilingDate: '2025-01-01',
      pwdDeterminationDate: '2025-01-15',
      pwdExpirationDate: formatISO(expDate),
    });
  },

  // Recruitment stage cases
  recruitmentActive: () => createTestCase({
    caseStatus: 'recruitment',
    progressStatus: 'working',
    pwdExpirationDate: '2025-06-30',
    recruitmentEndDate: null,
  }),

  recruitmentComplete: () => createTestCase({
    caseStatus: 'recruitment',
    progressStatus: 'approved',
    pwdExpirationDate: '2025-06-30',
    recruitmentEndDate: '2025-03-15',
  }),

  // ETA 9089 stage cases
  eta9089Pending: () => createTestCase({
    caseStatus: 'eta9089',
    progressStatus: 'working',
    recruitmentEndDate: '2025-03-15',
    eta9089FilingDate: null,
  }),

  eta9089WithRFI: (rfiDueDate: string) => createTestCase({
    caseStatus: 'eta9089',
    progressStatus: 'rfi_rfe',
    eta9089FilingDate: '2025-04-20',
    rfiReceivedDate: '2025-05-01',
    rfiDueDate: rfiDueDate,
    rfiSubmittedDate: null,
  }),

  eta9089Certified: (expirationDate: string) => createTestCase({
    caseStatus: 'eta9089',
    progressStatus: 'approved',
    eta9089FilingDate: '2025-04-20',
    eta9089CertificationDate: '2025-06-01',
    eta9089ExpirationDate: expirationDate,
  }),

  // I-140 stage cases
  i140Pending: (filingDeadline: string) => createTestCase({
    caseStatus: 'i140',
    progressStatus: 'working',
    eta9089CertificationDate: '2025-06-01',
    eta9089ExpirationDate: filingDeadline,
    i140FilingDate: null,
  }),

  i140WithRFE: (rfeDueDate: string) => createTestCase({
    caseStatus: 'i140',
    progressStatus: 'rfi_rfe',
    i140FilingDate: '2025-07-01',
    rfeReceivedDate: '2025-08-01',
    rfeDueDate: rfeDueDate,
    rfeSubmittedDate: null,
  }),

  i140Approved: () => createTestCase({
    caseStatus: 'i140',
    progressStatus: 'approved',
    i140FilingDate: '2025-07-01',
    i140ApprovalDate: '2025-10-15',
  }),

  // Closed cases
  closedCase: () => createTestCase({
    caseStatus: 'closed',
    progressStatus: 'approved',
  }),

  // Soft-deleted case
  deletedCase: () => createTestCase({
    caseStatus: 'pwd',
    progressStatus: 'working',
    deletedAt: Date.now(),
  }),

  // Overdue deadline case
  overdueDeadline: () => {
    const pastDate = addDays(new Date(), -5);
    return createTestCase({
      caseStatus: 'pwd',
      progressStatus: 'filed',
      pwdExpirationDate: formatISO(pastDate),
    });
  },
};

// Helper to format date as ISO string
function formatISO(date: Date): string {
  return date.toISOString().split('T')[0];
}

// Helper to add days to a date
function addDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

// Helper to get today's date as ISO string
export function today(): string {
  return formatISO(new Date());
}

// Helper to get date N days from now as ISO string
export function daysFromNow(days: number): string {
  return formatISO(addDays(new Date(), days));
}

// Helper to get date N days ago as ISO string
export function daysAgo(days: number): string {
  return formatISO(addDays(new Date(), -days));
}
```
  </action>
  <verify>npx tsc --noEmit v2/test-utils/dashboard-fixtures.ts</verify>
  <done>Test fixtures compile with no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: Write Unit Tests for Pure Helper Functions</name>
  <files>v2/convex/lib/dashboard.test.ts</files>
  <action>
Write comprehensive unit tests BEFORE implementing the helper functions. This is TDD - tests first.

```typescript
// v2/convex/lib/dashboard.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import {
  calculateUrgency,
  sortByUrgency,
  extractDeadlines,
  buildPwdSubtext,
  buildRecruitmentSubtext,
  buildEta9089Subtext,
  buildI140Subtext,
  groupDeadlinesByUrgency,
} from './dashboard-helpers';
import { fixtures, daysFromNow, daysAgo, today } from '../../test-utils/dashboard-fixtures';

describe('Dashboard Helper Functions - Unit Tests', () => {

  // ============================================
  // calculateUrgency() - Pure function tests
  // ============================================
  describe('calculateUrgency()', () => {
    describe('overdue classification', () => {
      it.each([
        [-30, 'overdue'],
        [-7, 'overdue'],
        [-1, 'overdue'],
      ])('returns "overdue" for %d days until deadline', (days, expected) => {
        expect(calculateUrgency(days)).toBe(expected);
      });
    });

    describe('thisWeek classification (0-7 days)', () => {
      it.each([
        [0, 'thisWeek'],  // Due today
        [1, 'thisWeek'],
        [3, 'thisWeek'],
        [7, 'thisWeek'],  // Exactly 7 days
      ])('returns "thisWeek" for %d days until deadline', (days, expected) => {
        expect(calculateUrgency(days)).toBe(expected);
      });
    });

    describe('thisMonth classification (8-30 days)', () => {
      it.each([
        [8, 'thisMonth'],   // Just past 7
        [14, 'thisMonth'],
        [21, 'thisMonth'],
        [30, 'thisMonth'],  // Exactly 30 days
      ])('returns "thisMonth" for %d days until deadline', (days, expected) => {
        expect(calculateUrgency(days)).toBe(expected);
      });
    });

    describe('later classification (31+ days)', () => {
      it.each([
        [31, 'later'],   // Just past 30
        [60, 'later'],
        [90, 'later'],
        [365, 'later'],
      ])('returns "later" for %d days until deadline', (days, expected) => {
        expect(calculateUrgency(days)).toBe(expected);
      });
    });
  });

  // ============================================
  // sortByUrgency() - Sorting tests
  // ============================================
  describe('sortByUrgency()', () => {
    it('sorts deadlines by daysUntil ascending (most urgent first)', () => {
      const deadlines = [
        { daysUntil: 30, label: 'later' },
        { daysUntil: -5, label: 'overdue' },
        { daysUntil: 7, label: 'soon' },
        { daysUntil: 0, label: 'today' },
      ];

      const sorted = sortByUrgency(deadlines);

      expect(sorted[0].daysUntil).toBe(-5);
      expect(sorted[1].daysUntil).toBe(0);
      expect(sorted[2].daysUntil).toBe(7);
      expect(sorted[3].daysUntil).toBe(30);
    });

    it('handles empty array', () => {
      expect(sortByUrgency([])).toEqual([]);
    });

    it('handles single item', () => {
      const single = [{ daysUntil: 5 }];
      expect(sortByUrgency(single)).toEqual(single);
    });

    it('maintains stability for equal daysUntil', () => {
      const deadlines = [
        { daysUntil: 5, id: 'a' },
        { daysUntil: 5, id: 'b' },
        { daysUntil: 5, id: 'c' },
      ];

      const sorted = sortByUrgency(deadlines);

      // Original order preserved for equal values
      expect(sorted[0].id).toBe('a');
      expect(sorted[1].id).toBe('b');
      expect(sorted[2].id).toBe('c');
    });
  });

  // ============================================
  // extractDeadlines() - Deadline extraction tests
  // ============================================
  describe('extractDeadlines()', () => {
    describe('PWD stage deadlines', () => {
      it('extracts PWD expiration when no ETA 9089 filed', () => {
        const caseData = fixtures.pwdWithExpiration('2025-06-30');
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines).toContainEqual(
          expect.objectContaining({
            deadlineType: 'pwd_expiration',
            dueDate: '2025-06-30',
          })
        );
      });

      it('excludes PWD expiration when ETA 9089 is filed (superseded)', () => {
        const caseData = {
          ...fixtures.pwdWithExpiration('2025-06-30'),
          eta9089FilingDate: '2025-04-15',
        };
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines.find(d => d.deadlineType === 'pwd_expiration')).toBeUndefined();
      });

      it('returns empty array for PWD case with no dates', () => {
        const caseData = fixtures.pwdWorking();
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines).toHaveLength(0);
      });
    });

    describe('RFI deadline extraction', () => {
      it('extracts RFI due date when RFI is active', () => {
        const caseData = fixtures.eta9089WithRFI('2025-06-01');
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines).toContainEqual(
          expect.objectContaining({
            deadlineType: 'rfi_due',
            dueDate: '2025-06-01',
          })
        );
      });

      it('excludes RFI when already submitted', () => {
        const caseData = {
          ...fixtures.eta9089WithRFI('2025-06-01'),
          rfiSubmittedDate: '2025-05-28',
        };
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines.find(d => d.deadlineType === 'rfi_due')).toBeUndefined();
      });
    });

    describe('RFE deadline extraction', () => {
      it('extracts RFE due date when RFE is active', () => {
        const caseData = fixtures.i140WithRFE('2025-09-01');
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines).toContainEqual(
          expect.objectContaining({
            deadlineType: 'rfe_due',
            dueDate: '2025-09-01',
          })
        );
      });

      it('excludes RFE when already submitted', () => {
        const caseData = {
          ...fixtures.i140WithRFE('2025-09-01'),
          rfeSubmittedDate: '2025-08-28',
        };
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines.find(d => d.deadlineType === 'rfe_due')).toBeUndefined();
      });
    });

    describe('ETA 9089 deadline extraction', () => {
      it('extracts ETA 9089 expiration (I-140 filing deadline)', () => {
        const caseData = fixtures.eta9089Certified('2025-11-28');
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines).toContainEqual(
          expect.objectContaining({
            deadlineType: 'eta9089_expiration',
            dueDate: '2025-11-28',
          })
        );
      });

      it('excludes ETA 9089 expiration when I-140 filed', () => {
        const caseData = {
          ...fixtures.eta9089Certified('2025-11-28'),
          i140FilingDate: '2025-08-01',
        };
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines.find(d => d.deadlineType === 'eta9089_expiration')).toBeUndefined();
      });
    });

    describe('daysUntil calculation', () => {
      it('calculates positive days for future deadline', () => {
        const futureDate = daysFromNow(10);
        const caseData = fixtures.pwdWithExpiration(futureDate);
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines[0].daysUntil).toBe(10);
      });

      it('calculates negative days for past deadline', () => {
        const pastDate = daysAgo(5);
        const caseData = fixtures.pwdWithExpiration(pastDate);
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines[0].daysUntil).toBe(-5);
      });

      it('calculates zero for deadline due today', () => {
        const caseData = fixtures.pwdWithExpiration(today());
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines[0].daysUntil).toBe(0);
      });
    });

    describe('closed and deleted cases', () => {
      it('returns empty array for closed cases', () => {
        const caseData = fixtures.closedCase();
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines).toHaveLength(0);
      });

      it('returns empty array for deleted cases', () => {
        const caseData = fixtures.deletedCase();
        const deadlines = extractDeadlines(caseData, today());

        expect(deadlines).toHaveLength(0);
      });
    });
  });

  // ============================================
  // groupDeadlinesByUrgency() - Grouping tests
  // ============================================
  describe('groupDeadlinesByUrgency()', () => {
    it('groups deadlines into 4 urgency buckets', () => {
      const deadlines = [
        { daysUntil: -5, urgency: 'overdue' as const },
        { daysUntil: 3, urgency: 'thisWeek' as const },
        { daysUntil: 15, urgency: 'thisMonth' as const },
        { daysUntil: 60, urgency: 'later' as const },
      ];

      const groups = groupDeadlinesByUrgency(deadlines);

      expect(groups.overdue).toHaveLength(1);
      expect(groups.thisWeek).toHaveLength(1);
      expect(groups.thisMonth).toHaveLength(1);
      expect(groups.later).toHaveLength(1);
      expect(groups.totalCount).toBe(4);
    });

    it('handles empty array', () => {
      const groups = groupDeadlinesByUrgency([]);

      expect(groups.overdue).toHaveLength(0);
      expect(groups.thisWeek).toHaveLength(0);
      expect(groups.thisMonth).toHaveLength(0);
      expect(groups.later).toHaveLength(0);
      expect(groups.totalCount).toBe(0);
    });

    it('sorts each group by daysUntil ascending', () => {
      const deadlines = [
        { daysUntil: 7, urgency: 'thisWeek' as const },
        { daysUntil: 1, urgency: 'thisWeek' as const },
        { daysUntil: 4, urgency: 'thisWeek' as const },
      ];

      const groups = groupDeadlinesByUrgency(deadlines);

      expect(groups.thisWeek[0].daysUntil).toBe(1);
      expect(groups.thisWeek[1].daysUntil).toBe(4);
      expect(groups.thisWeek[2].daysUntil).toBe(7);
    });
  });

  // ============================================
  // Subtext builder tests
  // ============================================
  describe('buildPwdSubtext()', () => {
    it('returns "X working, Y filed" format', () => {
      const breakdown = {
        working: 2,
        waiting_intake: 1,
        filed: 2,
        approved: 1,
        under_review: 0,
        rfi_rfe: 0,
      };

      const subtext = buildPwdSubtext(breakdown);

      expect(subtext).toBe('3 working, 3 filed');
    });

    it('omits zero counts', () => {
      const breakdown = {
        working: 3,
        waiting_intake: 0,
        filed: 0,
        approved: 0,
        under_review: 0,
        rfi_rfe: 0,
      };

      const subtext = buildPwdSubtext(breakdown);

      expect(subtext).toBe('3 working');
    });

    it('returns "None" for all zeros', () => {
      const breakdown = {
        working: 0,
        waiting_intake: 0,
        filed: 0,
        approved: 0,
        under_review: 0,
        rfi_rfe: 0,
      };

      const subtext = buildPwdSubtext(breakdown);

      expect(subtext).toBe('None');
    });
  });

  describe('buildRecruitmentSubtext()', () => {
    it('returns "X ready, Y in progress" format', () => {
      const breakdown = {
        working: 2,
        waiting_intake: 1,
        filed: 0,
        approved: 3,
        under_review: 1,
        rfi_rfe: 0,
      };

      const subtext = buildRecruitmentSubtext(breakdown);

      // ready = working + waiting_intake = 3
      // in progress = under_review + filed + approved = 4
      expect(subtext).toBe('3 ready, 4 in progress');
    });
  });

  describe('buildEta9089Subtext()', () => {
    it('returns "X prep, Y RFI, Z filed" format', () => {
      const breakdown = {
        working: 2,
        waiting_intake: 1,
        filed: 2,
        approved: 1,
        under_review: 0,
        rfi_rfe: 2,
      };

      const subtext = buildEta9089Subtext(breakdown);

      // prep = working + waiting_intake + under_review = 3
      // RFI = rfi_rfe = 2
      // filed = filed + approved = 3
      expect(subtext).toBe('3 prep, 2 RFI, 3 filed');
    });
  });

  describe('buildI140Subtext()', () => {
    it('returns "X prep, Y RFE, Z filed" format', () => {
      const breakdown = {
        working: 1,
        waiting_intake: 1,
        filed: 2,
        approved: 2,
        under_review: 1,
        rfi_rfe: 1,
      };

      const subtext = buildI140Subtext(breakdown);

      // prep = working + waiting_intake + under_review = 3
      // RFE = rfi_rfe = 1
      // filed = filed + approved = 4
      expect(subtext).toBe('3 prep, 1 RFE, 4 filed');
    });
  });
});
```
  </action>
  <verify>cd v2 && npm test -- convex/lib/dashboard.test.ts --run 2>&1 | head -50</verify>
  <done>All tests fail (functions not yet implemented) - this is expected TDD state</done>
</task>

<task type="auto">
  <name>Task 3: Implement Dashboard Helper Functions to Pass Tests</name>
  <files>v2/convex/lib/dashboard-helpers.ts, v2/convex/lib/dashboard-types.ts</files>
  <action>
Implement the helper functions to make all unit tests pass.

**First, create types file:**
```typescript
// v2/convex/lib/dashboard-types.ts
import { Id } from '../_generated/dataModel';

export type UrgencyGroup = 'overdue' | 'thisWeek' | 'thisMonth' | 'later';

export type CaseStatus = 'pwd' | 'recruitment' | 'eta9089' | 'i140' | 'closed';
export type ProgressStatus = 'working' | 'waiting_intake' | 'filed' | 'approved' | 'under_review' | 'rfi_rfe';

export type DeadlineItem = {
  caseId: Id<"cases">;
  caseNumber: string;
  employerName: string;
  beneficiaryName: string;
  deadlineType: string;
  deadlineLabel: string;
  dueDate: string; // ISO date YYYY-MM-DD
  daysUntil: number;
  urgency: UrgencyGroup;
  caseStatus: CaseStatus;
  progressStatus: ProgressStatus;
};

export type DeadlineGroups = {
  overdue: DeadlineItem[];
  thisWeek: DeadlineItem[];
  thisMonth: DeadlineItem[];
  later: DeadlineItem[];
  totalCount: number;
};

export type ProgressBreakdown = Record<ProgressStatus, number>;

export type StatusCount = {
  status: CaseStatus;
  total: number;
  subtext: string;
  breakdown: ProgressBreakdown;
};

export type DashboardSummary = {
  statusCounts: StatusCount[];
  totalCases: number;
  activeCases: number;
  completedCases: number;
  closedCases: number;
};

export type RecentActivityItem = {
  caseId: Id<"cases">;
  caseNumber: string;
  employerName: string;
  beneficiaryName: string;
  caseStatus: CaseStatus;
  progressStatus: ProgressStatus;
  updatedAt: number;
  action: 'created' | 'updated';
};
```

**Then, create helpers file:**
```typescript
// v2/convex/lib/dashboard-helpers.ts
import {
  UrgencyGroup,
  DeadlineItem,
  DeadlineGroups,
  ProgressBreakdown,
} from './dashboard-types';

// ============================================
// Urgency calculation
// ============================================
export function calculateUrgency(daysUntil: number): UrgencyGroup {
  if (daysUntil < 0) return 'overdue';
  if (daysUntil <= 7) return 'thisWeek';
  if (daysUntil <= 30) return 'thisMonth';
  return 'later';
}

// ============================================
// Sorting
// ============================================
export function sortByUrgency<T extends { daysUntil: number }>(items: T[]): T[] {
  return [...items].sort((a, b) => a.daysUntil - b.daysUntil);
}

// ============================================
// Deadline extraction from case data
// ============================================
export function extractDeadlines(
  caseData: any, // Doc<"cases"> type from schema
  todayISO: string
): Partial<DeadlineItem>[] {
  const deadlines: Partial<DeadlineItem>[] = [];

  // Skip closed or deleted cases
  if (caseData.caseStatus === 'closed' || caseData.deletedAt !== undefined) {
    return [];
  }

  const todayDate = new Date(todayISO + 'T00:00:00Z');

  // Helper to calculate days until
  const getDaysUntil = (dateStr: string): number => {
    const deadline = new Date(dateStr + 'T00:00:00Z');
    const diffMs = deadline.getTime() - todayDate.getTime();
    return Math.floor(diffMs / (1000 * 60 * 60 * 24));
  };

  // Helper to add deadline
  const addDeadline = (type: string, label: string, dueDate: string) => {
    const daysUntil = getDaysUntil(dueDate);
    deadlines.push({
      deadlineType: type,
      deadlineLabel: label,
      dueDate,
      daysUntil,
      urgency: calculateUrgency(daysUntil),
      caseStatus: caseData.caseStatus,
      progressStatus: caseData.progressStatus,
    });
  };

  // PWD Expiration (if not superseded by ETA 9089 filing)
  if (caseData.pwdExpirationDate && !caseData.eta9089FilingDate) {
    addDeadline('pwd_expiration', 'PWD Expires', caseData.pwdExpirationDate);
  }

  // RFI Due (if active - received but not submitted)
  if (caseData.rfiReceivedDate && caseData.rfiDueDate && !caseData.rfiSubmittedDate) {
    addDeadline('rfi_due', 'RFI Response Due', caseData.rfiDueDate);
  }

  // RFE Due (if active - received but not submitted)
  if (caseData.rfeReceivedDate && caseData.rfeDueDate && !caseData.rfeSubmittedDate) {
    addDeadline('rfe_due', 'RFE Response Due', caseData.rfeDueDate);
  }

  // ETA 9089 Expiration / I-140 Filing Deadline (if certified but I-140 not filed)
  if (caseData.eta9089CertificationDate && caseData.eta9089ExpirationDate && !caseData.i140FilingDate) {
    addDeadline('eta9089_expiration', 'I-140 Filing Deadline', caseData.eta9089ExpirationDate);
  }

  return deadlines;
}

// ============================================
// Grouping deadlines by urgency
// ============================================
export function groupDeadlinesByUrgency<T extends { urgency: UrgencyGroup; daysUntil: number }>(
  deadlines: T[]
): { overdue: T[]; thisWeek: T[]; thisMonth: T[]; later: T[]; totalCount: number } {
  const groups = {
    overdue: [] as T[],
    thisWeek: [] as T[],
    thisMonth: [] as T[],
    later: [] as T[],
    totalCount: deadlines.length,
  };

  for (const d of deadlines) {
    groups[d.urgency].push(d);
  }

  // Sort each group
  groups.overdue = sortByUrgency(groups.overdue);
  groups.thisWeek = sortByUrgency(groups.thisWeek);
  groups.thisMonth = sortByUrgency(groups.thisMonth);
  groups.later = sortByUrgency(groups.later);

  return groups;
}

// ============================================
// Subtext builders (per perm_flow.md requirements)
// ============================================

// PWD: "X working, Y filed"
export function buildPwdSubtext(breakdown: ProgressBreakdown): string {
  const working = breakdown.working + breakdown.waiting_intake + breakdown.under_review;
  const filed = breakdown.filed + breakdown.approved;

  const parts: string[] = [];
  if (working > 0) parts.push(`${working} working`);
  if (filed > 0) parts.push(`${filed} filed`);

  return parts.join(', ') || 'None';
}

// Recruitment: "X ready, Y in progress"
export function buildRecruitmentSubtext(breakdown: ProgressBreakdown): string {
  const ready = breakdown.working + breakdown.waiting_intake;
  const inProgress = breakdown.under_review + breakdown.filed + breakdown.approved;

  const parts: string[] = [];
  if (ready > 0) parts.push(`${ready} ready`);
  if (inProgress > 0) parts.push(`${inProgress} in progress`);

  return parts.join(', ') || 'None';
}

// ETA 9089: "X prep, Y RFI, Z filed"
export function buildEta9089Subtext(breakdown: ProgressBreakdown): string {
  const prep = breakdown.working + breakdown.waiting_intake + breakdown.under_review;
  const rfi = breakdown.rfi_rfe;
  const filed = breakdown.filed + breakdown.approved;

  const parts: string[] = [];
  if (prep > 0) parts.push(`${prep} prep`);
  if (rfi > 0) parts.push(`${rfi} RFI`);
  if (filed > 0) parts.push(`${filed} filed`);

  return parts.join(', ') || 'None';
}

// I-140: "X prep, Y RFE, Z filed"
export function buildI140Subtext(breakdown: ProgressBreakdown): string {
  const prep = breakdown.working + breakdown.waiting_intake + breakdown.under_review;
  const rfe = breakdown.rfi_rfe;
  const filed = breakdown.filed + breakdown.approved;

  const parts: string[] = [];
  if (prep > 0) parts.push(`${prep} prep`);
  if (rfe > 0) parts.push(`${rfe} RFE`);
  if (filed > 0) parts.push(`${filed} filed`);

  return parts.join(', ') || 'None';
}
```
  </action>
  <verify>cd v2 && npm test -- convex/lib/dashboard.test.ts --run</verify>
  <done>All unit tests pass (green)</done>
</task>

<task type="auto">
  <name>Task 4: Write Integration Tests for Convex Dashboard Queries</name>
  <files>v2/convex/dashboard.test.ts</files>
  <action>
Write integration tests for Convex queries BEFORE implementing them. These tests use convex-test with real database operations.

```typescript
// v2/convex/dashboard.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { api } from './_generated/api';
import { createTestContext, createAuthenticatedContext } from '../test-utils/convex';
import { fixtures, daysFromNow, daysAgo, today } from '../test-utils/dashboard-fixtures';

describe('Dashboard Convex Queries - Integration Tests', () => {

  // ============================================
  // getDeadlines query
  // ============================================
  describe('dashboard.getDeadlines', () => {
    it('requires authentication', async () => {
      const t = createTestContext();

      await expect(t.query(api.dashboard.getDeadlines, {}))
        .rejects.toThrow(/not authenticated/i);
    });

    it('returns empty groups when user has no cases', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      const result = await auth.query(api.dashboard.getDeadlines, {});

      expect(result.overdue).toHaveLength(0);
      expect(result.thisWeek).toHaveLength(0);
      expect(result.thisMonth).toHaveLength(0);
      expect(result.later).toHaveLength(0);
      expect(result.totalCount).toBe(0);
    });

    it('groups deadlines by urgency correctly', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // Create cases with different deadline urgencies
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysAgo(5)), // overdue
        employerName: 'Overdue Corp',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(3)), // thisWeek
        employerName: 'Soon Corp',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(15)), // thisMonth
        employerName: 'Month Corp',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(60)), // later
        employerName: 'Later Corp',
      });

      const result = await auth.query(api.dashboard.getDeadlines, {});

      expect(result.overdue).toHaveLength(1);
      expect(result.overdue[0].employerName).toBe('Overdue Corp');

      expect(result.thisWeek).toHaveLength(1);
      expect(result.thisWeek[0].employerName).toBe('Soon Corp');

      expect(result.thisMonth).toHaveLength(1);
      expect(result.thisMonth[0].employerName).toBe('Month Corp');

      expect(result.later).toHaveLength(1);
      expect(result.later[0].employerName).toBe('Later Corp');

      expect(result.totalCount).toBe(4);
    });

    it('excludes superseded deadlines (PWD after ETA 9089 filed)', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // PWD expiration should NOT appear because ETA 9089 is filed
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(10)),
        eta9089FilingDate: '2025-04-15',
        employerName: 'Superseded Corp',
      });

      const result = await auth.query(api.dashboard.getDeadlines, {});

      expect(result.totalCount).toBe(0);
    });

    it('excludes closed and deleted cases', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // Closed case
      await auth.mutation(api.cases.create, {
        ...fixtures.closedCase(),
        pwdExpirationDate: daysFromNow(5),
      });

      // Create then soft-delete
      const toDelete = await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(5)),
        employerName: 'Deleted Corp',
      });
      await auth.mutation(api.cases.remove, { id: toDelete });

      const result = await auth.query(api.dashboard.getDeadlines, {});

      expect(result.totalCount).toBe(0);
    });

    it('isolates deadlines by user (RLS)', async () => {
      const t = createTestContext();
      const userA = await createAuthenticatedContext(t, 'User A');
      const userB = await createAuthenticatedContext(t, 'User B');

      // User A creates case
      await userA.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(5)),
        employerName: 'User A Corp',
      });

      // User B should see nothing
      const resultB = await userB.query(api.dashboard.getDeadlines, {});
      expect(resultB.totalCount).toBe(0);

      // User A should see their deadline
      const resultA = await userA.query(api.dashboard.getDeadlines, {});
      expect(resultA.totalCount).toBe(1);
    });

    it('includes RFI deadlines when active', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      await auth.mutation(api.cases.create, {
        ...fixtures.eta9089WithRFI(daysFromNow(10)),
        employerName: 'RFI Corp',
      });

      const result = await auth.query(api.dashboard.getDeadlines, {});

      expect(result.thisMonth).toHaveLength(1);
      expect(result.thisMonth[0].deadlineType).toBe('rfi_due');
    });

    it('includes RFE deadlines when active', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      await auth.mutation(api.cases.create, {
        ...fixtures.i140WithRFE(daysFromNow(20)),
        employerName: 'RFE Corp',
      });

      const result = await auth.query(api.dashboard.getDeadlines, {});

      expect(result.thisMonth).toHaveLength(1);
      expect(result.thisMonth[0].deadlineType).toBe('rfe_due');
    });
  });

  // ============================================
  // getSummary query
  // ============================================
  describe('dashboard.getSummary', () => {
    it('requires authentication', async () => {
      const t = createTestContext();

      await expect(t.query(api.dashboard.getSummary, {}))
        .rejects.toThrow(/not authenticated/i);
    });

    it('returns zero counts when user has no cases', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      const result = await auth.query(api.dashboard.getSummary, {});

      expect(result.totalCases).toBe(0);
      expect(result.activeCases).toBe(0);
      expect(result.completedCases).toBe(0);
      expect(result.closedCases).toBe(0);
    });

    it('counts cases by status correctly', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // Create cases in different statuses
      await auth.mutation(api.cases.create, fixtures.pwdWorking());
      await auth.mutation(api.cases.create, fixtures.pwdWorking());
      await auth.mutation(api.cases.create, fixtures.recruitmentActive());
      await auth.mutation(api.cases.create, fixtures.eta9089Pending());
      await auth.mutation(api.cases.create, fixtures.i140Approved());
      await auth.mutation(api.cases.create, fixtures.closedCase());

      const result = await auth.query(api.dashboard.getSummary, {});

      expect(result.totalCases).toBe(6);

      const pwdCount = result.statusCounts.find(s => s.status === 'pwd');
      expect(pwdCount?.total).toBe(2);

      const recruitmentCount = result.statusCounts.find(s => s.status === 'recruitment');
      expect(recruitmentCount?.total).toBe(1);

      const eta9089Count = result.statusCounts.find(s => s.status === 'eta9089');
      expect(eta9089Count?.total).toBe(1);

      const i140Count = result.statusCounts.find(s => s.status === 'i140');
      expect(i140Count?.total).toBe(1);
    });

    it('separates Complete (I-140 Approved) from Closed', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // I-140 Approved = Complete
      await auth.mutation(api.cases.create, fixtures.i140Approved());
      await auth.mutation(api.cases.create, fixtures.i140Approved());

      // Closed = terminal status
      await auth.mutation(api.cases.create, fixtures.closedCase());

      const result = await auth.query(api.dashboard.getSummary, {});

      expect(result.completedCases).toBe(2); // I-140 Approved
      expect(result.closedCases).toBe(1);    // Closed status
    });

    it('builds correct subtexts per perm_flow.md', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // Create PWD cases with different progress statuses
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWorking(),
        progressStatus: 'working',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWorking(),
        progressStatus: 'working',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWorking(),
        progressStatus: 'filed',
      });

      const result = await auth.query(api.dashboard.getSummary, {});

      const pwdCount = result.statusCounts.find(s => s.status === 'pwd');
      expect(pwdCount?.subtext).toBe('2 working, 1 filed');
    });

    it('excludes soft-deleted cases from counts', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // Create and delete a case
      const caseId = await auth.mutation(api.cases.create, fixtures.pwdWorking());
      await auth.mutation(api.cases.remove, { id: caseId });

      // Create a normal case
      await auth.mutation(api.cases.create, fixtures.pwdWorking());

      const result = await auth.query(api.dashboard.getSummary, {});

      expect(result.totalCases).toBe(1); // Only non-deleted
    });

    it('isolates counts by user (RLS)', async () => {
      const t = createTestContext();
      const userA = await createAuthenticatedContext(t, 'User A');
      const userB = await createAuthenticatedContext(t, 'User B');

      // User A creates cases
      await userA.mutation(api.cases.create, fixtures.pwdWorking());
      await userA.mutation(api.cases.create, fixtures.pwdWorking());

      // User B should see zero
      const resultB = await userB.query(api.dashboard.getSummary, {});
      expect(resultB.totalCases).toBe(0);

      // User A should see 2
      const resultA = await userA.query(api.dashboard.getSummary, {});
      expect(resultA.totalCases).toBe(2);
    });
  });

  // ============================================
  // getRecentActivity query
  // ============================================
  describe('dashboard.getRecentActivity', () => {
    it('requires authentication', async () => {
      const t = createTestContext();

      await expect(t.query(api.dashboard.getRecentActivity, {}))
        .rejects.toThrow(/not authenticated/i);
    });

    it('returns empty array when user has no cases', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      const result = await auth.query(api.dashboard.getRecentActivity, {});

      expect(result).toHaveLength(0);
    });

    it('returns last 5 updated cases', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // Create 7 cases
      for (let i = 1; i <= 7; i++) {
        await auth.mutation(api.cases.create, {
          ...fixtures.pwdWorking(),
          employerName: `Employer ${i}`,
        });
      }

      const result = await auth.query(api.dashboard.getRecentActivity, {});

      expect(result).toHaveLength(5);
    });

    it('orders by updatedAt descending (most recent first)', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      // Create cases in order
      const case1 = await auth.mutation(api.cases.create, {
        ...fixtures.pwdWorking(),
        employerName: 'First',
      });
      const case2 = await auth.mutation(api.cases.create, {
        ...fixtures.pwdWorking(),
        employerName: 'Second',
      });

      // Update case1 to make it most recent
      await auth.mutation(api.cases.update, {
        id: case1,
        employerName: 'First Updated',
      });

      const result = await auth.query(api.dashboard.getRecentActivity, {});

      // First Updated should be first (most recently updated)
      expect(result[0].employerName).toBe('First Updated');
    });

    it('excludes soft-deleted cases', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      const caseId = await auth.mutation(api.cases.create, fixtures.pwdWorking());
      await auth.mutation(api.cases.remove, { id: caseId });

      const result = await auth.query(api.dashboard.getRecentActivity, {});

      expect(result).toHaveLength(0);
    });

    it('isolates activity by user (RLS)', async () => {
      const t = createTestContext();
      const userA = await createAuthenticatedContext(t, 'User A');
      const userB = await createAuthenticatedContext(t, 'User B');

      // User A creates case
      await userA.mutation(api.cases.create, fixtures.pwdWorking());

      // User B should see nothing
      const resultB = await userB.query(api.dashboard.getRecentActivity, {});
      expect(resultB).toHaveLength(0);
    });
  });

  // ============================================
  // getUpcomingDeadlines query
  // ============================================
  describe('dashboard.getUpcomingDeadlines', () => {
    it('requires authentication', async () => {
      const t = createTestContext();

      await expect(t.query(api.dashboard.getUpcomingDeadlines, {}))
        .rejects.toThrow(/not authenticated/i);
    });

    it('defaults to 30 days', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(25)),
        employerName: 'Within 30',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(35)),
        employerName: 'Beyond 30',
      });

      const result = await auth.query(api.dashboard.getUpcomingDeadlines, {});

      expect(result).toHaveLength(1);
      expect(result[0].employerName).toBe('Within 30');
    });

    it('filters to specified days', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(5)),
        employerName: 'Within 7',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(10)),
        employerName: 'Beyond 7',
      });

      const result = await auth.query(api.dashboard.getUpcomingDeadlines, { days: 7 });

      expect(result).toHaveLength(1);
      expect(result[0].employerName).toBe('Within 7');
    });

    it('includes overdue deadlines', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysAgo(5)),
        employerName: 'Overdue Corp',
      });

      const result = await auth.query(api.dashboard.getUpcomingDeadlines, {});

      expect(result).toHaveLength(1);
      expect(result[0].employerName).toBe('Overdue Corp');
      expect(result[0].daysUntil).toBe(-5);
    });

    it('sorts by daysUntil ascending (most urgent first)', async () => {
      const t = createTestContext();
      const auth = await createAuthenticatedContext(t, 'User A');

      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(20)),
        employerName: 'Later',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysFromNow(5)),
        employerName: 'Soon',
      });
      await auth.mutation(api.cases.create, {
        ...fixtures.pwdWithExpiration(daysAgo(3)),
        employerName: 'Overdue',
      });

      const result = await auth.query(api.dashboard.getUpcomingDeadlines, {});

      expect(result[0].employerName).toBe('Overdue');
      expect(result[1].employerName).toBe('Soon');
      expect(result[2].employerName).toBe('Later');
    });
  });
});
```
  </action>
  <verify>cd v2 && npm test -- convex/dashboard.test.ts --run 2>&1 | head -50</verify>
  <done>All integration tests fail (queries not yet implemented) - this is expected TDD state</done>
</task>

<task type="auto">
  <name>Task 5: Implement Convex Dashboard Queries to Pass Tests</name>
  <files>v2/convex/dashboard.ts</files>
  <action>
Implement the Convex queries to make all integration tests pass.

```typescript
// v2/convex/dashboard.ts
import { v } from "convex/values";
import { query } from "./_generated/server";
import { getCurrentUserId } from "./lib/auth";
import {
  extractDeadlines,
  groupDeadlinesByUrgency,
  calculateUrgency,
  sortByUrgency,
  buildPwdSubtext,
  buildRecruitmentSubtext,
  buildEta9089Subtext,
  buildI140Subtext,
} from "./lib/dashboard-helpers";
import {
  DeadlineItem,
  DeadlineGroups,
  DashboardSummary,
  StatusCount,
  RecentActivityItem,
  CaseStatus,
  ProgressStatus,
  ProgressBreakdown,
} from "./lib/dashboard-types";

// Get today's date as ISO string (server-side)
function getTodayISO(): string {
  const now = new Date();
  return now.toISOString().split('T')[0];
}

// Create empty breakdown
function emptyBreakdown(): ProgressBreakdown {
  return {
    working: 0,
    waiting_intake: 0,
    filed: 0,
    approved: 0,
    under_review: 0,
    rfi_rfe: 0,
  };
}

/**
 * Get all deadlines grouped by urgency
 */
export const getDeadlines = query({
  args: {},
  handler: async (ctx): Promise<DeadlineGroups> => {
    const userId = await getCurrentUserId(ctx);
    const todayISO = getTodayISO();

    // Fetch all non-deleted cases for user
    const cases = await ctx.db
      .query("cases")
      .withIndex("by_user_id", (q) => q.eq("userId", userId as any))
      .collect();

    const activeCases = cases.filter(c =>
      c.deletedAt === undefined && c.caseStatus !== 'closed'
    );

    // Extract deadlines from all active cases
    const allDeadlines: DeadlineItem[] = [];

    for (const c of activeCases) {
      const caseDeadlines = extractDeadlines(c, todayISO);

      for (const d of caseDeadlines) {
        allDeadlines.push({
          caseId: c._id,
          caseNumber: c.caseNumber ?? `CASE-${c._id.slice(-6)}`,
          employerName: c.employerName,
          beneficiaryName: c.beneficiaryIdentifier,
          deadlineType: d.deadlineType!,
          deadlineLabel: d.deadlineLabel!,
          dueDate: d.dueDate!,
          daysUntil: d.daysUntil!,
          urgency: d.urgency!,
          caseStatus: c.caseStatus as CaseStatus,
          progressStatus: c.progressStatus as ProgressStatus,
        });
      }
    }

    // Group by urgency
    return groupDeadlinesByUrgency(allDeadlines);
  },
});

/**
 * Get case counts by status with subtexts
 */
export const getSummary = query({
  args: {},
  handler: async (ctx): Promise<DashboardSummary> => {
    const userId = await getCurrentUserId(ctx);

    // Fetch all non-deleted cases for user
    const cases = await ctx.db
      .query("cases")
      .withIndex("by_user_id", (q) => q.eq("userId", userId as any))
      .collect();

    const activeCasesOnly = cases.filter(c => c.deletedAt === undefined);

    // Initialize counts
    const counts: Record<CaseStatus, ProgressBreakdown> = {
      pwd: emptyBreakdown(),
      recruitment: emptyBreakdown(),
      eta9089: emptyBreakdown(),
      i140: emptyBreakdown(),
      closed: emptyBreakdown(),
    };

    // Count by status and progress
    for (const c of activeCasesOnly) {
      const status = c.caseStatus as CaseStatus;
      const progress = c.progressStatus as ProgressStatus;
      counts[status][progress]++;
    }

    // Calculate totals
    const sum = (breakdown: ProgressBreakdown): number =>
      Object.values(breakdown).reduce((a, b) => a + b, 0);

    // Build status counts with subtexts
    const statusCounts: StatusCount[] = [
      {
        status: 'pwd',
        total: sum(counts.pwd),
        subtext: buildPwdSubtext(counts.pwd),
        breakdown: counts.pwd,
      },
      {
        status: 'recruitment',
        total: sum(counts.recruitment),
        subtext: buildRecruitmentSubtext(counts.recruitment),
        breakdown: counts.recruitment,
      },
      {
        status: 'eta9089',
        total: sum(counts.eta9089),
        subtext: buildEta9089Subtext(counts.eta9089),
        breakdown: counts.eta9089,
      },
      {
        status: 'i140',
        total: sum(counts.i140),
        subtext: buildI140Subtext(counts.i140),
        breakdown: counts.i140,
      },
      {
        status: 'closed',
        total: sum(counts.closed),
        subtext: `${sum(counts.closed)} archived`,
        breakdown: counts.closed,
      },
    ];

    // Complete = I-140 Approved (separate from Closed)
    const completedCases = counts.i140.approved;
    const closedCases = sum(counts.closed);
    const totalCases = activeCasesOnly.length;
    const activeCases = totalCases - completedCases - closedCases;

    return {
      statusCounts,
      totalCases,
      activeCases,
      completedCases,
      closedCases,
    };
  },
});

/**
 * Get last 5 updated cases for recent activity
 */
export const getRecentActivity = query({
  args: {},
  handler: async (ctx): Promise<RecentActivityItem[]> => {
    const userId = await getCurrentUserId(ctx);

    // Fetch cases ordered by updatedAt (need to collect and sort since index may not exist)
    const cases = await ctx.db
      .query("cases")
      .withIndex("by_user_id", (q) => q.eq("userId", userId as any))
      .collect();

    // Filter deleted and sort by updatedAt descending
    const activeCases = cases
      .filter(c => c.deletedAt === undefined)
      .sort((a, b) => {
        const aTime = a.updatedAt ?? a._creationTime;
        const bTime = b.updatedAt ?? b._creationTime;
        return bTime - aTime; // Descending
      })
      .slice(0, 5);

    return activeCases.map(c => ({
      caseId: c._id,
      caseNumber: c.caseNumber ?? `CASE-${c._id.slice(-6)}`,
      employerName: c.employerName,
      beneficiaryName: c.beneficiaryIdentifier,
      caseStatus: c.caseStatus as CaseStatus,
      progressStatus: c.progressStatus as ProgressStatus,
      updatedAt: c.updatedAt ?? c._creationTime,
      action: c.updatedAt ? 'updated' : 'created',
    }));
  },
});

/**
 * Get upcoming deadlines for next N days
 */
export const getUpcomingDeadlines = query({
  args: {
    days: v.optional(v.number()),
  },
  handler: async (ctx, args): Promise<DeadlineItem[]> => {
    const days = args.days ?? 30;
    const userId = await getCurrentUserId(ctx);
    const todayISO = getTodayISO();

    // Fetch all non-deleted cases for user
    const cases = await ctx.db
      .query("cases")
      .withIndex("by_user_id", (q) => q.eq("userId", userId as any))
      .collect();

    const activeCases = cases.filter(c =>
      c.deletedAt === undefined && c.caseStatus !== 'closed'
    );

    // Extract all deadlines
    const allDeadlines: DeadlineItem[] = [];

    for (const c of activeCases) {
      const caseDeadlines = extractDeadlines(c, todayISO);

      for (const d of caseDeadlines) {
        allDeadlines.push({
          caseId: c._id,
          caseNumber: c.caseNumber ?? `CASE-${c._id.slice(-6)}`,
          employerName: c.employerName,
          beneficiaryName: c.beneficiaryIdentifier,
          deadlineType: d.deadlineType!,
          deadlineLabel: d.deadlineLabel!,
          dueDate: d.dueDate!,
          daysUntil: d.daysUntil!,
          urgency: d.urgency!,
          caseStatus: c.caseStatus as CaseStatus,
          progressStatus: c.progressStatus as ProgressStatus,
        });
      }
    }

    // Filter to upcoming N days (include overdue)
    const upcoming = allDeadlines.filter(d => d.daysUntil <= days);

    // Sort by daysUntil ascending
    return sortByUrgency(upcoming);
  },
});
```
  </action>
  <verify>cd v2 && npm test -- convex/dashboard.test.ts --run</verify>
  <done>All integration tests pass (green)</done>
</task>

<task type="auto">
  <name>Task 6: Run Full Test Suite and Type Check</name>
  <files>N/A</files>
  <action>
Run full verification to ensure everything works together:

1. Type check entire codebase:
```bash
cd v2 && npx tsc --noEmit
```

2. Run all dashboard-related tests:
```bash
cd v2 && npm test -- dashboard --run
```

3. Run Convex dev to verify queries work:
```bash
cd v2 && npx convex dev --once
```

Fix any issues that arise.
  </action>
  <verify>cd v2 && npx tsc --noEmit && npm test -- dashboard --run</verify>
  <done>All type checks pass, all tests pass, Convex deploys successfully</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` - No TypeScript errors
- [ ] `npm test -- convex/lib/dashboard.test.ts --run` - All unit tests pass
- [ ] `npm test -- convex/dashboard.test.ts --run` - All integration tests pass
- [ ] `npx convex dev --once` - Convex deploys successfully
- [ ] Test fixtures are reusable for future phases
</verification>

<success_criteria>
- Test fixtures created with factory pattern
- Unit tests written BEFORE implementation (TDD)
- All pure helper functions tested in isolation
- Integration tests written BEFORE Convex queries
- All Convex queries tested with authentication and RLS
- 100% test coverage on new code
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-dashboard/20-01-SUMMARY.md`:

# Phase 20-01: Dashboard Data Layer Summary

**TDD implementation of dashboard queries with comprehensive test coverage.**

## Accomplishments
- Created reusable test fixtures (dashboard-fixtures.ts)
- Implemented helper functions with unit tests
- Built Convex queries with integration tests
- Achieved 100% test coverage

## Files Created/Modified
- `v2/test-utils/dashboard-fixtures.ts` - Test data factories
- `v2/convex/lib/dashboard-types.ts` - TypeScript types
- `v2/convex/lib/dashboard-helpers.ts` - Pure helper functions
- `v2/convex/lib/dashboard.test.ts` - Unit tests
- `v2/convex/dashboard.ts` - Convex queries
- `v2/convex/dashboard.test.ts` - Integration tests

## Test Coverage
- Unit tests: [X] tests
- Integration tests: [X] tests
- All passing

## Next Step
Ready for 20-02-PLAN.md (Dashboard Layout & Summary Tiles)
</output>
