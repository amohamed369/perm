---
phase: 09-feature-completion
plan: 02
type: execute
---

<objective>
Implement channel creation (watch subscription) and sync token logic for two-way calendar sync.

Purpose: Enable the app to subscribe to Google Calendar changes and fetch updates incrementally.
Output: Working channel subscription, change fetching, and channel renewal in scheduler.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-feature-completion/09-01-SUMMARY.md

**Codebase context:**
@backend/app/services/calendar_service.py
@backend/app/services/calendar_sync_service.py
@backend/app/services/scheduler_service.py
@backend/app/utils/google_oauth.py

**Research findings:**
- Channel creation: POST to /calendars/{calendarId}/events/watch
- Channels expire in ~7 days, need renewal job
- Use syncToken for incremental updates
- 410 GONE error = sync token expired, need full resync
- Deleted events have status='cancelled' in sync responses
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement channel creation (watch subscription)</name>
  <files>backend/app/services/calendar_sync_service.py</files>
  <action>
Add watch subscription methods to CalendarSyncService:

```python
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from app.services.calendar_service import CalendarService

# Add these methods to CalendarSyncService class:

@staticmethod
async def create_watch_channel(user_id: str, calendar_id: str = "primary") -> Dict:
    """
    Create a push notification channel for a user's calendar.

    This subscribes us to receive notifications when events change.
    Returns channel info including expiration timestamp.
    """
    # Get user's Google credentials
    credentials = CalendarService._get_credentials(user_id)
    if not credentials:
        raise ValueError(f"No Google credentials for user {user_id}")

    service = build("calendar", "v3", credentials=credentials)

    # Generate unique channel ID and token
    channel_id = CalendarSyncService.generate_channel_id()
    channel_token = CalendarSyncService.generate_channel_token(channel_id)

    # Webhook URL - use backend URL from settings
    # In test environment, this won't work without ngrok/tunnel
    webhook_url = f"{settings.backend_url}/api/webhooks/google-calendar"

    # Create watch request
    watch_body = {
        "id": channel_id,
        "type": "web_hook",
        "address": webhook_url,
        "token": channel_token,
    }

    try:
        response = service.events().watch(
            calendarId=calendar_id,
            body=watch_body
        ).execute()

        # Store channel in database
        channel = CalendarSyncService.create_channel(
            user_id=user_id,
            calendar_id=calendar_id,
            channel_id=channel_id,
            resource_id=response["resourceId"],
            expiration_timestamp=int(response["expiration"]),
        )

        logger.info(
            f"Created watch channel {channel_id} for user {user_id}, "
            f"expires at {response['expiration']}"
        )

        return channel

    except HttpError as e:
        logger.error(f"Failed to create watch channel: {e}")
        raise

@staticmethod
async def stop_watch_channel(channel_id: str, resource_id: str, user_id: str):
    """Stop a watch channel subscription"""
    credentials = CalendarService._get_credentials(user_id)
    if not credentials:
        logger.warning(f"No credentials for user {user_id}, cannot stop channel")
        return

    service = build("calendar", "v3", credentials=credentials)

    try:
        service.channels().stop(body={
            "id": channel_id,
            "resourceId": resource_id
        }).execute()

        logger.info(f"Stopped channel {channel_id}")

    except HttpError as e:
        # 404 = channel already expired/stopped - OK
        if e.resp.status != 404:
            logger.error(f"Error stopping channel {channel_id}: {e}")

    # Remove from database
    CalendarSyncService.delete_channel(channel_id)

@staticmethod
async def ensure_user_has_channel(user_id: str, calendar_id: str = "primary") -> Optional[Dict]:
    """
    Ensure user has an active sync channel.
    Creates one if missing or expired.
    Returns the channel info.
    """
    channel = CalendarSyncService.get_user_channel(user_id, calendar_id)

    if channel:
        # Check if expired or expiring soon (within 1 day)
        now_ms = int(datetime.utcnow().timestamp() * 1000)
        one_day_ms = 24 * 60 * 60 * 1000

        if channel["expiration_timestamp"] > now_ms + one_day_ms:
            return channel  # Still valid

        # Channel expired or expiring - stop and recreate
        logger.info(f"Channel {channel['channel_id']} expired/expiring, recreating")
        await CalendarSyncService.stop_watch_channel(
            channel["channel_id"],
            channel["resource_id"],
            user_id
        )

    # Create new channel
    return await CalendarSyncService.create_watch_channel(user_id, calendar_id)
```

Also add `backend_url` to settings if not present (check config.py).
  </action>
  <verify>Import check: `cd backend && python -c "from app.services.calendar_sync_service import CalendarSyncService; print('OK')"`</verify>
  <done>Watch subscription methods implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement sync token fetching and change detection</name>
  <files>backend/app/services/calendar_sync_service.py</files>
  <action>
Complete the process_webhook_notification method and add sync logic:

```python
# Add to CalendarSyncService class:

@staticmethod
async def do_initial_sync(user_id: str, calendar_id: str = "primary") -> str:
    """
    Perform initial full sync to get the first sync token.
    Returns the sync token for incremental updates.
    """
    credentials = CalendarService._get_credentials(user_id)
    if not credentials:
        raise ValueError(f"No Google credentials for user {user_id}")

    service = build("calendar", "v3", credentials=credentials)

    # Get all events (we don't store them - just get the sync token)
    # We only sync OUR events, not all calendar events
    sync_token = None
    page_token = None

    while True:
        response = service.events().list(
            calendarId=calendar_id,
            maxResults=2500,
            pageToken=page_token,
            singleEvents=True,  # Expand recurring events
        ).execute()

        page_token = response.get("nextPageToken")
        if not page_token:
            sync_token = response.get("nextSyncToken")
            break

    logger.info(f"Initial sync complete for user {user_id}, got sync token")
    return sync_token

@staticmethod
async def process_webhook_notification(channel_id: str, resource_id: str):
    """
    Process a webhook notification by fetching changes.
    This is called as a background task after webhook received.
    """
    channel = CalendarSyncService.get_channel(channel_id)
    if not channel:
        logger.warning(f"Unknown channel {channel_id} - ignoring notification")
        return

    user_id = channel["user_id"]
    calendar_id = channel["calendar_id"]
    sync_token = channel.get("sync_token")

    # If no sync token, we need initial sync first
    if not sync_token:
        logger.info(f"No sync token for channel {channel_id}, doing initial sync")
        sync_token = await CalendarSyncService.do_initial_sync(user_id, calendar_id)
        CalendarSyncService.update_sync_token(channel_id, sync_token)
        return

    # Fetch changes using sync token
    try:
        changes, new_token = await CalendarSyncService.fetch_changes(
            user_id, calendar_id, sync_token
        )

        if changes:
            await CalendarSyncService.process_event_changes(user_id, changes)

        # Update sync token
        CalendarSyncService.update_sync_token(channel_id, new_token)

    except HttpError as e:
        if e.resp.status == 410:
            # Sync token expired - need full resync
            logger.warning(f"Sync token expired for channel {channel_id}, doing full resync")
            new_token = await CalendarSyncService.do_initial_sync(user_id, calendar_id)
            CalendarSyncService.update_sync_token(channel_id, new_token)
        else:
            raise

@staticmethod
async def fetch_changes(
    user_id: str,
    calendar_id: str,
    sync_token: str
) -> tuple[List[Dict], str]:
    """
    Fetch incremental changes since last sync.
    Returns (list of changed events, new sync token).
    """
    credentials = CalendarService._get_credentials(user_id)
    service = build("calendar", "v3", credentials=credentials)

    events = []
    page_token = None
    new_sync_token = None

    while True:
        response = service.events().list(
            calendarId=calendar_id,
            syncToken=sync_token,
            pageToken=page_token,
        ).execute()

        events.extend(response.get("items", []))

        page_token = response.get("nextPageToken")
        if not page_token:
            new_sync_token = response.get("nextSyncToken")
            break

    logger.info(f"Fetched {len(events)} changed events for user {user_id}")
    return events, new_sync_token

@staticmethod
async def process_event_changes(user_id: str, events: List[Dict]):
    """
    Process changed events from Google Calendar.
    Currently logs changes - full conflict resolution in 09-03.
    """
    supabase = get_supabase_client()

    for event in events:
        event_id = event.get("id")
        status = event.get("status")
        summary = event.get("summary", "")

        # Check if this is one of our PERM deadline events
        # Our events have descriptions containing "PERM Tracker" or case IDs
        description = event.get("description", "")
        is_our_event = "PERM Tracker" in description or "permtracker.app" in description

        if not is_our_event:
            # Not our event - skip
            continue

        if status == "cancelled":
            logger.info(f"Event {event_id} was deleted in Google Calendar")
            # TODO (09-03): Handle deletion - remove from calendar_event_ids
        else:
            logger.info(
                f"Event {event_id} was modified in Google Calendar: {summary}"
            )
            # TODO (09-03): Handle modification - check for conflicts

    # Update last synced timestamp for user
    supabase.table("perm_users").update({
        "calendar_last_synced_at": datetime.utcnow().isoformat()
    }).eq("id", user_id).execute()
```
  </action>
  <verify>Import check with all dependencies: `cd backend && python -c "from app.services.calendar_sync_service import CalendarSyncService; print('OK')"`</verify>
  <done>Sync token logic implemented with change detection</done>
</task>

<task type="auto">
  <name>Task 3: Add channel renewal to scheduler</name>
  <files>backend/app/services/scheduler_service.py</files>
  <action>
Add channel renewal job to the existing DeadlineScheduler:

```python
# Add import at top:
from app.services.calendar_sync_service import CalendarSyncService

# Modify start() method to add channel renewal job:
def start(self):
    """Start the scheduler"""
    if self.is_running:
        logger.warning("Scheduler is already running")
        return

    # Schedule daily deadline check at 9 AM
    self.scheduler.add_job(
        self.check_all_deadlines,
        "cron",
        hour=9,
        minute=0,
        id="daily_deadline_check",
        replace_existing=True,
    )

    # Schedule channel renewal check at 3 AM daily
    self.scheduler.add_job(
        self.renew_expiring_channels,
        "cron",
        hour=3,
        minute=0,
        id="daily_channel_renewal",
        replace_existing=True,
    )

    self.scheduler.start()
    self.is_running = True
    logger.info(
        "Scheduler started - deadline check at 9 AM, channel renewal at 3 AM"
    )

# Add new method:
async def renew_expiring_channels(self):
    """
    Renew calendar sync channels expiring within 2 days.
    Runs daily at 3 AM.
    """
    try:
        logger.info("Starting channel renewal check...")

        expiring = CalendarSyncService.get_expiring_channels(within_days=2)

        if not expiring:
            logger.info("No channels expiring soon")
            return

        logger.info(f"Found {len(expiring)} channels expiring within 2 days")

        renewed = 0
        failed = 0

        for channel in expiring:
            try:
                # Create new channel (this will stop the old one)
                await CalendarSyncService.ensure_user_has_channel(
                    user_id=channel["user_id"],
                    calendar_id=channel["calendar_id"]
                )
                renewed += 1

            except Exception as e:
                logger.error(
                    f"Failed to renew channel {channel['channel_id']}: {e}"
                )
                failed += 1

        logger.info(f"Channel renewal complete: {renewed} renewed, {failed} failed")

    except Exception as e:
        logger.error(f"Error during channel renewal: {e}")
```

Also add a perm_users.calendar_last_synced_at column if needed:
Check if migration 025 needs to add this to perm_users table.
  </action>
  <verify>Scheduler starts: `cd backend && python -c "from app.services.scheduler_service import DeadlineScheduler; print('OK')"`</verify>
  <done>Channel renewal job added to scheduler</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Watch subscription creates channel in Google Calendar API
- [ ] Sync token fetching works with pagination
- [ ] Scheduler includes channel renewal job
- [ ] Backend starts successfully with all new code
</verification>

<success_criteria>
- Channel creation (watch) implemented with proper Google API calls
- Sync token logic handles incremental updates and 410 errors
- Scheduler renews expiring channels daily at 3 AM
- All imports work, backend starts
</success_criteria>

<output>
After completion, create `.planning/phases/09-feature-completion/09-02-SUMMARY.md`
</output>
