# Phase 25.1: Calendar Sync (One-Way) - Research

**Researched:** 2025-12-31
**Domain:** Next.js App Router + Convex + Google Calendar API OAuth integration
**Confidence:** HIGH

<research_summary>
## Summary

Researched the ecosystem for building Google Calendar sync with Next.js App Router and Convex backend. The standard approach uses Next.js API routes for OAuth flow, Convex actions for Google API calls, and stores tokens in the Convex database.

Key finding: OAuth callback MUST go through Next.js API routes (not Convex HTTP actions) because it needs to interact with browser cookies/session and perform redirects. Convex actions handle the actual Google Calendar API calls after tokens are stored.

**Primary recommendation:** Use Next.js API routes for OAuth (`/api/auth/google/connect`, `/api/auth/google/callback`), store encrypted tokens in `userProfiles` table, use Convex `internalAction` for calendar API calls scheduled from mutations.

</research_summary>

<standard_stack>
## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `googleapis` | ^147.0.0 | Google API client for Calendar operations | Official Google Node.js client |
| `google-auth-library` | ^9.x | OAuth2 client for token management | Official, handles refresh automatically |
| `next/server` | (Next.js) | API routes for OAuth flow | App Router standard, secure cookies |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `@types/google.accounts` | ^0.0.x | TypeScript types for Google auth | Type safety in client-side OAuth |
| None needed | - | Token encryption | Use Convex environment variables for secrets |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| googleapis | google-auth-library only + fetch | googleapis is higher level, less boilerplate |
| Manual OAuth | Auth.js/NextAuth | Auth.js adds complexity for single-provider case |
| Next.js API routes | Convex HTTP actions | HTTP actions can't set cookies or redirect browser |

**Installation:**
```bash
pnpm add googleapis google-auth-library
```

</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Recommended Project Structure
```
v2/
├── src/app/api/auth/google/
│   ├── connect/route.ts      # Initiates OAuth flow
│   └── callback/route.ts     # Handles OAuth callback
├── convex/
│   ├── calendar.ts           # Public mutations (sync toggles)
│   ├── calendarActions.ts    # Internal actions (API calls)
│   └── lib/
│       └── googleCalendar.ts # Google API helpers
```

### Pattern 1: OAuth Flow via Next.js API Routes
**What:** Use Next.js route handlers for OAuth initiation and callback
**When to use:** Always - browser redirects need server-side handling
**Example:**
```typescript
// v2/src/app/api/auth/google/connect/route.ts
import { NextResponse } from 'next/server';
import { google } from 'googleapis';
import { auth } from '@/auth'; // or getAuthUserId pattern

const oauth2Client = new google.auth.OAuth2(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/google/callback`
);

export async function GET() {
  // Verify user is authenticated first
  const session = await auth();
  if (!session?.user) {
    return NextResponse.redirect('/signin');
  }

  const authUrl = oauth2Client.generateAuthUrl({
    access_type: 'offline', // CRITICAL: Get refresh token
    prompt: 'consent',      // Force consent to always get refresh token
    scope: ['https://www.googleapis.com/auth/calendar.events'],
    state: session.user.id, // Pass user ID for callback
  });

  return NextResponse.redirect(authUrl);
}
```

### Pattern 2: Convex Actions for External API Calls
**What:** Use `internalAction` for Google Calendar API operations, scheduled from mutations
**When to use:** All external API calls must go through actions, not mutations
**Example:**
```typescript
// convex/calendarActions.ts
import { internalAction } from './_generated/server';
import { v } from 'convex/values';
import { google } from 'googleapis';

export const createCalendarEvent = internalAction({
  args: {
    userId: v.id('users'),
    accessToken: v.string(),
    refreshToken: v.string(),
    event: v.object({
      summary: v.string(),
      description: v.string(),
      startDate: v.string(),
    }),
  },
  handler: async (ctx, args) => {
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET
    );

    oauth2Client.setCredentials({
      access_token: args.accessToken,
      refresh_token: args.refreshToken,
    });

    const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

    const event = await calendar.events.insert({
      calendarId: 'primary',
      requestBody: {
        summary: args.event.summary,
        description: args.event.description,
        start: { date: args.event.startDate },
        end: { date: args.event.startDate },
      },
    });

    return { eventId: event.data.id };
  },
});
```

### Pattern 3: Mutation → Schedule Action Pattern
**What:** Client calls mutation, mutation schedules action for external API work
**When to use:** Always for external API calls - never call actions directly from client
**Example:**
```typescript
// convex/calendar.ts
import { mutation, internalMutation } from './_generated/server';
import { internal } from './_generated/api';

export const syncCaseToCalendar = mutation({
  args: { caseId: v.id('cases') },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error('Unauthorized');

    const user = await ctx.db.get(userId);
    if (!user?.googleRefreshToken) {
      throw new Error('Calendar not connected');
    }

    // Schedule the action - don't call directly
    await ctx.scheduler.runAfter(0, internal.calendarActions.syncCase, {
      userId,
      caseId: args.caseId,
    });

    return { scheduled: true };
  },
});
```

### Pattern 4: Token Storage in Database
**What:** Store Google OAuth tokens in userProfiles table
**When to use:** Always - tokens must persist across sessions
**Example:**
```typescript
// convex/schema.ts additions
userProfiles: defineTable({
  userId: v.id('users'),
  // ... existing fields ...
  googleAccessToken: v.optional(v.string()),
  googleRefreshToken: v.optional(v.string()),
  googleTokenExpiry: v.optional(v.number()), // Unix timestamp
  googleCalendarConnected: v.optional(v.boolean()),
  calendarEventIds: v.optional(v.record(v.string(), v.string())), // caseId -> eventId map
}).index('by_userId', ['userId']),
```

### Anti-Patterns to Avoid
- **Calling actions directly from client:** Always go through mutations that schedule actions
- **OAuth via Convex HTTP actions:** Can't handle browser redirects or set cookies properly
- **Storing tokens in client-side state:** Tokens must persist in database
- **Not using `prompt: 'consent'`:** Won't get refresh_token on reconnect without it
- **Blocking case operations on sync failures:** Sync should be best-effort, log failures

</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| OAuth token refresh | Manual expiry checking | google-auth-library auto-refresh | Library handles edge cases, token race conditions |
| Token encryption | Custom encryption | Convex environment variables | Store secrets server-side only, not in DB |
| OAuth state verification | Manual state management | Built-in state parameter | Google OAuth handles CSRF via state |
| Rate limiting | Custom throttling | Exponential backoff on 429 | Google API returns proper rate limit headers |
| Event ID tracking | Complex sync logic | Simple caseId → eventId map | Delete-and-recreate is simpler than sync |

**Key insight:** The v1 implementation already solved most edge cases. The v2 implementation should mirror v1's patterns (delete-and-recreate on update, best-effort sync, token auto-disconnect on revocation) rather than inventing new approaches.

</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Missing Refresh Token on Reconnect
**What goes wrong:** After disconnecting and reconnecting, no refresh_token is returned
**Why it happens:** Google only returns refresh_token on first authorization unless `prompt: 'consent'` is set
**How to avoid:** Always include `prompt: 'consent'` in generateAuthUrl options
**Warning signs:** Access works initially but fails after token expires (~1 hour)

### Pitfall 2: Token Expiry in Test Mode
**What goes wrong:** Tokens stop working after 7 days
**Why it happens:** Google Cloud project in "Testing" mode has 7-day token expiry
**How to avoid:** Publish OAuth consent screen to production (requires verification for sensitive scopes)
**Warning signs:** Working in dev but users report disconnects in production after a week

### Pitfall 3: Calling Convex Actions Directly from Client
**What goes wrong:** Actions called without mutation wrapper, invariants not enforced
**Why it happens:** Seems simpler to skip mutation layer
**How to avoid:** Always: client → mutation → scheduler → action
**Warning signs:** Duplicate API calls, race conditions, inconsistent state

### Pitfall 4: Blocking Case Operations on Sync Failure
**What goes wrong:** User can't save case because calendar sync failed
**Why it happens:** Treating sync as part of the critical path
**How to avoid:** Sync after case save succeeds, log failures but don't block
**Warning signs:** User complaints about "can't save case" when Google is down

### Pitfall 5: OAuth Callback in Wrong Place
**What goes wrong:** OAuth redirect fails or tokens can't be stored
**Why it happens:** Using Convex HTTP actions instead of Next.js API routes for OAuth callback
**How to avoid:** OAuth initiation and callback MUST be Next.js API routes
**Warning signs:** Redirect loops, "Invalid state" errors, cookies not setting

### Pitfall 6: Not Handling Revoked Tokens
**What goes wrong:** Silent failures when user revokes access from Google settings
**Why it happens:** Not catching RefreshError and auto-disconnecting
**How to avoid:** Catch token refresh failures, set googleCalendarConnected = false, show reconnect prompt
**Warning signs:** Calendar sync silently stops working for some users

### Pitfall 7: Stale Event IDs After Google Deletion
**What goes wrong:** Trying to update/delete events that user deleted in Google Calendar
**Why it happens:** App has event IDs that no longer exist in Google
**How to avoid:** On 404 from Google, remove stale ID from database
**Warning signs:** "Event not found" errors in logs

</common_pitfalls>

<code_examples>
## Code Examples

Verified patterns from official sources and v1 implementation:

### OAuth Callback Route Handler
```typescript
// v2/src/app/api/auth/google/callback/route.ts
// Source: Next.js docs + Google OAuth best practices

import { NextRequest, NextResponse } from 'next/server';
import { google } from 'googleapis';
import { ConvexHttpClient } from 'convex/browser';
import { api } from '@/convex/_generated/api';

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export async function GET(request: NextRequest) {
  const code = request.nextUrl.searchParams.get('code');
  const state = request.nextUrl.searchParams.get('state'); // User ID
  const error = request.nextUrl.searchParams.get('error');

  if (error) {
    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/settings?error=oauth_denied`
    );
  }

  if (!code || !state) {
    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/settings?error=oauth_failed`
    );
  }

  try {
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/google/callback`
    );

    const { tokens } = await oauth2Client.getToken(code);

    // Store tokens in Convex via internal mutation
    // (Need to call Convex from Next.js API route)
    await convex.mutation(api.calendar.storeGoogleTokens, {
      userId: state, // The user ID from state
      accessToken: tokens.access_token!,
      refreshToken: tokens.refresh_token!,
      expiryDate: tokens.expiry_date!,
    });

    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/settings?success=calendar_connected`
    );
  } catch (err) {
    console.error('OAuth callback error:', err);
    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/settings?error=oauth_exchange_failed`
    );
  }
}
```

### Google Calendar Event Creation (Convex Action)
```typescript
// convex/calendarActions.ts
// Source: googleapis docs + v1 patterns

import { internalAction } from './_generated/server';
import { v } from 'convex/values';
import { google } from 'googleapis';

export const createEvent = internalAction({
  args: {
    accessToken: v.string(),
    refreshToken: v.string(),
    summary: v.string(),
    description: v.string(),
    date: v.string(), // YYYY-MM-DD format
  },
  handler: async (ctx, args) => {
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET
    );

    oauth2Client.setCredentials({
      access_token: args.accessToken,
      refresh_token: args.refreshToken,
    });

    // Listen for token refresh events
    oauth2Client.on('tokens', (tokens) => {
      // In production, you'd schedule a mutation to update stored tokens
      console.log('New access token:', tokens.access_token);
    });

    const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

    try {
      const event = await calendar.events.insert({
        calendarId: 'primary',
        requestBody: {
          summary: args.summary,
          description: args.description,
          start: { date: args.date },
          end: { date: args.date },
        },
      });

      return {
        success: true,
        eventId: event.data.id,
        htmlLink: event.data.htmlLink,
      };
    } catch (error: any) {
      if (error.code === 401 || error.code === 403) {
        return { success: false, error: 'TOKEN_REVOKED' };
      }
      if (error.code === 429) {
        return { success: false, error: 'RATE_LIMITED' };
      }
      throw error;
    }
  },
});
```

### Event Title Format (Match v1)
```typescript
// convex/lib/calendarHelpers.ts
// Source: v1 backend/app/services/calendar_integration.py

export function formatEventTitle(
  eventType: string,
  employerName: string,
  rfiNumber?: number
): string {
  // Match v1 format exactly
  // Examples:
  // - "PWD Expiration: Acme Corp"
  // - "I-140 Deadline: Tech Solutions Inc"
  // - "RFI Response Due: Global Services - RFI #1"

  const titles: Record<string, string> = {
    pwd_expiration: 'PWD Expiration',
    eta9089_filing: 'ETA 9089 Filing',
    eta9089_expiration: 'ETA 9089 Expiration',
    ready_to_file: 'Ready to File',
    recruitment_expires: 'Recruitment Expires',
    i140_deadline: 'I-140 Deadline',
    rfi_response: 'RFI Response Due',
    rfe_response: 'RFE Response Due',
  };

  const title = titles[eventType] || eventType;

  if (rfiNumber !== undefined) {
    return `${title}: ${employerName} - RFI #${rfiNumber}`;
  }

  return `${title}: ${employerName}`;
}
```

</code_examples>

<sota_updates>
## State of the Art (2024-2025)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Pages Router API routes | App Router route handlers | 2023+ | Use `route.ts` not `pages/api` |
| Manual token refresh | google-auth-library auto-refresh | Stable | Library handles refresh transparently |
| Sync tokens in realtime | Store encrypted in DB | Best practice | Persist across sessions |
| Auth.js for all OAuth | Direct googleapis for single-provider | Case-by-case | Auth.js overkill for just Google Calendar |

**New tools/patterns to consider:**
- **Server Actions for form submissions:** Could simplify "Sync All" button but not needed for OAuth flow
- **Convex Actions with fetch:** Actions can use native fetch, don't need full googleapis if just calling REST endpoints

**Deprecated/outdated:**
- **Convex HTTP actions for OAuth:** Don't use - can't handle browser redirects properly
- **Storing tokens in localStorage:** Security risk, tokens belong server-side
- **Implicit OAuth flow:** Google deprecated, use authorization code flow only

</sota_updates>

<open_questions>
## Open Questions

Things that couldn't be fully resolved:

1. **Token encryption in Convex**
   - What we know: Convex stores data encrypted at rest, env vars for secrets
   - What's unclear: Should refresh tokens be additionally encrypted before storing in DB?
   - Recommendation: Start with storing as-is (Convex encrypted at rest), add encryption layer if compliance requires

2. **Concurrent token refresh**
   - What we know: google-auth-library handles token refresh automatically
   - What's unclear: What happens if two actions try to refresh simultaneously?
   - Recommendation: The library handles this with token locks, but monitor for issues

3. **Batch event operations**
   - What we know: Google Calendar API supports batch requests
   - What's unclear: Is it worth the complexity for our use case?
   - Recommendation: Start with sequential calls, add batching only if performance is an issue

</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- `/llmstxt/convex_dev_llms-full_txt` - Convex actions, scheduling, mutations
- `/vercel/next.js` - App Router route handlers, authentication patterns
- `/websites/googleapis_dev_nodejs_googleapis` - Google Calendar API, OAuth flow
- v1 implementation: `backend/app/services/calendar_integration.py`, `calendar_service.py`, `utils/google_oauth.py`

### Secondary (MEDIUM confidence)
- [Google OAuth 2.0 for Web Server Applications](https://developers.google.com/identity/protocols/oauth2/web-server) - OAuth flow details
- [Convex Environment Variables](https://docs.convex.dev/production/environment-variables) - Secrets management
- [Convex Auth with Next.js](https://labs.convex.dev/auth/authz/nextjs) - Server-side auth patterns

### Tertiary (LOW confidence - needs validation)
- None - all findings verified with official sources

</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: Next.js App Router + Convex + Google Calendar API
- Ecosystem: googleapis, google-auth-library
- Patterns: OAuth flow, action scheduling, token storage
- Pitfalls: Token refresh, test mode expiry, revoked tokens

**Confidence breakdown:**
- Standard stack: HIGH - verified with Context7, official docs
- Architecture: HIGH - from Convex docs + v1 patterns
- Pitfalls: HIGH - documented in v1 code, Google docs
- Code examples: HIGH - from Context7/official sources + v1

**Research date:** 2025-12-31
**Valid until:** 2026-01-30 (30 days - stable ecosystem)

</metadata>

---

*Phase: 25.1-calendar-sync*
*Research completed: 2025-12-31*
*Ready for planning: yes*
