---
phase: 25.1-calendar-sync
plan: 02
type: execute
domain: convex-google-api
---

<objective>
Implement Google Calendar event CRUD operations as Convex actions.

Purpose: Create reusable actions for creating, updating, and deleting calendar events for case deadlines.
Output: Working Convex actions that sync case deadlines to Google Calendar using the OAuth tokens from Plan 01.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25.1-calendar-sync/25.1-CONTEXT.md
@.planning/phases/25.1-calendar-sync/25.1-01-SUMMARY.md

**Depends on:** Plan 01 (OAuth Infrastructure) - tokens are stored and refreshable

**Codebase constraints:**
- Convex actions for external API calls
- googleapis library for Calendar API
- All dates are ISO strings (YYYY-MM-DD)
- UTC all-day events only

**Event Format (from v1):**
- Title: "{Type}: {Employer}" (e.g., "PWD Expiration: Acme Corp")
- All-day events with UTC timezone
- Description: Multi-line with case details

**8 Event Types:**
| Event Type | Schema Field |
|------------|--------------|
| PWD Expiration | pwdExpirationDate |
| ETA 9089 Filing | eta9089FilingDate |
| ETA 9089 Expiration | eta9089ExpirationDate |
| Ready to File | filingWindowOpens |
| Recruitment Expires | recruitmentWindowCloses |
| I-140 Deadline | calculateI140Deadline(eta9089CertificationDate) |
| RFI Response Due | rfiEntries[].responseDueDate |
| RFE Response Due | rfeEntries[].responseDueDate |

**v1 Reference:**
- Calendar service: `backend/app/services/calendar_service.py`
- Event creation: `backend/app/services/calendar_integration.py`

## Required Reading (MANDATORY)
| Doc | Path | Purpose |
|-----|------|---------|
| perm_flow.md | `/Users/adammohamed/cc/perm-tracker-test/perm_flow.md` | SOURCE OF TRUTH |
| v2/CLAUDE.md | `/Users/adammohamed/cc/perm-tracker-test/v2/CLAUDE.md` | API patterns |
| CONTEXT.md | `.planning/phases/25.1-calendar-sync/25.1-CONTEXT.md` | Edge cases |

## Quality Standards
- DRY - Abstract common patterns
- KISS - Minimal complexity
- Best-effort sync - Don't block on failures
- Log errors, return results
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create calendar event helper utilities</name>
  <files>
    v2/convex/lib/calendarHelpers.ts
    v2/convex/lib/calendarTypes.ts
  </files>
  <exploration>
    Use Explore agent to understand:
    - Existing deadline calculation patterns in convex/lib/perm/
    - Case data structure from schema.ts
    - v1 event formatting in calendar_integration.py
  </exploration>
  <action>
    Create helper utilities for calendar event formatting:

    1. **v2/convex/lib/calendarTypes.ts** - Type definitions:
       ```typescript
       // Event types that can be synced
       export type CalendarEventType =
         | 'pwd_expiration'
         | 'eta9089_filing'
         | 'eta9089_expiration'
         | 'filing_window_opens'
         | 'recruitment_expires'
         | 'i140_deadline'
         | 'rfi_due'
         | 'rfe_due';

       // Mapping from event type to sync preference field
       export const EVENT_TYPE_TO_PREF: Record<CalendarEventType, string> = {
         pwd_expiration: 'calendarSyncPwd',
         eta9089_filing: 'calendarSyncEta9089',
         eta9089_expiration: 'calendarSyncEta9089',
         filing_window_opens: 'calendarSyncFilingWindow',
         recruitment_expires: 'calendarSyncRecruitment',
         i140_deadline: 'calendarSyncI140',
         rfi_due: 'calendarSyncRfi',
         rfe_due: 'calendarSyncRfe',
       };

       // Google Calendar event input
       export interface CalendarEventInput {
         type: CalendarEventType;
         date: string; // ISO date YYYY-MM-DD
         employerName: string;
         beneficiaryIdentifier?: string;
         caseId: string;
         rfiRfeId?: string; // For RFI/RFE events
       }

       // Google Calendar event response
       export interface CalendarEventResult {
         eventId: string;
         type: CalendarEventType;
         success: boolean;
         error?: string;
       }
       ```

    2. **v2/convex/lib/calendarHelpers.ts** - Formatting utilities:
       ```typescript
       import type { CalendarEventInput, CalendarEventType } from './calendarTypes';

       // Event type display names
       const EVENT_TYPE_LABELS: Record<CalendarEventType, string> = {
         pwd_expiration: 'PWD Expiration',
         eta9089_filing: 'ETA 9089 Filing',
         eta9089_expiration: 'ETA 9089 Expiration',
         filing_window_opens: 'Ready to File',
         recruitment_expires: 'Recruitment Window',
         i140_deadline: 'I-140 Deadline',
         rfi_due: 'RFI Response Due',
         rfe_due: 'RFE Response Due',
       };

       // Format event title: "{Type}: {Employer}"
       export function formatEventTitle(input: CalendarEventInput): string {
         const label = EVENT_TYPE_LABELS[input.type];
         // Truncate employer name if too long (max 100 chars total)
         const maxEmployerLen = 100 - label.length - 2;
         const employer = input.employerName.length > maxEmployerLen
           ? input.employerName.slice(0, maxEmployerLen - 3) + '...'
           : input.employerName;
         return `${label}: ${employer}`;
       }

       // Format event description with case details
       export function formatEventDescription(input: CalendarEventInput): string {
         const lines = [
           `Case: ${input.beneficiaryIdentifier || 'N/A'}`,
           `Employer: ${input.employerName}`,
           `Type: ${EVENT_TYPE_LABELS[input.type]}`,
           '',
           `Case ID: ${input.caseId}`,
         ];
         if (input.rfiRfeId) {
           lines.push(`RFI/RFE ID: ${input.rfiRfeId}`);
         }
         return lines.join('\n');
       }

       // Check if date is in the future (skip past deadlines)
       export function isFutureDate(dateStr: string): boolean {
         const today = new Date().toISOString().slice(0, 10);
         return dateStr > today;
       }

       // Convert ISO date to Google Calendar all-day event format
       export function toGoogleCalendarDate(dateStr: string): { date: string } {
         // All-day events use 'date' field (not 'dateTime')
         return { date: dateStr };
       }
       ```
  </action>
  <verify>
    - `cd v2 && pnpm build` compiles without errors
    - Helper functions are pure and testable
  </verify>
  <done>
    Calendar helper utilities created with proper typing and formatting
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Google Calendar API action for event CRUD</name>
  <files>
    v2/convex/googleCalendarActions.ts (extend from Plan 01)
  </files>
  <exploration>
    Use researcher agent to verify:
    - Google Calendar API v3 event insert/update/delete endpoints
    - googleapis library calendar.events methods
    - Error codes (404 for deleted events, 429 for rate limit)
  </exploration>
  <action>
    Extend googleCalendarActions.ts with event CRUD operations:

    ```typescript
    import { google } from 'googleapis';
    import { formatEventTitle, formatEventDescription, toGoogleCalendarDate, isFutureDate } from './lib/calendarHelpers';
    import type { CalendarEventInput, CalendarEventResult } from './lib/calendarTypes';

    // Create a single calendar event
    export const createCalendarEvent = internalAction({
      args: {
        userId: v.id("users"),
        event: v.object({
          type: v.string(),
          date: v.string(),
          employerName: v.string(),
          beneficiaryIdentifier: v.optional(v.string()),
          caseId: v.string(),
          rfiRfeId: v.optional(v.string()),
        }),
      },
      handler: async (ctx, args): Promise<CalendarEventResult> => {
        const { userId, event } = args;

        // Skip past dates
        if (!isFutureDate(event.date)) {
          return { eventId: '', type: event.type, success: false, error: 'Past date skipped' };
        }

        try {
          // Get valid access token (refreshes if needed)
          const accessToken = await ctx.runAction(internal.googleCalendarActions.getValidAccessToken, { userId });

          // Create Google Calendar client
          const oauth2Client = new google.auth.OAuth2();
          oauth2Client.setCredentials({ access_token: accessToken });
          const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

          // Create event
          const response = await calendar.events.insert({
            calendarId: 'primary',
            requestBody: {
              summary: formatEventTitle(event as CalendarEventInput),
              description: formatEventDescription(event as CalendarEventInput),
              start: toGoogleCalendarDate(event.date),
              end: toGoogleCalendarDate(event.date),
              reminders: { useDefault: false },
            },
          });

          return {
            eventId: response.data.id!,
            type: event.type as CalendarEventType,
            success: true,
          };
        } catch (error: any) {
          console.error(`Failed to create calendar event:`, error.message);
          return {
            eventId: '',
            type: event.type as CalendarEventType,
            success: false,
            error: error.message,
          };
        }
      },
    });

    // Delete a calendar event by ID
    export const deleteCalendarEvent = internalAction({
      args: {
        userId: v.id("users"),
        eventId: v.string(),
      },
      handler: async (ctx, args): Promise<{ success: boolean; error?: string }> => {
        try {
          const accessToken = await ctx.runAction(internal.googleCalendarActions.getValidAccessToken, { userId: args.userId });

          const oauth2Client = new google.auth.OAuth2();
          oauth2Client.setCredentials({ access_token: accessToken });
          const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

          await calendar.events.delete({
            calendarId: 'primary',
            eventId: args.eventId,
          });

          return { success: true };
        } catch (error: any) {
          // 404 means event already deleted - treat as success
          if (error.code === 404) {
            console.log(`Event ${args.eventId} already deleted from Google`);
            return { success: true };
          }
          console.error(`Failed to delete calendar event:`, error.message);
          return { success: false, error: error.message };
        }
      },
    });

    // Update event by deleting old and creating new (simple, reliable)
    export const updateCalendarEvent = internalAction({
      args: {
        userId: v.id("users"),
        oldEventId: v.optional(v.string()),
        event: v.object({
          type: v.string(),
          date: v.string(),
          employerName: v.string(),
          beneficiaryIdentifier: v.optional(v.string()),
          caseId: v.string(),
          rfiRfeId: v.optional(v.string()),
        }),
      },
      handler: async (ctx, args): Promise<CalendarEventResult> => {
        // Delete old event if exists
        if (args.oldEventId) {
          await ctx.runAction(internal.googleCalendarActions.deleteCalendarEvent, {
            userId: args.userId,
            eventId: args.oldEventId,
          });
        }

        // Create new event
        return await ctx.runAction(internal.googleCalendarActions.createCalendarEvent, {
          userId: args.userId,
          event: args.event,
        });
      },
    });
    ```

    **Key behaviors:**
    - Skip past dates (only sync future deadlines)
    - Delete-and-recreate on update (simple, reliable, matches v1)
    - Handle 404 on delete gracefully (event already gone)
    - Log errors but return results (best-effort sync)
  </action>
  <verify>
    - `cd v2 && npx convex dev` runs without errors
    - Dependencies: `pnpm add googleapis`
    - Types are correct for event input/output
  </verify>
  <done>
    Calendar event CRUD actions created with proper error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Create bulk sync action for all case events</name>
  <files>
    v2/convex/googleCalendarActions.ts (continue)
    v2/convex/lib/calendarEventExtractor.ts
  </files>
  <exploration>
    Use Explore agent to understand:
    - Case data structure from schema.ts
    - Deadline calculation patterns in lib/perm/calculators/
    - How to extract all deadline dates from a case
  </exploration>
  <action>
    Create utilities to extract deadlines from a case and sync all events:

    1. **v2/convex/lib/calendarEventExtractor.ts** - Extract deadlines from case:
       ```typescript
       import type { CalendarEventInput, CalendarEventType } from './calendarTypes';
       import { calculateI140FilingDeadline } from './perm/calculators/i140';
       import { isFutureDate } from './calendarHelpers';

       interface CaseData {
         _id: string;
         employerName: string;
         beneficiaryIdentifier: string;
         pwdExpirationDate?: string;
         eta9089FilingDate?: string;
         eta9089ExpirationDate?: string;
         eta9089CertificationDate?: string;
         filingWindowOpens?: string;
         recruitmentWindowCloses?: string;
         rfiEntries?: Array<{ id: string; responseDueDate: string; responseSubmittedDate?: string }>;
         rfeEntries?: Array<{ id: string; responseDueDate: string; responseSubmittedDate?: string }>;
       }

       interface UserPreferences {
         calendarSyncPwd: boolean;
         calendarSyncEta9089: boolean;
         calendarSyncI140: boolean;
         calendarSyncRfi: boolean;
         calendarSyncRfe: boolean;
         calendarSyncRecruitment: boolean;
         calendarSyncFilingWindow: boolean;
       }

       /**
        * Extract all syncable deadlines from a case based on user preferences
        */
       export function extractCalendarEvents(
         caseData: CaseData,
         preferences: UserPreferences
       ): CalendarEventInput[] {
         const events: CalendarEventInput[] = [];
         const baseEvent = {
           employerName: caseData.employerName,
           beneficiaryIdentifier: caseData.beneficiaryIdentifier,
           caseId: caseData._id,
         };

         // PWD Expiration
         if (preferences.calendarSyncPwd && caseData.pwdExpirationDate && isFutureDate(caseData.pwdExpirationDate)) {
           events.push({ ...baseEvent, type: 'pwd_expiration', date: caseData.pwdExpirationDate });
         }

         // ETA 9089 Filing
         if (preferences.calendarSyncEta9089 && caseData.eta9089FilingDate && isFutureDate(caseData.eta9089FilingDate)) {
           events.push({ ...baseEvent, type: 'eta9089_filing', date: caseData.eta9089FilingDate });
         }

         // ETA 9089 Expiration
         if (preferences.calendarSyncEta9089 && caseData.eta9089ExpirationDate && isFutureDate(caseData.eta9089ExpirationDate)) {
           events.push({ ...baseEvent, type: 'eta9089_expiration', date: caseData.eta9089ExpirationDate });
         }

         // Filing Window Opens
         if (preferences.calendarSyncFilingWindow && caseData.filingWindowOpens && isFutureDate(caseData.filingWindowOpens)) {
           events.push({ ...baseEvent, type: 'filing_window_opens', date: caseData.filingWindowOpens });
         }

         // Recruitment Window Closes
         if (preferences.calendarSyncRecruitment && caseData.recruitmentWindowCloses && isFutureDate(caseData.recruitmentWindowCloses)) {
           events.push({ ...baseEvent, type: 'recruitment_expires', date: caseData.recruitmentWindowCloses });
         }

         // I-140 Deadline (calculated from ETA 9089 certification)
         if (preferences.calendarSyncI140 && caseData.eta9089CertificationDate) {
           const i140Deadline = calculateI140FilingDeadline(caseData.eta9089CertificationDate);
           if (i140Deadline && isFutureDate(i140Deadline)) {
             events.push({ ...baseEvent, type: 'i140_deadline', date: i140Deadline });
           }
         }

         // RFI Due Dates (only unresolved)
         if (preferences.calendarSyncRfi && caseData.rfiEntries) {
           for (const rfi of caseData.rfiEntries) {
             if (!rfi.responseSubmittedDate && isFutureDate(rfi.responseDueDate)) {
               events.push({
                 ...baseEvent,
                 type: 'rfi_due',
                 date: rfi.responseDueDate,
                 rfiRfeId: rfi.id,
               });
             }
           }
         }

         // RFE Due Dates (only unresolved)
         if (preferences.calendarSyncRfe && caseData.rfeEntries) {
           for (const rfe of caseData.rfeEntries) {
             if (!rfe.responseSubmittedDate && isFutureDate(rfe.responseDueDate)) {
               events.push({
                 ...baseEvent,
                 type: 'rfe_due',
                 date: rfe.responseDueDate,
                 rfiRfeId: rfe.id,
               });
             }
           }
         }

         return events;
       }
       ```

    2. **Bulk sync action in googleCalendarActions.ts**:
       ```typescript
       // Sync all events for a single case
       export const syncCaseCalendarEvents = internalAction({
         args: {
           userId: v.id("users"),
           caseId: v.id("cases"),
         },
         handler: async (ctx, args) => {
           // 1. Get case data
           const caseData = await ctx.runQuery(internal.cases.getForSync, { id: args.caseId });
           if (!caseData) return { success: false, error: 'Case not found' };

           // 2. Get user preferences
           const preferences = await ctx.runQuery(internal.users.getCalendarPreferences, { userId: args.userId });
           if (!preferences) return { success: false, error: 'Preferences not found' };

           // 3. Delete existing events for this case
           const existingEventIds = caseData.calendarEventIds || {};
           for (const eventId of Object.values(existingEventIds).filter(Boolean)) {
             await ctx.runAction(internal.googleCalendarActions.deleteCalendarEvent, {
               userId: args.userId,
               eventId: eventId as string,
             });
           }

           // 4. Extract new events based on preferences
           const events = extractCalendarEvents(caseData, preferences);

           // 5. Create new events and collect IDs
           const newEventIds: Record<string, string> = {};
           for (const event of events) {
             const result = await ctx.runAction(internal.googleCalendarActions.createCalendarEvent, {
               userId: args.userId,
               event,
             });
             if (result.success && result.eventId) {
               newEventIds[event.type] = result.eventId;
             }
           }

           // 6. Update case with new event IDs
           await ctx.runMutation(internal.cases.updateCalendarEventIds, {
             caseId: args.caseId,
             eventIds: newEventIds,
           });

           return { success: true, eventsCreated: events.length };
         },
       });
       ```
  </action>
  <verify>
    - All deadline types extracted correctly
    - Only future, unresolved deadlines synced
    - Event IDs stored in case.calendarEventIds
    - `cd v2 && pnpm build` succeeds
  </verify>
  <done>
    Bulk sync action created that extracts and syncs all case deadlines
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd v2 && pnpm build` succeeds without errors
- [ ] `cd v2 && npx convex dev` runs without schema errors
- [ ] googleapis dependency installed
- [ ] Calendar event create/update/delete actions work
- [ ] Bulk sync extracts all 8 event types correctly
- [ ] Past dates and resolved RFI/RFE skipped
</verification>

<success_criteria>
- All 3 tasks completed
- Calendar event CRUD operations working
- Event extraction handles all deadline types
- Error handling logs but doesn't block
- Ready for Plan 03 (Case Mutation Hooks)
</success_criteria>

<output>
After completion, create `.planning/phases/25.1-calendar-sync/25.1-02-SUMMARY.md`:

# Phase 25.1 Plan 02: Calendar Event CRUD Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified
- `path/to/file.ts` - Description

## Decisions Made
[Key decisions and rationale, or "None"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 25.1-03-PLAN.md (Case Mutation Hooks)
</output>
