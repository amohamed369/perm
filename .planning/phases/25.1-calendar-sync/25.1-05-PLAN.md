---
phase: 25.1-calendar-sync
plan: 05
type: execute
domain: edge-cases-testing
---

<objective>
Handle "not connected" edge cases throughout the app and add comprehensive test coverage.

Purpose: Ensure calendar sync fails gracefully everywhere, with proper user guidance.
Output: Edge case handling + comprehensive test suite for calendar sync.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25.1-calendar-sync/25.1-CONTEXT.md
@.planning/phases/25.1-calendar-sync/25.1-01-SUMMARY.md
@.planning/phases/25.1-calendar-sync/25.1-02-SUMMARY.md
@.planning/phases/25.1-calendar-sync/25.1-03-SUMMARY.md
@.planning/phases/25.1-calendar-sync/25.1-04-SUMMARY.md

**Depends on:** Plans 01-04 (complete calendar infrastructure)

**Edge Cases to Handle (from CONTEXT.md):**

**"Not Connected" States:**
1. Case Detail - Sync Toggle: Check before toggle, show toast + redirect hint
2. CaseCard - Sync Indicator: Warning if enabled but not connected
3. Settings - Deadline Toggles: Already handled (disabled when not connected)
4. Calendar Page: Show connection hint/CTA
5. Per-case dropdown sync: Check before action

**Sync Operation Edge Cases:**
6. Token expired mid-sync: Auto-refresh (already in Plan 01)
7. Token revoked: Auto-disconnect (already in Plan 01)
8. Event deleted in Google (404): Log, remove stale ID
9. Rate limit (429): Exponential backoff
10. Skip past deadlines: Already handled (Plan 02)

**Test Coverage Needed:**
- OAuth flow utilities
- Calendar helpers (event formatting, date checks)
- Event extractor (all 8 types)
- Case mutation hooks
- Edge case handling

## Required Reading (MANDATORY)
| Doc | Path | Purpose |
|-----|------|---------|
| CONTEXT.md | `.planning/phases/25.1-calendar-sync/25.1-CONTEXT.md` | Complete edge case list |
| v2/CLAUDE.md | `/Users/adammohamed/cc/perm-tracker-test/v2/CLAUDE.md` | Test patterns |

## Quality Standards
- 100% test coverage for calendar helpers
- Edge cases gracefully handled everywhere
- Clear user feedback with toast + guidance
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add "not connected" handling to case components</name>
  <files>
    v2/src/components/cases/detail/CaseDetailSection.tsx
    v2/src/components/cases/CaseCard.tsx
    v2/src/components/calendar/CalendarEventPopover.tsx
  </files>
  <exploration>
    Use Explore agent to understand:
    - How toggleCalendarSync is called in CaseDetailSection
    - CaseCard calendar indicator implementation
    - Calendar page structure and components
  </exploration>
  <action>
    1. **CaseDetailSection - Check connection before toggle**:
       ```tsx
       // Add hook for connection status
       const profile = useQuery(api.users.getCurrentUserProfile);
       const isGoogleConnected = profile?.googleCalendarConnected ?? false;

       // In toggle handler:
       const handleCalendarSyncToggle = async () => {
         if (!isGoogleConnected) {
           toast.error(
             "Connect Google Calendar first",
             {
               description: "Go to Settings > Calendar to connect",
               action: {
                 label: "Go to Settings",
                 onClick: () => router.push('/settings?tab=calendar'),
               },
             }
           );
           return;
         }

         // Proceed with toggle
         await toggleCalendarSync({ id: caseId });
       };
       ```

    2. **CaseCard - Show warning indicator when sync enabled but not connected**:
       ```tsx
       // In CaseCard, check connection status
       const profile = useQuery(api.users.getCurrentUserProfile);
       const isGoogleConnected = profile?.googleCalendarConnected ?? false;

       // Calendar indicator
       {caseData.calendarSyncEnabled && (
         <div className={`flex items-center gap-1 text-xs ${
           isGoogleConnected ? 'text-green-600' : 'text-amber-500'
         }`}>
           <Calendar className="w-3 h-3" />
           {isGoogleConnected ? 'Synced' : (
             <span className="flex items-center gap-0.5">
               <AlertTriangle className="w-3 h-3" />
               Not connected
             </span>
           )}
         </div>
       )}
       ```

    3. **Calendar page - Add connection hint**:
       In the calendar view component, add a banner when not connected:
       ```tsx
       const profile = useQuery(api.users.getCurrentUserProfile);
       const isGoogleConnected = profile?.googleCalendarConnected ?? false;

       // At top of calendar content
       {!isGoogleConnected && (
         <div className="flex items-center justify-between p-4 mb-4 bg-blue-50 dark:bg-blue-950/30 border-2 border-blue-200 dark:border-blue-800">
           <div className="flex items-center gap-3">
             <Info className="w-5 h-5 text-blue-600" />
             <div>
               <p className="text-sm font-medium text-blue-700 dark:text-blue-300">
                 Sync deadlines to Google Calendar
               </p>
               <p className="text-xs text-blue-600 dark:text-blue-400">
                 Connect your Google Calendar to see deadlines in your calendar app
               </p>
             </div>
           </div>
           <Link
             href="/settings?tab=calendar"
             className="px-3 py-1.5 text-sm font-medium bg-blue-600 text-white border-2 border-black"
             style={{ boxShadow: "2px 2px 0px #000" }}
           >
             Connect
           </Link>
         </div>
       )}
       ```
  </action>
  <verify>
    - Toggle shows toast when not connected
    - CaseCard shows warning indicator when sync enabled but not connected
    - Calendar page shows connection hint
  </verify>
  <done>
    "Not connected" handling added to all relevant components
  </done>
</task>

<task type="auto">
  <name>Task 2: Add rate limit and error handling improvements</name>
  <files>
    v2/convex/googleCalendarActions.ts
    v2/convex/lib/calendarHelpers.ts
  </files>
  <exploration>
    Use researcher agent to verify:
    - Google Calendar API rate limit response format
    - Exponential backoff best practices
    - Error code handling for googleapis
  </exploration>
  <action>
    1. **Add exponential backoff helper in calendarHelpers.ts**:
       ```typescript
       /**
        * Execute with exponential backoff for rate limits
        * @param fn - Async function to execute
        * @param maxRetries - Maximum retry attempts (default 3)
        * @param baseDelayMs - Base delay in ms (default 1000)
        */
       export async function withExponentialBackoff<T>(
         fn: () => Promise<T>,
         maxRetries = 3,
         baseDelayMs = 1000
       ): Promise<T> {
         let lastError: Error | undefined;

         for (let attempt = 0; attempt <= maxRetries; attempt++) {
           try {
             return await fn();
           } catch (error: any) {
             lastError = error;

             // Only retry on rate limit (429)
             if (error.code !== 429 && error.status !== 429) {
               throw error;
             }

             if (attempt === maxRetries) {
               console.error(`Rate limit: exhausted retries after ${maxRetries} attempts`);
               throw error;
             }

             // Exponential backoff: 1s, 2s, 4s, ...
             const delay = baseDelayMs * Math.pow(2, attempt);
             console.log(`Rate limited, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries})`);
             await new Promise(resolve => setTimeout(resolve, delay));
           }
         }

         throw lastError;
       }
       ```

    2. **Wrap API calls with backoff in googleCalendarActions.ts**:
       ```typescript
       // In createCalendarEvent:
       const response = await withExponentialBackoff(async () => {
         return await calendar.events.insert({
           calendarId: 'primary',
           requestBody: { ... },
         });
       });

       // In deleteCalendarEvent:
       await withExponentialBackoff(async () => {
         await calendar.events.delete({
           calendarId: 'primary',
           eventId: args.eventId,
         });
       });
       ```

    3. **Handle stale event IDs (404 on update)**:
       ```typescript
       // In syncCaseCalendarEvents, when deleting old events:
       for (const [type, eventId] of Object.entries(existingEventIds)) {
         if (!eventId) continue;

         try {
           await ctx.runAction(internal.googleCalendarActions.deleteCalendarEvent, {
             userId: args.userId,
             eventId: eventId as string,
           });
         } catch (error: any) {
           if (error.code === 404) {
             // Event already deleted in Google - clear from case
             console.log(`Stale event ID for ${type}, clearing`);
             // Will be overwritten by new event ID anyway
           } else {
             throw error;
           }
         }
       }
       ```
  </action>
  <verify>
    - Rate limits handled with backoff
    - 404 errors on delete treated as success
    - Stale event IDs cleared
  </verify>
  <done>
    Rate limit handling and error recovery improved
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive test coverage</name>
  <files>
    v2/convex/lib/__tests__/calendarHelpers.test.ts
    v2/convex/lib/__tests__/calendarEventExtractor.test.ts
    v2/convex/__tests__/googleCalendarActions.test.ts
  </files>
  <exploration>
    Use Explore agent to understand:
    - Existing test patterns in v2/convex/__tests__/
    - convex-test library usage
    - Test utilities in test-utils/
  </exploration>
  <action>
    Create comprehensive test suites:

    1. **v2/convex/lib/__tests__/calendarHelpers.test.ts**:
       ```typescript
       import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
       import {
         formatEventTitle,
         formatEventDescription,
         isFutureDate,
         toGoogleCalendarDate,
         withExponentialBackoff,
       } from '../calendarHelpers';

       describe('calendarHelpers', () => {
         describe('formatEventTitle', () => {
           it('formats title with type and employer', () => {
             const result = formatEventTitle({
               type: 'pwd_expiration',
               date: '2025-06-30',
               employerName: 'Acme Corp',
               caseId: 'abc123',
             });
             expect(result).toBe('PWD Expiration: Acme Corp');
           });

           it('truncates long employer names', () => {
             const longName = 'A'.repeat(150);
             const result = formatEventTitle({
               type: 'pwd_expiration',
               date: '2025-06-30',
               employerName: longName,
               caseId: 'abc123',
             });
             expect(result.length).toBeLessThanOrEqual(100);
             expect(result).toContain('...');
           });
         });

         describe('isFutureDate', () => {
           it('returns true for future dates', () => {
             const futureDate = new Date();
             futureDate.setDate(futureDate.getDate() + 10);
             expect(isFutureDate(futureDate.toISOString().slice(0, 10))).toBe(true);
           });

           it('returns false for past dates', () => {
             expect(isFutureDate('2020-01-01')).toBe(false);
           });

           it('returns false for today', () => {
             const today = new Date().toISOString().slice(0, 10);
             expect(isFutureDate(today)).toBe(false);
           });
         });

         describe('toGoogleCalendarDate', () => {
           it('returns date object for all-day events', () => {
             const result = toGoogleCalendarDate('2025-06-30');
             expect(result).toEqual({ date: '2025-06-30' });
           });
         });

         describe('withExponentialBackoff', () => {
           beforeEach(() => {
             vi.useFakeTimers();
           });

           afterEach(() => {
             vi.useRealTimers();
           });

           it('returns result on first success', async () => {
             const fn = vi.fn().mockResolvedValue('success');
             const result = await withExponentialBackoff(fn);
             expect(result).toBe('success');
             expect(fn).toHaveBeenCalledTimes(1);
           });

           it('retries on 429 error', async () => {
             const error = { code: 429, message: 'Rate limit' };
             const fn = vi.fn()
               .mockRejectedValueOnce(error)
               .mockResolvedValue('success');

             const promise = withExponentialBackoff(fn);
             await vi.advanceTimersByTimeAsync(1000);
             const result = await promise;

             expect(result).toBe('success');
             expect(fn).toHaveBeenCalledTimes(2);
           });

           it('throws non-429 errors immediately', async () => {
             const error = { code: 403, message: 'Forbidden' };
             const fn = vi.fn().mockRejectedValue(error);

             await expect(withExponentialBackoff(fn)).rejects.toEqual(error);
             expect(fn).toHaveBeenCalledTimes(1);
           });
         });
       });
       ```

    2. **v2/convex/lib/__tests__/calendarEventExtractor.test.ts**:
       ```typescript
       import { describe, it, expect } from 'vitest';
       import { extractCalendarEvents } from '../calendarEventExtractor';

       describe('extractCalendarEvents', () => {
         const baseCase = {
           _id: 'case123',
           employerName: 'Test Corp',
           beneficiaryIdentifier: 'John Doe',
         };

         const allPreferencesEnabled = {
           calendarSyncPwd: true,
           calendarSyncEta9089: true,
           calendarSyncI140: true,
           calendarSyncRfi: true,
           calendarSyncRfe: true,
           calendarSyncRecruitment: true,
           calendarSyncFilingWindow: true,
         };

         const futureDate = () => {
           const d = new Date();
           d.setMonth(d.getMonth() + 1);
           return d.toISOString().slice(0, 10);
         };

         it('extracts PWD expiration when enabled', () => {
           const caseData = {
             ...baseCase,
             pwdExpirationDate: futureDate(),
           };

           const events = extractCalendarEvents(caseData, allPreferencesEnabled);

           expect(events).toHaveLength(1);
           expect(events[0].type).toBe('pwd_expiration');
         });

         it('skips past PWD dates', () => {
           const caseData = {
             ...baseCase,
             pwdExpirationDate: '2020-01-01',
           };

           const events = extractCalendarEvents(caseData, allPreferencesEnabled);
           expect(events).toHaveLength(0);
         });

         it('extracts RFI due dates only when unresolved', () => {
           const caseData = {
             ...baseCase,
             rfiEntries: [
               { id: 'rfi1', responseDueDate: futureDate() }, // Unresolved
               { id: 'rfi2', responseDueDate: futureDate(), responseSubmittedDate: '2024-01-01' }, // Resolved
             ],
           };

           const events = extractCalendarEvents(caseData, allPreferencesEnabled);
           expect(events).toHaveLength(1);
           expect(events[0].rfiRfeId).toBe('rfi1');
         });

         it('respects preference toggles', () => {
           const caseData = {
             ...baseCase,
             pwdExpirationDate: futureDate(),
           };

           const disabledPrefs = {
             ...allPreferencesEnabled,
             calendarSyncPwd: false,
           };

           const events = extractCalendarEvents(caseData, disabledPrefs);
           expect(events).toHaveLength(0);
         });

         it('extracts all 8 event types', () => {
           const fd = futureDate();
           const caseData = {
             ...baseCase,
             pwdExpirationDate: fd,
             eta9089FilingDate: fd,
             eta9089ExpirationDate: fd,
             eta9089CertificationDate: fd, // For I-140 deadline
             filingWindowOpens: fd,
             recruitmentWindowCloses: fd,
             rfiEntries: [{ id: 'rfi1', responseDueDate: fd }],
             rfeEntries: [{ id: 'rfe1', responseDueDate: fd }],
           };

           const events = extractCalendarEvents(caseData, allPreferencesEnabled);

           const types = events.map(e => e.type);
           expect(types).toContain('pwd_expiration');
           expect(types).toContain('eta9089_filing');
           expect(types).toContain('eta9089_expiration');
           expect(types).toContain('i140_deadline');
           expect(types).toContain('filing_window_opens');
           expect(types).toContain('recruitment_expires');
           expect(types).toContain('rfi_due');
           expect(types).toContain('rfe_due');
         });
       });
       ```

    3. **v2/convex/__tests__/googleCalendarActions.test.ts** - Integration tests with mocked Google API (if time permits, can be stub file)
  </action>
  <verify>
    - `cd v2 && pnpm test:run` passes all tests
    - Calendar helper tests cover edge cases
    - Event extractor tests all 8 types
  </verify>
  <done>
    Comprehensive test coverage added for calendar sync
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] "Not connected" handling in CaseDetailSection toggle
- [ ] CaseCard shows warning when sync enabled but not connected
- [ ] Calendar page shows connection hint
- [ ] Rate limit handling with exponential backoff
- [ ] All tests pass: `cd v2 && pnpm test:run`
- [ ] No TypeScript errors: `cd v2 && pnpm build`
</verification>

<success_criteria>
- All 3 tasks completed
- Edge cases gracefully handled throughout app
- Comprehensive test coverage
- Phase 25.1 complete and ready for documentation update
</success_criteria>

<output>
After completion, create `.planning/phases/25.1-calendar-sync/25.1-05-SUMMARY.md`:

# Phase 25.1 Plan 05: Edge Cases + Tests Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified
- `path/to/file.ts` - Description

## Decisions Made
[Key decisions and rationale, or "None"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Phase 25.1 complete. Update documentation, then proceed to Phase 26 (Chat Foundation).
</output>
