---
phase: 27-knowledge-layer
plan: 03
type: execute
domain: tool-definitions
---

<objective>
Create AI SDK tool definitions for case data, knowledge search, and web search.

Purpose: Define the tools that the LLM can call natively. The LLM decides when and how to use each tool based on the user's question. No keyword-based routing - the model is smart enough to figure it out.

Output:
- `query_cases` tool with flexible filters (status, RFI/RFE, deadlines, search)
- `search_knowledge` tool for RAG search
- `search_web` tool for web search
- Proper Zod schemas with `.describe()` on every field
- Tool definitions exported for chat API integration
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-knowledge-layer/27-RESEARCH.md
@.planning/phases/27-knowledge-layer/27-CONTEXT.md
@.planning/phases/27-knowledge-layer/27-01-SUMMARY.md
@.planning/phases/27-knowledge-layer/27-02-SUMMARY.md
@v2/convex/cases.ts
@v2/convex/schema.ts

**Prior decisions affecting this phase:**
- Case schema established in Phase 19 with 100+ fields
- Existing cases.ts has list, get, listFiltered queries
- Message schema already has `toolCalls` array with status/result
- AI SDK v5 supports native `tool()` with Zod schemas

**From Research (Best Practices):**
- Use `tool()` from 'ai' package with Zod `inputSchema`
- Add `.describe()` to EVERY Zod field for LLM guidance
- Return structured data with summaries (not raw DB dumps)
- Single flexible tool > many specific tools (avoid tool explosion)
- Include usage examples in tool description

**From 27-CONTEXT.md:**
- "Knows MY cases" - answers in context of specific situations
- Quality bar: Like Claude/ChatGPT - professional, thorough
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create flexible case query Convex function</name>
  <files>v2/convex/chatCaseData.ts</files>
  <exploration>
    Use Explore agent to understand existing case query patterns in v2/convex/cases.ts.
    Look for auth patterns (getCurrentUserId) and deleted record filtering.
    Review case schema for all available fields.
  </exploration>
  <action>
    1. Create convex/chatCaseData.ts with single flexible query:

    ```typescript
    import { v } from "convex/values";
    import { query } from "./_generated/server";
    import { getCurrentUserId } from "./lib/auth";

    // Helper: Check if case has overdue deadline
    function hasOverdueDeadline(caseData: any): boolean {
      const now = new Date().toISOString().split('T')[0];
      const deadlineFields = [
        'pwdExpiration', 'recruitmentEnd', 'eta9089FilingDeadline',
        'i140FilingDeadline', 'rfiDeadline', 'rfeDeadline'
      ];
      return deadlineFields.some(field =>
        caseData[field] && caseData[field] < now
      );
    }

    // Helper: Check if deadline within N days
    function hasDeadlineWithinDays(caseData: any, days: number): boolean {
      const now = new Date();
      const future = new Date(now.getTime() + days * 24 * 60 * 60 * 1000);
      const futureStr = future.toISOString().split('T')[0];
      const nowStr = now.toISOString().split('T')[0];

      const deadlineFields = [
        'pwdExpiration', 'recruitmentEnd', 'eta9089FilingDeadline',
        'i140FilingDeadline', 'rfiDeadline', 'rfeDeadline'
      ];
      return deadlineFields.some(field =>
        caseData[field] && caseData[field] >= nowStr && caseData[field] <= futureStr
      );
    }

    // Single flexible query for chatbot
    export const queryCases = query({
      args: {
        // Filter by stage
        caseStatus: v.optional(v.union(
          v.literal("PWD"),
          v.literal("Recruitment"),
          v.literal("ETA 9089"),
          v.literal("I-140"),
          v.literal("Closed")
        )),

        // Filter by progress
        progressStatus: v.optional(v.union(
          v.literal("Working on it"),
          v.literal("Waiting for intake"),
          v.literal("Filed"),
          v.literal("Approved"),
          v.literal("Under review"),
          v.literal("RFI/RFE")
        )),

        // Filter by RFI/RFE
        hasRfi: v.optional(v.boolean()),
        hasRfe: v.optional(v.boolean()),

        // Filter by deadlines
        hasOverdueDeadline: v.optional(v.boolean()),
        deadlineWithinDays: v.optional(v.number()),

        // Search
        searchText: v.optional(v.string()),

        // Output control
        fields: v.optional(v.array(v.string())),
        limit: v.optional(v.number()),
        returnAllFields: v.optional(v.boolean()),

        // Aggregation mode
        countOnly: v.optional(v.boolean()),
      },
      handler: async (ctx, args) => {
        const userId = await getCurrentUserId(ctx);
        if (!userId) return { error: "Not authenticated", cases: [], totalCount: 0 };

        // Get all user's cases (non-deleted)
        let cases = await ctx.db
          .query("cases")
          .withIndex("by_userId", (q) => q.eq("userId", userId))
          .filter((q) => q.eq(q.field("deletedAt"), undefined))
          .collect();

        // Apply filters
        if (args.caseStatus) {
          cases = cases.filter(c => c.caseStatus === args.caseStatus);
        }
        if (args.progressStatus) {
          cases = cases.filter(c => c.progressStatus === args.progressStatus);
        }
        if (args.hasRfi === true) {
          cases = cases.filter(c => c.rfiReceivedDate);
        }
        if (args.hasRfi === false) {
          cases = cases.filter(c => !c.rfiReceivedDate);
        }
        if (args.hasRfe === true) {
          cases = cases.filter(c => c.rfeReceivedDate);
        }
        if (args.hasRfe === false) {
          cases = cases.filter(c => !c.rfeReceivedDate);
        }
        if (args.hasOverdueDeadline === true) {
          cases = cases.filter(c => hasOverdueDeadline(c));
        }
        if (args.deadlineWithinDays) {
          cases = cases.filter(c => hasDeadlineWithinDays(c, args.deadlineWithinDays!));
        }
        if (args.searchText) {
          const search = args.searchText.toLowerCase();
          cases = cases.filter(c =>
            c.employerName?.toLowerCase().includes(search) ||
            c.positionTitle?.toLowerCase().includes(search) ||
            c.beneficiaryName?.toLowerCase().includes(search) ||
            c.notes?.toLowerCase().includes(search)
          );
        }

        // Count-only mode (for "how many" questions)
        if (args.countOnly) {
          const byStatus: Record<string, number> = {};
          const byProgress: Record<string, number> = {};
          cases.forEach(c => {
            byStatus[c.caseStatus] = (byStatus[c.caseStatus] || 0) + 1;
            byProgress[c.progressStatus] = (byProgress[c.progressStatus] || 0) + 1;
          });

          return {
            totalCount: cases.length,
            byStatus,
            byProgress,
            overdueCount: cases.filter(c => hasOverdueDeadline(c)).length,
            upcomingCount: cases.filter(c => hasDeadlineWithinDays(c, 7)).length,
          };
        }

        // Apply limit
        const limit = args.limit || 20;
        cases = cases.slice(0, limit);

        // Select fields (default to summary fields, or all if returnAllFields)
        const defaultFields = [
          '_id', 'employerName', 'positionTitle', 'beneficiaryName',
          'caseStatus', 'progressStatus', 'pwdExpiration',
          'rfiDeadline', 'rfeDeadline', 'notes'
        ];
        const fields = args.returnAllFields ? null : (args.fields || defaultFields);

        // Project to requested fields (or return all if fields is null)
        const projectedCases = cases.map(c => {
          if (fields === null) {
            return c; // Return all fields
          }
          const projected: Record<string, any> = {};
          fields.forEach(field => {
            if (c[field as keyof typeof c] !== undefined) {
              projected[field] = c[field as keyof typeof c];
            }
          });
          // Always include ID for reference
          projected._id = c._id;
          return projected;
        });

        return {
          cases: projectedCases,
          totalCount: cases.length,
          query: {
            filters: {
              caseStatus: args.caseStatus,
              progressStatus: args.progressStatus,
              hasRfi: args.hasRfi,
              hasRfe: args.hasRfe,
              hasOverdueDeadline: args.hasOverdueDeadline,
              deadlineWithinDays: args.deadlineWithinDays,
              searchText: args.searchText,
            },
            fieldsReturned: fields || 'all',
            limit,
          },
        };
      },
    });
    ```

    2. Add helper for getting single case by ID:
    ```typescript
    export const getCaseById = query({
      args: { caseId: v.id("cases") },
      handler: async (ctx, { caseId }) => {
        const userId = await getCurrentUserId(ctx);
        if (!userId) return null;

        const caseData = await ctx.db.get(caseId);
        if (!caseData || caseData.userId !== userId || caseData.deletedAt) {
          return null;
        }
        return caseData;
      },
    });
    ```

    AVOID: Don't create separate queries for each filter combination - single flexible query handles all.
  </action>
  <verify>
    - TypeScript compiles without errors
    - queryCases appears in Convex dashboard
    - Query respects user ownership (can't access other users' data)
    - Deleted cases are excluded
  </verify>
  <done>Flexible case query implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create AI SDK tool definitions</name>
  <files>v2/src/lib/ai/tools.ts, v2/src/lib/ai/index.ts</files>
  <action>
    1. Create src/lib/ai/tools.ts with tool definitions:

    ```typescript
    import { tool } from 'ai';
    import { z } from 'zod';

    // ============================================================
    // OUTPUT SCHEMAS (for type safety and LLM understanding)
    // ============================================================

    const CaseSummarySchema = z.object({
      _id: z.string().describe("Unique case identifier"),
      employerName: z.string().describe("Employer/company name"),
      positionTitle: z.string().optional().describe("Job position title"),
      beneficiaryName: z.string().optional().describe("Foreign worker's name"),
      caseStatus: z.enum(["PWD", "Recruitment", "ETA 9089", "I-140", "Closed"]).describe("Current case stage"),
      progressStatus: z.string().describe("Progress within current stage"),
      pwdExpiration: z.string().optional().describe("PWD expiration date (YYYY-MM-DD)"),
      rfiDeadline: z.string().optional().describe("RFI response deadline if applicable"),
      rfeDeadline: z.string().optional().describe("RFE response deadline if applicable"),
      notes: z.string().optional().describe("Case notes"),
    });

    const QueryCasesOutputSchema = z.object({
      cases: z.array(CaseSummarySchema).describe("Array of case objects with requested fields"),
      totalCount: z.number().describe("Total number of cases matching filters (before limit applied)"),
      query: z.object({
        filters: z.record(z.any()).describe("Echo of filters that were applied"),
        fieldsReturned: z.union([z.array(z.string()), z.literal("all")]).describe("Fields included in response"),
        limit: z.number().describe("Max cases returned"),
      }).describe("Metadata about the query executed"),
    });

    const QueryCasesCountOutputSchema = z.object({
      totalCount: z.number().describe("Total number of cases matching filters"),
      byStatus: z.record(z.number()).describe("Count of cases per caseStatus (e.g., {'PWD': 3, 'Recruitment': 5})"),
      byProgress: z.record(z.number()).describe("Count of cases per progressStatus"),
      overdueCount: z.number().describe("Number of cases with at least one overdue deadline"),
      upcomingCount: z.number().describe("Number of cases with deadline in next 7 days"),
    });

    // ============================================================
    // TOOL: query_cases
    // ============================================================

    /**
     * Tool: query_cases
     * Query user's PERM cases with flexible filters
     */
    export const queryCasesTool = tool({
      description: `Query the user's PERM cases with flexible filters.

USE THIS TOOL WHEN the user asks about:
- Their cases, deadlines, or case counts
- Specific cases by employer name, status, or deadline
- Cases with RFI/RFE
- Overdue or upcoming deadlines
- Questions like "how many", "which cases", "show me", "list my", "find"

PARAMETERS SUMMARY:
- caseStatus: Filter by stage. Default: no filter (all stages)
- progressStatus: Filter by progress. Default: no filter (all progress states)
- hasRfi/hasRfe: Filter by RFI/RFE. Default: no filter
- hasOverdueDeadline: Filter overdue. Default: false (no filter)
- deadlineWithinDays: Filter by upcoming deadline. Default: no filter
- searchText: Text search. Default: no filter
- fields: Which fields to return. Default: summary fields
- returnAllFields: Get all 100+ fields. Default: false
- limit: Max results. Default: 20
- countOnly: Return counts only. Default: false

OUTPUT FORMAT:
- If countOnly=true: { totalCount, byStatus, byProgress, overdueCount, upcomingCount }
- If countOnly=false: { cases: [...], totalCount, query: { filters, fieldsReturned, limit } }

EXAMPLES:
- "How many cases?" → { countOnly: true }
- "ETA 9089 cases with RFEs" → { caseStatus: "ETA 9089", hasRfe: true }
- "Cases due this week" → { deadlineWithinDays: 7 }
- "Overdue PWD cases" → { caseStatus: "PWD", hasOverdueDeadline: true }
- "Acme Corp PWD date" → { searchText: "Acme", fields: ["employerName", "pwdDetermination", "pwdExpiration"] }
- "Everything about Google case" → { searchText: "Google", returnAllFields: true, limit: 1 }`,

      parameters: z.object({
        caseStatus: z.enum(["PWD", "Recruitment", "ETA 9089", "I-140", "Closed"])
          .optional()
          .describe("Filter by case stage. Options: PWD (wage determination), Recruitment (ads/postings), ETA 9089 (DOL filing), I-140 (USCIS petition), Closed (archived). Default: no filter (returns all stages)"),

        progressStatus: z.enum(["Working on it", "Waiting for intake", "Filed", "Approved", "Under review", "RFI/RFE"])
          .optional()
          .describe("Filter by progress status within a stage. Options: 'Working on it', 'Waiting for intake', 'Filed', 'Approved', 'Under review', 'RFI/RFE'. Default: no filter (returns all progress states)"),

        hasRfi: z.boolean()
          .optional()
          .describe("Filter by RFI (Request for Information) presence. true=cases WITH RFI, false=cases WITHOUT RFI. Default: no filter (returns both)"),

        hasRfe: z.boolean()
          .optional()
          .describe("Filter by RFE (Request for Evidence) presence. true=cases WITH RFE, false=cases WITHOUT RFE. Default: no filter (returns both)"),

        hasOverdueDeadline: z.boolean()
          .optional()
          .describe("Filter by overdue status. true=only cases with at least one past-due deadline. Default: no filter (returns all regardless of overdue status)"),

        deadlineWithinDays: z.number()
          .optional()
          .describe("Filter to cases with any deadline within N days from today. Example: 7 for 'due this week', 30 for 'due this month'. Default: no filter"),

        searchText: z.string()
          .optional()
          .describe("Free-text search across employerName, positionTitle, beneficiaryName, and notes. Case-insensitive partial match. Default: no filter"),

        fields: z.array(z.string())
          .optional()
          .describe(`Which fields to include in response. Default: summary fields (_id, employerName, positionTitle, beneficiaryName, caseStatus, progressStatus, pwdExpiration, rfiDeadline, rfeDeadline, notes).

AVAILABLE FIELDS BY CATEGORY:
- IDENTIFIERS: _id, employerName, positionTitle, beneficiaryName, caseStatus, progressStatus
- PWD: pwdFilingDate, pwdDetermination, pwdExpiration, pwdJobTitle, pwdWageLevel, pwdWage
- RECRUITMENT: recruitmentStart, recruitmentEnd, sundayAd1Date, sundayAd1Publication, sundayAd2Date, sundayAd2Publication, jobOrderStart, jobOrderEnd, jobOrderNumber, noticeOfFilingStart, noticeOfFilingEnd, additionalRecruitment1Date, additionalRecruitment1Method, additionalRecruitment2Date, additionalRecruitment2Method, additionalRecruitment3Date, additionalRecruitment3Method, recruitmentApplicantsCount
- ETA 9089: eta9089Filing, eta9089Certification, eta9089Expiration, eta9089CaseNumber
- I-140: i140Filing, i140Approval, i140ReceiptNumber
- RFI/RFE: rfiReceivedDate, rfiDeadline, rfiResponseDate, rfeReceivedDate, rfeDeadline, rfeResponseDate
- OTHER: isProfessionalOccupation, isFavorite, notes, createdAt, updatedAt`),

        limit: z.number()
          .optional()
          .describe("Maximum number of cases to return. Range: 1-100. Default: 20. Use lower values for focused queries, higher for comprehensive lists"),

        returnAllFields: z.boolean()
          .optional()
          .describe("If true, returns ALL case fields (100+) instead of summary fields. Overrides 'fields' param. Best used with limit:1 for single-case deep dives. Default: false"),

        countOnly: z.boolean()
          .optional()
          .describe("If true, returns only aggregated counts (totalCount, byStatus, byProgress, overdueCount, upcomingCount) without case details. Use for 'how many' questions. Default: false"),
      }),

      // Output schema for type safety (LLM sees this structure)
      outputSchema: z.union([QueryCasesOutputSchema, QueryCasesCountOutputSchema]),
    });

    // ============================================================
    // TOOL: search_knowledge (RAG)
    // ============================================================

    const SearchKnowledgeOutputSchema = z.object({
      context: z.string().describe("Retrieved knowledge text relevant to the query. May be empty if no matches found"),
      sources: z.array(z.object({
        title: z.string().describe("Section title (e.g., 'PWD Expiration Rules')"),
        source: z.string().describe("Source document (e.g., 'perm_flow.md')"),
        cfr: z.string().optional().describe("CFR reference if applicable (e.g., '20 CFR 656.40')"),
        score: z.number().optional().describe("Relevance score 0-1 (higher = more relevant)"),
      })).describe("Array of source citations for the retrieved context"),
      message: z.string().optional().describe("Status message if no results found"),
    });

    /**
     * Tool: search_knowledge
     * Search PERM knowledge base (RAG)
     */
    export const searchKnowledgeTool = tool({
      description: `Search the PERM knowledge base for regulations, requirements, deadlines, and procedures.

USE THIS TOOL WHEN the user asks about:
- PERM regulations, requirements, or procedures
- Deadlines, timelines, or filing windows
- Sunday ad requirements, job order rules
- PWD expiration calculations
- ETA 9089 or I-140 filing requirements
- RFI vs RFE rules and differences
- Any general PERM process question

DO NOT USE for:
- User's specific cases (use query_cases instead)
- Current/recent DOL updates (use search_web instead)

KNOWLEDGE BASE CONTAINS:
- 20 CFR 656 regulations
- PWD stage procedures and expiration rules
- Recruitment requirements (Sunday ads, job order, notice of filing)
- ETA 9089 filing window and requirements
- I-140 filing deadlines
- RFI/RFE response rules
- App feature documentation

PARAMETERS:
- query: The question or topic to search. Default: required (no default)

OUTPUT FORMAT:
{
  context: "Retrieved text with relevant PERM knowledge...",
  sources: [{ title, source, cfr?, score? }, ...],
  message?: "Status if no results"
}

CITATION REQUIREMENT: Always cite sources in your response using the returned source info (e.g., "per 20 CFR 656.17" or "according to PERM guidelines").

EXAMPLES:
- "PWD expiration rules" → { query: "PWD expiration calculation validity period" }
- "Sunday ad requirements" → { query: "Sunday newspaper advertisement requirements PERM recruitment" }
- "ETA 9089 filing window" → { query: "ETA 9089 filing deadline 30 180 days recruitment" }`,

      parameters: z.object({
        query: z.string()
          .describe("The PERM-related question or topic to search for. Be specific and include relevant keywords. Required parameter (no default). Example: 'PWD expiration calculation rules' or 'Sunday newspaper ad requirements'"),
      }),

      outputSchema: SearchKnowledgeOutputSchema,
    });

    // ============================================================
    // TOOL: search_web
    // ============================================================

    const SearchWebOutputSchema = z.object({
      source: z.enum(["tavily", "brave", "none"]).describe("Which search provider returned results. 'none' means no results available (quota exhausted or error)"),
      results: z.array(z.object({
        title: z.string().describe("Page title"),
        url: z.string().describe("Full URL to the source"),
        content: z.string().describe("Snippet of relevant content from the page"),
      })).describe("Array of web search results (max 5)"),
      answer: z.string().optional().describe("AI-generated summary answer (Tavily only)"),
      message: z.string().optional().describe("Status message if no results"),
      error: z.string().optional().describe("Error message if search failed"),
    });

    /**
     * Tool: search_web
     * Search web for current PERM information
     */
    export const searchWebTool = tool({
      description: `Search the web for current PERM regulations, DOL updates, and processing times.

USE THIS TOOL WHEN the user asks about:
- Current DOL processing times
- Recent regulation changes or updates (2024, 2025, etc.)
- News about the PERM program
- Specific CFR references you need to verify
- Information that may have changed recently
- Questions with words like "current", "latest", "now", "today"

DO NOT USE for:
- Static PERM procedures (use search_knowledge instead - faster, no quota)
- User's specific cases (use query_cases instead)
- General PERM knowledge already in the knowledge base

PARAMETERS:
- query: Web search query. Default: required (no default)

OUTPUT FORMAT:
{
  source: "tavily" | "brave" | "none",
  results: [{ title, url, content }, ...],
  answer?: "AI summary (Tavily only)",
  message?: "Status if no results",
  error?: "Error message if failed"
}

RATE LIMITS: Web search has daily quota limits. Use sparingly - prefer search_knowledge for static information.

CITATION REQUIREMENT: Always cite web sources with [Title](URL) format in your response.

EXAMPLES:
- "Current processing times" → { query: "PERM DOL processing times 2025" }
- "Recent changes" → { query: "PERM regulation changes 2025 DOL" }
- "CFR verification" → { query: "20 CFR 656.17 PERM recruitment requirements" }`,

      parameters: z.object({
        query: z.string()
          .describe("Web search query string. Include 'PERM' or 'DOL' for relevant results. Include year for current info. Required parameter (no default). Example: 'PERM processing times 2025' or 'DOL PERM regulation changes'"),
      }),

      outputSchema: SearchWebOutputSchema,
    });

    // ============================================================
    // EXPORTS
    // ============================================================

    // Export output schemas for use in tests and type checking
    export {
      CaseSummarySchema,
      QueryCasesOutputSchema,
      QueryCasesCountOutputSchema,
      SearchKnowledgeOutputSchema,
      SearchWebOutputSchema,
    };

    // Export all tools for use in chat API
    export const chatTools = {
      query_cases: queryCasesTool,
      search_knowledge: searchKnowledgeTool,
      search_web: searchWebTool,
    };
    ```

    2. Export from src/lib/ai/index.ts:
    ```typescript
    export * from './tools';
    export * from './system-prompt';
    export * from './providers';
    ```

    AVOID: Don't add execute functions here - those go in the chat API route where we have Convex access.
  </action>
  <verify>
    - TypeScript compiles
    - All tools have comprehensive descriptions
    - All parameters have `.describe()` calls
    - Tools exported from index
  </verify>
  <done>AI SDK tool definitions created</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for case query and tool schemas</name>
  <files>v2/convex/__tests__/chatCaseData.test.ts, v2/src/lib/ai/__tests__/tools.test.ts</files>
  <action>
    1. Create convex/__tests__/chatCaseData.test.ts:
       - Test queryCases with no filters returns all cases
       - Test queryCases with caseStatus filter
       - Test queryCases with hasRfe filter
       - Test queryCases with hasOverdueDeadline filter
       - Test queryCases with deadlineWithinDays filter
       - Test queryCases with searchText filter
       - Test queryCases with countOnly mode
       - Test queryCases with fields projection
       - Test queryCases with combined filters
       - Test queryCases with returnAllFields returns all fields
       - Test queryCases respects user ownership
       - Test queryCases excludes deleted cases
       - Test getCaseById returns case for owner
       - Test getCaseById returns null for non-owner

    2. Create src/lib/ai/__tests__/tools.test.ts:
       - Test queryCasesTool has valid Zod schema
       - Test searchKnowledgeTool has valid Zod schema
       - Test searchWebTool has valid Zod schema
       - Test tool descriptions are non-empty and comprehensive
       - Test tool parameters parse valid inputs
       - Test tool parameters reject invalid inputs
       - Test chatTools exports all tools
       - Test output schemas parse valid outputs
       - Test QueryCasesOutputSchema validates case array response
       - Test QueryCasesCountOutputSchema validates count response
       - Test SearchKnowledgeOutputSchema validates RAG response
       - Test SearchWebOutputSchema validates web search response
       - Test output schemas reject malformed responses

    3. Sample test queries to verify input schema:
       - `{ countOnly: true }` - valid
       - `{ caseStatus: "PWD", hasRfe: true }` - valid
       - `{ deadlineWithinDays: 7, limit: 5 }` - valid
       - `{ searchText: "Acme", returnAllFields: true, limit: 1 }` - valid
       - `{ caseStatus: "INVALID" }` - should reject
       - `{ deadlineWithinDays: "seven" }` - should reject

    4. Sample outputs to verify output schemas:
       - QueryCasesOutputSchema: `{ cases: [...], totalCount: 5, query: {...} }` - valid
       - QueryCasesCountOutputSchema: `{ totalCount: 5, byStatus: {}, byProgress: {}, overdueCount: 0, upcomingCount: 2 }` - valid
       - SearchKnowledgeOutputSchema: `{ context: "...", sources: [{title, source}] }` - valid
       - SearchWebOutputSchema: `{ source: "tavily", results: [...], answer: "..." }` - valid
       - Missing required fields - should reject

    AVOID: Don't test implementation details - test behavior and schema validation.
  </action>
  <verify>
    - `pnpm test convex/__tests__/chatCaseData.test.ts` passes
    - `pnpm test src/lib/ai/__tests__/tools.test.ts` passes
    - All edge cases covered
  </verify>
  <done>Case query and tool schemas fully tested</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Flexible queryCases function handles all filter combinations
- [ ] Tool definitions have comprehensive descriptions
- [ ] All Zod parameters have `.describe()` calls
- [ ] Tools exported for chat API integration
- [ ] All queries respect user ownership
- [ ] All tests pass
- [ ] No TypeScript errors
</verification>

<success_criteria>
- Single flexible query_cases tool replaces rigid 3-tier queries
- Tool descriptions guide LLM on when/how to use each tool
- Parameter descriptions enable LLM to construct correct arguments
- All tests passing
- Ready for chat API integration (27-04)
</success_criteria>

<output>
After completion, create `.planning/phases/27-knowledge-layer/27-03-SUMMARY.md`:

# Phase 27 Plan 03: Tool Definitions Summary

**[One-liner describing what shipped]**

## Accomplishments
- Flexible queryCases Convex function with all filter options
- AI SDK tool definitions with Zod schemas
- Comprehensive `.describe()` on all parameters
- Tool usage examples in descriptions

## Files Created/Modified
- `v2/convex/chatCaseData.ts` - Flexible case query
- `v2/src/lib/ai/tools.ts` - Tool definitions
- `v2/src/lib/ai/index.ts` - Exports
- Tests for both

## Decisions Made
[Any decisions made during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 27-04-PLAN.md (Chat API Integration with Tools)
</output>
