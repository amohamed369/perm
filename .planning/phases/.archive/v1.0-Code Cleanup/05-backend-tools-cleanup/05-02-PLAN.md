---
phase: 05-backend-tools-cleanup
plan: 02
type: execute
---

<objective>
Replace generic Any types with specific TypedDict definitions in core tool infrastructure files.

Purpose: Address M1 (type safety gaps) in the core files that all tools depend on.
Output: Type-safe core infrastructure with ToolContext, ToolResult, ToolArguments TypedDicts.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan context:**
05-01-PLAN removes deprecated exports and dead code - this plan assumes that's done.

**Current state from exploration:**
- base.py: 5 Any type usages
- registry.py: 3 Any type usages
- orchestrator_v2.py: 7 Any type usages in key signatures

These 3 files form the core tool infrastructure. Fixing types here establishes patterns for implementations.

**Files to modify:**
@backend/app/services/tools/base.py
@backend/app/services/tools/registry.py
@backend/app/services/tools/orchestrator_v2.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypedDict definitions in base.py</name>
  <files>backend/app/services/tools/base.py</files>
  <exploration>
    Review current base.py structure to understand execute() signature and what context/arguments contain.
    Look at how tools use these types in implementations.
  </exploration>
  <action>
Add TypedDict definitions at top of base.py after imports:

```python
from typing import TypedDict, NotRequired, Literal

class PageContext(TypedDict, total=False):
    """Context from the current page state."""
    page: str
    caseId: NotRequired[str]
    caseName: NotRequired[str]
    userId: str
    # Add other common fields

class ToolExecutionContext(TypedDict):
    """Context passed to tool execution."""
    page_context: PageContext
    user_id: str
    db: Any  # Keep Any for database client - external type

class ToolResult(TypedDict):
    """Standard tool result format."""
    success: bool
    error: NotRequired[str]
    data: NotRequired[dict]  # Tool-specific data
    client_action: NotRequired[dict]  # Client-side action to perform

class ToolArguments(TypedDict, total=False):
    """Base tool arguments - extended by specific tools."""
    pass  # Specific tools define their own
```

Update BaseTool.execute() signature:
```python
def execute(
    self,
    arguments: dict[str, Any],  # Keep flexible for subclasses
    context: ToolExecutionContext
) -> ToolResult:
```

Note: Keep some Any for flexibility where tools extend arguments. The goal is to type the core structures, not be overly restrictive.
  </action>
  <verify>python -c "from app.services.tools.base import ToolResult, ToolExecutionContext, PageContext; print('Types defined')"</verify>
  <done>Core TypedDicts defined in base.py, BaseTool updated</done>
</task>

<task type="auto">
  <name>Task 2: Fix Any types in registry.py</name>
  <files>backend/app/services/tools/registry.py</files>
  <exploration>
    Review registry.py to understand what types are actually passed through.
    Look at register(), execute(), and export format methods.
  </exploration>
  <action>
Import types from base.py and update signatures:

1. Import: `from app.services.tools.base import ToolResult, ToolExecutionContext`

2. Update execute() method signature:
```python
def execute(
    self,
    tool_name: str,
    arguments: dict[str, Any],  # Tool-specific, keep flexible
    context: ToolExecutionContext
) -> ToolResult:
```

3. For export methods (get_tools_for_openai, etc.), the return type is provider-specific - can use `list[dict[str, Any]]` since these match external API schemas.

4. For _tool_definitions cache, use `dict[str, dict[str, Any]]` - external schema format.

Focus on execute() which is the core path. Export formats are external schemas.
  </action>
  <verify>python -c "from app.services.tools.registry import tool_registry; print('Registry imports OK')"</verify>
  <done>registry.py execute() uses ToolExecutionContext and ToolResult</done>
</task>

<task type="auto">
  <name>Task 3: Fix key Any types in orchestrator_v2.py</name>
  <files>backend/app/services/tools/orchestrator_v2.py</files>
  <exploration>
    Review orchestrator_v2.py to find the key functions that use Any types.
    Focus on execute_tool_call(), process_tool_calls(), and main orchestration methods.
  </exploration>
  <action>
Import types from base.py and update key signatures:

1. Import: `from app.services.tools.base import ToolResult, ToolExecutionContext, PageContext`

2. Update _execute_tool_call() signature:
```python
async def _execute_tool_call(
    self,
    tool_name: str,
    arguments: dict[str, Any],  # From LLM, keep flexible
    context: ToolExecutionContext
) -> ToolResult:
```

3. Update _process_tool_calls() to use ToolResult for results list.

4. For LLM response types (messages, tool_calls), keep `list[dict[str, Any]]` - these are provider API formats.

5. Key internal methods to type:
   - _build_context() -> ToolExecutionContext
   - Tool results storage/handling uses ToolResult

Focus on tool execution path. LLM interaction types stay flexible as they're external APIs.
  </action>
  <verify>python -c "from app.services.tools.orchestrator_v2 import ToolOrchestrator; print('Orchestrator imports OK')"</verify>
  <done>orchestrator_v2.py key methods use typed tool infrastructure</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from app.services.tools.base import ToolResult, ToolExecutionContext, PageContext"` - types importable
- [ ] `python -c "from app.services.tools.registry import tool_registry"` - registry works
- [ ] `python -c "from app.services.tools.orchestrator_v2 import ToolOrchestrator"` - orchestrator works
- [ ] `cd backend && python -m pytest tests/ -q` - all tests pass
- [ ] No type errors in core files (mypy optional)
</verification>

<success_criteria>
- TypedDicts defined in base.py (ToolResult, ToolExecutionContext, PageContext)
- Core files use typed signatures where appropriate
- External API types (LLM responses, provider schemas) stay flexible
- All tests pass
- No import errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-backend-tools-cleanup/05-02-SUMMARY.md`
</output>
