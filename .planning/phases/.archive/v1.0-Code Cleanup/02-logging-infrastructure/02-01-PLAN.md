---
phase: 02-logging-infrastructure
plan: 01
type: execute
---

<objective>
Create proper logging infrastructure for backend and frontend, enabling future phases to remove debug statements systematically.

Purpose: Establish the logging utilities that Phase 3-8 cleanup work depends on. Without proper logging infrastructure, we can't remove print()/console.* statements - we'd lose debugging capability.
Output: Backend logging configuration + frontend conditional console wrapper + orchestrator print() statements converted to structured logging.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/context-preservation.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Codebase constraints (from .planning/codebase/):**
- Python: 4-space indentation, type hints required, Google-style docstrings
- JavaScript: 2-space indentation, ES modules, JSDoc comments
- Backend uses Pydantic Settings for config (`app/config.py`)

**Prior decisions affecting this phase:**
- Phase 1 established dev vs prod behavior pattern (dev: warn only, prod: fail fast)

**Key files (DO NOT read these directly - use exploration steps):**
- `backend/app/main.py` - Add logging configuration here
- `backend/app/utils/logger.py` - Existing UserFriendlyLogger (don't modify)
- `backend/app/services/tools/orchestrator_v2.py` - 22 print() statements
- `backend/app/services/tools/orchestrator.py` - 6 print() statements
- `frontend/src/js/utils/logger.js` - Create this (doesn't exist yet)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Python logging in main.py</name>
  <files>backend/app/main.py</files>
  <exploration>
    Use Explore agent (haiku, quick) to find:
    - Current logging imports/configuration in main.py
    - How settings.DEBUG or environment is accessed
    - Any existing logging patterns in backend/app/

    Prompt: "Quick search: Find logging configuration in backend/app/main.py and how DEBUG/environment settings are accessed. Also check if any logging.basicConfig exists anywhere in backend/."
  </exploration>
  <action>
Add logging configuration at module level (before app creation):

1. Import logging and sys
2. Create configure_logging() function that:
   - Sets format: `%(asctime)s - %(name)s - %(levelname)s - %(message)s`
   - Sets level: DEBUG if settings.DEBUG else INFO
   - Adds StreamHandler to stdout (for Render logs)
   - Quiets noisy loggers (uvicorn.access, httpx, httpcore) to WARNING
3. Call configure_logging() before app = FastAPI(...)

Do NOT modify the existing UserFriendlyLogger in utils/logger.py - it's for error responses.
  </action>
  <verify>
Run: `cd backend && python -c "from app.main import app; import logging; print(logging.getLogger().level)"`
Should print a numeric level (10 for DEBUG or 20 for INFO)
  </verify>
  <done>Logging configured with proper format, level based on environment, third-party loggers quieted</done>
</task>

<task type="auto">
  <name>Task 2: Create frontend conditional console wrapper</name>
  <files>frontend/src/js/utils/logger.js</files>
  <exploration>
    Use Explore agent (haiku, quick) to find:
    - How Vite environment is accessed (import.meta.env)
    - Directory structure of frontend/src/js/utils/
    - Any existing logging patterns in frontend

    Prompt: "Quick search: Check frontend/src/js/utils/ structure. Find how environment mode is checked in frontend code (import.meta.env). Look for any existing console wrapper or logging utility."
  </exploration>
  <action>
Create a new logger utility that:

1. Checks `import.meta.env.DEV` for development mode detection
2. Exports a `logger` object with methods: debug, log, info, warn, error
3. In dev mode: pass through to console.* methods with prefix `[PERM]`
4. In prod mode: noop functions (silent)
5. Add a `logger.force` namespace that always logs (for critical errors)

Example API:
```javascript
import { logger } from './utils/logger.js';

logger.debug('Processing case', { caseId }); // Only in dev
logger.error('Failed to load', error);        // Only in dev
logger.force.error('Critical failure', error); // Always logs
```

Use JSDoc for documentation. Keep it simple - no external dependencies.
  </action>
  <verify>
Check file exists: `ls frontend/src/js/utils/logger.js`
Check exports: `grep -E "export (const|function)" frontend/src/js/utils/logger.js`
  </verify>
  <done>Logger utility created with dev-only logging and force namespace for critical errors</done>
</task>

<task type="auto">
  <name>Task 3: Convert orchestrator print() statements to logger</name>
  <files>backend/app/services/tools/orchestrator_v2.py, backend/app/services/tools/orchestrator.py</files>
  <exploration>
    Use Explore agent (haiku, medium) to find:
    - All print() patterns in both orchestrator files
    - Whether logger = logging.getLogger(__name__) already exists
    - What prefixes are used ([ORCH], [ORCH-v2], DEBUG:, etc.)

    Prompt: "Find all print() statements in backend/app/services/tools/orchestrator.py and orchestrator_v2.py. List the patterns used (prefixes like [ORCH], DEBUG:, etc). Check if logger is already imported/created."
  </exploration>
  <action>
Replace all print() statements with structured logging:

1. Both files should have `logger = logging.getLogger(__name__)` - verify and add if missing
2. Convert patterns:
   - `print(f"[ORCH-v2] DEBUG: ...")` → `logger.debug(...)`
   - `print(f"[ORCH-v2] ...")` → `logger.info(...)` (general flow)
   - `print(f"[ORCH] ...")` → `logger.info(...)`
   - Error-related prints → `logger.warning(...)` or `logger.error(...)`
3. Remove `flush=True` arguments - not needed with logging
4. Remove prefixes like `[ORCH-v2]` and `[ORCH]` - logger name provides context
5. Use structured logging where applicable: `logger.debug("Tool result", extra={"success": result.success})`

Total: 28 print() statements across both files (22 + 6).
  </action>
  <verify>
Run: `grep -c "print(" backend/app/services/tools/orchestrator*.py`
Should return 0 for both files (no print statements remaining)
  </verify>
  <done>All 28 print() statements converted to structured logging, no prints remain in orchestrators</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `cd backend && python -c "from app.main import app"` succeeds (no import errors)
- [ ] `grep -r "print(" backend/app/services/tools/orchestrator*.py | wc -l` returns 0
- [ ] `ls frontend/src/js/utils/logger.js` exists
- [ ] `cd backend && pytest tests/ -x -q` passes (regression check)
</verification>

<success_criteria>
- Logging configuration added to main.py with environment-aware levels
- Frontend logger.js created with conditional dev-only logging
- All 28 orchestrator print() statements converted to structured logging
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-logging-infrastructure/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Logging Infrastructure Summary

**[Substantive one-liner - what shipped]**

## Accomplishments
- [Key outcome 1]
- [Key outcome 2]
- [Key outcome 3]

## Files Created/Modified
- `backend/app/main.py` - Added logging configuration
- `frontend/src/js/utils/logger.js` - New conditional console wrapper
- `backend/app/services/tools/orchestrator_v2.py` - Converted prints to logging
- `backend/app/services/tools/orchestrator.py` - Converted prints to logging

## Decisions Made
[Any decisions made during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Phase 2 complete, ready for Phase 3 (Backend Core Cleanup)
</output>
