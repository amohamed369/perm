---
phase: 25.1-calendar-sync
plan: 01
type: execute
domain: next-js-convex
---

<objective>
Set up Google OAuth infrastructure for calendar integration in Next.js with secure token storage in Convex.

Purpose: Enable users to authenticate with Google and securely store OAuth tokens for calendar access.
Output: Working OAuth flow that stores refresh/access tokens in userProfiles, with auto-refresh capabilities.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25.1-calendar-sync/25.1-CONTEXT.md

**Codebase constraints:**
- Next.js 16+ App Router with TypeScript strict mode
- Convex for backend - tokens stored in userProfiles table
- Schema already has google* fields in userProfiles (googleEmail, googleRefreshToken, googleAccessToken, googleTokenExpiry, googleScopes, googleCalendarConnected)
- No direct environment variable access in Convex - use process.env in actions only

**v1 Reference:**
- OAuth flow: `backend/app/api/google_services.py`
- Token management: `backend/app/utils/google_oauth.py`

**Prior decisions:**
- One-way sync only (App â†’ Google)
- UTC all-day events
- Best-effort sync (don't block case operations on sync failure)

## Required Reading (MANDATORY)
| Doc | Path | Purpose |
|-----|------|---------|
| perm_flow.md | `/Users/adammohamed/cc/perm-tracker-test/perm_flow.md` | SOURCE OF TRUTH |
| v2/CLAUDE.md | `/Users/adammohamed/cc/perm-tracker-test/v2/CLAUDE.md` | API patterns, imports |
| CONTEXT.md | `.planning/phases/25.1-calendar-sync/25.1-CONTEXT.md` | Edge cases, requirements |

## Quality Standards
- DRY - Don't Repeat Yourself, abstract common patterns
- KISS - Keep It Simple, minimal complexity
- No clashing - No duplicate implementations
- Work within existing patterns
- Refactor as needed for consistency
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google OAuth API routes in Next.js</name>
  <files>
    v2/src/app/api/google/connect/route.ts
    v2/src/app/api/google/callback/route.ts
    v2/src/app/api/google/disconnect/route.ts
    v2/src/lib/google/oauth.ts
  </files>
  <exploration>
    Use Explore agent to understand:
    - Current Next.js API route patterns in v2/src/app/api/
    - How Convex auth is accessed from API routes
    - Environment variable patterns in Next.js

    Use researcher agent to verify:
    - Latest Next.js 16 API route patterns
    - Google OAuth 2.0 best practices for server-side flow
    - googleapis library usage for token exchange
  </exploration>
  <action>
    Create OAuth infrastructure following v1 patterns adapted for Next.js:

    1. **v2/src/lib/google/oauth.ts** - Shared utilities:
       - CALENDAR_SCOPE constant: 'https://www.googleapis.com/auth/calendar.events'
       - encodeState(userId: string, scopes: string[]) - base64 encode for state param
       - decodeState(state: string) - decode and validate state
       - getOAuthClient() - create google.auth.OAuth2 client with credentials
       - getAuthUrl(client, state) - generate authorization URL with offline access
       - exchangeCodeForTokens(client, code) - exchange auth code for tokens

    2. **v2/src/app/api/google/connect/route.ts** - Initiate OAuth:
       - GET handler that requires auth (check Convex session)
       - Generate state with userId from session
       - Redirect to Google OAuth consent screen
       - Scopes: calendar.events only (no Gmail)
       - access_type: 'offline' to get refresh token
       - prompt: 'consent' to always get refresh token

    3. **v2/src/app/api/google/callback/route.ts** - Handle OAuth callback:
       - GET handler with ?code and ?state query params
       - Decode and validate state (check userId matches session)
       - Exchange code for tokens (access_token, refresh_token, expiry)
       - Call Convex mutation to store tokens (encrypted if needed)
       - Redirect to /settings?tab=calendar&connected=true
       - Handle errors: redirect to /settings?tab=calendar&error=...

    4. **v2/src/app/api/google/disconnect/route.ts** - Disconnect:
       - POST handler that requires auth
       - Clear google* fields in userProfiles via Convex mutation
       - Return success JSON

    **Environment variables needed:**
    - GOOGLE_CLIENT_ID
    - GOOGLE_CLIENT_SECRET
    - NEXT_PUBLIC_APP_URL (for redirect URI)

    **Security:**
    - Validate state parameter to prevent CSRF
    - Use httpOnly cookies or server-side sessions
    - Don't expose tokens to client
  </action>
  <verify>
    - TypeScript compiles without errors: `cd v2 && pnpm build`
    - API routes accessible (will test manually in next plan)
    - Environment variable checks in place
  </verify>
  <done>
    OAuth API routes created with proper error handling, state validation, and token exchange
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Convex mutations for token storage and refresh</name>
  <files>
    v2/convex/googleAuth.ts
    v2/convex/lib/googleHelpers.ts
  </files>
  <exploration>
    Use Explore agent to understand:
    - Current userProfiles mutation patterns in users.ts
    - How internal mutations are structured
    - Token-related fields in schema.ts (google* fields)
  </exploration>
  <action>
    Create Convex functions for Google OAuth token management:

    1. **v2/convex/lib/googleHelpers.ts** - Helper utilities:
       ```typescript
       // Token expiry check with 5-minute buffer
       export function isTokenExpired(expiryTime: number | undefined): boolean

       // Calculate expiry timestamp from Google's expires_in
       export function calculateTokenExpiry(expiresIn: number): number
       ```

    2. **v2/convex/googleAuth.ts** - Mutations and queries:
       ```typescript
       // Store tokens after OAuth callback (internal - called from API route)
       export const storeGoogleTokens = internalMutation({
         args: {
           userId: v.id("users"),
           accessToken: v.string(),
           refreshToken: v.string(),
           expiryTime: v.number(),
           email: v.string(),
           scopes: v.array(v.string()),
         },
         handler: async (ctx, args) => {
           // Update userProfiles with google* fields
           // Set googleCalendarConnected: true
         },
       });

       // Clear tokens on disconnect (internal)
       export const clearGoogleTokens = internalMutation({
         args: { userId: v.id("users") },
         handler: async (ctx, args) => {
           // Clear all google* fields
           // Set googleCalendarConnected: false
         },
       });

       // Get current tokens for refresh check (internal query)
       export const getGoogleTokens = internalQuery({
         args: { userId: v.id("users") },
         handler: async (ctx, args) => {
           // Return tokens if connected, null otherwise
         },
       });

       // Check if user is connected (public query)
       export const isGoogleCalendarConnected = query({
         args: {},
         handler: async (ctx) => {
           const userId = await getCurrentUserIdOrNull(ctx);
           if (!userId) return false;
           // Check userProfiles.googleCalendarConnected
         },
       });
       ```

    **Important:**
    - Use internal mutations for token operations (not exposed to client)
    - API routes will call these via Convex HTTP client
    - Don't encrypt tokens in Convex (Convex handles encryption at rest)
  </action>
  <verify>
    - `cd v2 && npx convex dev` runs without errors
    - Types are correct: `pnpm test:run convex/googleAuth.test.ts`
  </verify>
  <done>
    Convex mutations created for token storage/clearing with proper auth checks
  </done>
</task>

<task type="auto">
  <name>Task 3: Create token refresh action for Google API calls</name>
  <files>
    v2/convex/googleCalendarActions.ts
  </files>
  <exploration>
    Use researcher agent to verify:
    - Google OAuth token refresh flow with googleapis library
    - Best practices for handling expired tokens
    - Rate limiting and error handling
  </exploration>
  <action>
    Create Convex action for refreshing Google tokens:

    **v2/convex/googleCalendarActions.ts**:
    ```typescript
    import { internalAction } from "./_generated/server";
    import { v } from "convex/values";
    import { internal } from "./_generated/api";
    import { OAuth2Client } from "google-auth-library";

    // Refresh access token if expired
    export const refreshAccessToken = internalAction({
      args: { userId: v.id("users") },
      handler: async (ctx, args) => {
        // 1. Get current tokens via internal query
        const tokens = await ctx.runQuery(internal.googleAuth.getGoogleTokens, { userId: args.userId });

        if (!tokens || !tokens.refreshToken) {
          throw new Error("No refresh token available");
        }

        // 2. Check if token is expired (5 min buffer)
        if (!isTokenExpired(tokens.expiryTime)) {
          return tokens.accessToken; // Still valid
        }

        // 3. Refresh the token using googleapis
        const oauth2Client = new OAuth2Client(
          process.env.GOOGLE_CLIENT_ID,
          process.env.GOOGLE_CLIENT_SECRET
        );
        oauth2Client.setCredentials({ refresh_token: tokens.refreshToken });

        try {
          const { credentials } = await oauth2Client.refreshAccessToken();

          // 4. Store new tokens
          await ctx.runMutation(internal.googleAuth.storeGoogleTokens, {
            userId: args.userId,
            accessToken: credentials.access_token!,
            refreshToken: tokens.refreshToken, // Keep existing refresh token
            expiryTime: calculateTokenExpiry(credentials.expiry_date || 3600),
            email: tokens.email,
            scopes: tokens.scopes,
          });

          return credentials.access_token;
        } catch (error) {
          // Token revoked or invalid - auto-disconnect
          console.error("Token refresh failed:", error);
          await ctx.runMutation(internal.googleAuth.clearGoogleTokens, { userId: args.userId });
          throw new Error("Token refresh failed - user disconnected");
        }
      },
    });

    // Get valid access token (refresh if needed)
    export const getValidAccessToken = internalAction({
      args: { userId: v.id("users") },
      handler: async (ctx, args) => {
        return await ctx.runAction(internal.googleCalendarActions.refreshAccessToken, { userId: args.userId });
      },
    });
    ```

    **Key behaviors:**
    - 5-minute buffer before expiry to prevent mid-request failures
    - Auto-disconnect if refresh fails (token revoked)
    - Log errors but don't expose details to user
  </action>
  <verify>
    - `cd v2 && npx convex dev` runs without errors
    - Action types are correct
    - Dependencies installed: `pnpm add google-auth-library`
  </verify>
  <done>
    Token refresh action created with auto-disconnect on revocation
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd v2 && pnpm build` succeeds without errors
- [ ] `cd v2 && npx convex dev` runs without schema errors
- [ ] OAuth API routes exist at /api/google/{connect,callback,disconnect}
- [ ] Convex mutations for token storage/clearing work
- [ ] google-auth-library dependency installed
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All 3 tasks completed
- OAuth infrastructure ready for UI integration
- Token storage and refresh mechanisms in place
- Error handling for revoked tokens implemented
- Ready for Plan 02 (Calendar Event CRUD)
</success_criteria>

<output>
After completion, create `.planning/phases/25.1-calendar-sync/25.1-01-SUMMARY.md`:

# Phase 25.1 Plan 01: OAuth Infrastructure Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified
- `path/to/file.ts` - Description

## Decisions Made
[Key decisions and rationale, or "None"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 25.1-02-PLAN.md (Calendar Event CRUD)
</output>
