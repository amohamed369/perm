---
phase: 25.1-calendar-sync
plan: 03
type: execute
domain: convex-mutations
---

<objective>
Integrate calendar sync into case mutations (create, update, delete, toggle).

Purpose: Automatically sync calendar events when case data changes.
Output: Case mutations trigger calendar sync automatically, with proper guards for connection status.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25.1-calendar-sync/25.1-CONTEXT.md
@.planning/phases/25.1-calendar-sync/25.1-01-SUMMARY.md
@.planning/phases/25.1-calendar-sync/25.1-02-SUMMARY.md

**Depends on:** Plans 01-02 (OAuth + Calendar CRUD actions)

**Codebase constraints:**
- Existing case mutations in convex/cases.ts
- Best-effort sync - never block case operations on sync failure
- Schedule sync as background action (don't await in mutation)

**Case Lifecycle Events to Hook:**
| Event | Calendar Action |
|-------|-----------------|
| Case created | Create events if sync enabled |
| Case updated | Update/delete changed events |
| Case soft-deleted | Delete all calendar events |
| Case restored | Recreate calendar events |
| toggleCalendarSync ON | Create all events |
| toggleCalendarSync OFF | Delete all events |

**v1 Reference:**
- Hook patterns: `backend/app/services/calendar_integration.py`

## Required Reading (MANDATORY)
| Doc | Path | Purpose |
|-----|------|---------|
| cases.ts | `v2/convex/cases.ts` | Current mutation patterns |
| v2/CLAUDE.md | `/Users/adammohamed/cc/perm-tracker-test/v2/CLAUDE.md` | API patterns |
| CONTEXT.md | `.planning/phases/25.1-calendar-sync/25.1-CONTEXT.md` | Edge cases |

## Quality Standards
- Best-effort sync (scheduler.runAfter, don't await)
- Check connection status before scheduling
- Log sync errors, don't throw
- Refactor mutations minimally
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create internal helper queries for sync eligibility</name>
  <files>
    v2/convex/lib/calendarSyncHelpers.ts
    v2/convex/googleAuth.ts (add query)
  </files>
  <exploration>
    Use Explore agent to understand:
    - How userProfiles calendar fields are accessed
    - Existing patterns for checking user settings
    - How internal queries are structured
  </exploration>
  <action>
    Create helper functions to check if sync should run:

    1. **Add to v2/convex/googleAuth.ts** - Check connection status:
       ```typescript
       // Check if user should sync calendar (connected + enabled)
       export const shouldSyncCalendar = internalQuery({
         args: { userId: v.id("users") },
         handler: async (ctx, args) => {
           const profile = await ctx.db
             .query("userProfiles")
             .withIndex("by_user_id", (q) => q.eq("userId", args.userId))
             .filter((q) => q.eq(q.field("deletedAt"), undefined))
             .first();

           if (!profile) return { shouldSync: false, reason: 'No profile' };

           // Check user-level calendar connection
           if (!profile.googleCalendarConnected) {
             return { shouldSync: false, reason: 'Not connected' };
           }

           // Check user-level calendar sync enabled
           if (!profile.calendarSyncEnabled) {
             return { shouldSync: false, reason: 'Sync disabled' };
           }

           return {
             shouldSync: true,
             preferences: {
               calendarSyncPwd: profile.calendarSyncPwd,
               calendarSyncEta9089: profile.calendarSyncEta9089,
               calendarSyncI140: profile.calendarSyncI140,
               calendarSyncRfi: profile.calendarSyncRfi,
               calendarSyncRfe: profile.calendarSyncRfe,
               calendarSyncRecruitment: profile.calendarSyncRecruitment,
               calendarSyncFilingWindow: profile.calendarSyncFilingWindow,
             },
           };
         },
       });
       ```

    2. **v2/convex/lib/calendarSyncHelpers.ts** - Sync scheduling helper:
       ```typescript
       import { ActionCtx } from "../_generated/server";
       import { internal } from "../_generated/api";
       import type { Id } from "../_generated/dataModel";

       /**
        * Schedule calendar sync for a case (best-effort, non-blocking)
        * Returns immediately, sync runs in background
        */
       export async function scheduleCalendarSync(
         ctx: ActionCtx | MutationCtx,
         userId: Id<"users">,
         caseId: Id<"cases">,
         operation: 'create' | 'update' | 'delete'
       ): Promise<void> {
         try {
           // Check if we should sync
           const syncCheck = await ctx.runQuery(internal.googleAuth.shouldSyncCalendar, { userId });

           if (!syncCheck.shouldSync) {
             console.log(`Skipping calendar sync: ${syncCheck.reason}`);
             return;
           }

           // Schedule the sync action (runs in background)
           if (operation === 'delete') {
             ctx.scheduler.runAfter(0, internal.googleCalendarActions.deleteCaseCalendarEvents, {
               userId,
               caseId,
             });
           } else {
             ctx.scheduler.runAfter(0, internal.googleCalendarActions.syncCaseCalendarEvents, {
               userId,
               caseId,
             });
           }
         } catch (error) {
           // Log but don't throw - calendar sync is best-effort
           console.error(`Failed to schedule calendar sync:`, error);
         }
       }
       ```
  </action>
  <verify>
    - `cd v2 && npx convex dev` runs without errors
    - Helper functions properly check connection status
  </verify>
  <done>
    Sync eligibility helpers created with proper connection checks
  </done>
</task>

<task type="auto">
  <name>Task 2: Add delete action and hook into case mutations</name>
  <files>
    v2/convex/googleCalendarActions.ts (add delete action)
    v2/convex/cases.ts (modify mutations)
  </files>
  <exploration>
    Use Explore agent to understand:
    - Current structure of cases.ts mutations
    - How scheduler.runAfter is used in existing code
    - calendarEventIds field in case schema
  </exploration>
  <action>
    1. **Add to v2/convex/googleCalendarActions.ts** - Delete all events for a case:
       ```typescript
       // Delete all calendar events for a case
       export const deleteCaseCalendarEvents = internalAction({
         args: {
           userId: v.id("users"),
           caseId: v.id("cases"),
         },
         handler: async (ctx, args) => {
           // Get case to find event IDs
           const caseData = await ctx.runQuery(internal.cases.getForSync, { id: args.caseId });
           if (!caseData) return { success: true }; // Case gone, nothing to delete

           // Delete all events
           const eventIds = caseData.calendarEventIds || {};
           const results = [];

           for (const eventId of Object.values(eventIds).filter(Boolean)) {
             const result = await ctx.runAction(internal.googleCalendarActions.deleteCalendarEvent, {
               userId: args.userId,
               eventId: eventId as string,
             });
             results.push(result);
           }

           // Clear event IDs from case (if case still exists)
           try {
             await ctx.runMutation(internal.cases.clearCalendarEventIds, { caseId: args.caseId });
           } catch (error) {
             // Case might be deleted, that's fine
           }

           return { success: true, eventsDeleted: results.length };
         },
       });
       ```

    2. **Modify v2/convex/cases.ts** - Add hooks to mutations:

       **Add internal query for sync:**
       ```typescript
       // Internal query for calendar sync (minimal fields)
       export const getForSync = internalQuery({
         args: { id: v.id("cases") },
         handler: async (ctx, args) => {
           const caseData = await ctx.db.get(args.id);
           if (!caseData || caseData.deletedAt) return null;
           return caseData;
         },
       });

       // Internal mutation to update calendar event IDs
       export const updateCalendarEventIds = internalMutation({
         args: {
           caseId: v.id("cases"),
           eventIds: v.record(v.string(), v.string()),
         },
         handler: async (ctx, args) => {
           await ctx.db.patch(args.caseId, {
             calendarEventIds: args.eventIds,
             updatedAt: Date.now(),
           });
         },
       });

       // Internal mutation to clear calendar event IDs
       export const clearCalendarEventIds = internalMutation({
         args: { caseId: v.id("cases") },
         handler: async (ctx, args) => {
           await ctx.db.patch(args.caseId, {
             calendarEventIds: undefined,
             updatedAt: Date.now(),
           });
         },
       });
       ```

       **Hook into create mutation:**
       ```typescript
       // In the create mutation, after inserting:
       // Check case-level sync flag
       if (result.calendarSyncEnabled !== false) {
         // Schedule calendar sync (non-blocking)
         ctx.scheduler.runAfter(0, internal.googleCalendarActions.syncCaseCalendarEvents, {
           userId,
           caseId: caseId,
         });
       }
       ```

       **Hook into update mutation:**
       ```typescript
       // In the update mutation, after patching:
       // Check if any deadline-relevant fields changed
       const deadlineFields = [
         'pwdExpirationDate', 'eta9089FilingDate', 'eta9089ExpirationDate',
         'eta9089CertificationDate', 'filingWindowOpens', 'recruitmentWindowCloses',
         'rfiEntries', 'rfeEntries', 'calendarSyncEnabled'
       ];
       const hasDeadlineChange = deadlineFields.some(f => f in args.data);

       if (hasDeadlineChange && existingCase.calendarSyncEnabled !== false) {
         ctx.scheduler.runAfter(0, internal.googleCalendarActions.syncCaseCalendarEvents, {
           userId,
           caseId: args.id,
         });
       }
       ```

       **Hook into softDelete mutation:**
       ```typescript
       // In softDelete, schedule event deletion
       ctx.scheduler.runAfter(0, internal.googleCalendarActions.deleteCaseCalendarEvents, {
         userId,
         caseId: args.id,
       });
       ```

       **Hook into restore mutation (if exists):**
       ```typescript
       // In restore, schedule event recreation
       if (existingCase.calendarSyncEnabled !== false) {
         ctx.scheduler.runAfter(0, internal.googleCalendarActions.syncCaseCalendarEvents, {
           userId,
           caseId: args.id,
         });
       }
       ```
  </action>
  <verify>
    - `cd v2 && pnpm build` succeeds
    - Case mutations compile with new hooks
    - Scheduler calls are non-blocking
  </verify>
  <done>
    Case mutations hooked to trigger calendar sync automatically
  </done>
</task>

<task type="auto">
  <name>Task 3: Add toggleCalendarSync mutation hook</name>
  <files>
    v2/convex/cases.ts (modify toggleCalendarSync)
  </files>
  <exploration>
    Use Explore agent to find:
    - Current toggleCalendarSync mutation in cases.ts
    - How it updates the calendarSyncEnabled field
  </exploration>
  <action>
    Modify the toggleCalendarSync mutation to trigger sync on toggle:

    ```typescript
    // Toggle calendar sync for a case
    export const toggleCalendarSync = mutation({
      args: {
        id: v.id("cases"),
        enabled: v.optional(v.boolean()), // If provided, set to this value; otherwise toggle
      },
      handler: async (ctx, args) => {
        const userId = await getCurrentUserId(ctx);
        const caseData = await ctx.db.get(args.id);

        if (!caseData || caseData.userId !== userId || caseData.deletedAt) {
          throw new Error("Case not found");
        }

        // Determine new value
        const currentValue = caseData.calendarSyncEnabled;
        const newValue = args.enabled !== undefined ? args.enabled : !currentValue;

        // Update case
        await ctx.db.patch(args.id, {
          calendarSyncEnabled: newValue,
          updatedAt: Date.now(),
        });

        // Schedule calendar action based on new state
        if (newValue) {
          // Turning ON - create events
          ctx.scheduler.runAfter(0, internal.googleCalendarActions.syncCaseCalendarEvents, {
            userId,
            caseId: args.id,
          });
        } else {
          // Turning OFF - delete events
          ctx.scheduler.runAfter(0, internal.googleCalendarActions.deleteCaseCalendarEvents, {
            userId,
            caseId: args.id,
          });
        }

        return { success: true, calendarSyncEnabled: newValue };
      },
    });
    ```

    **Key behaviors:**
    - Toggle ON → create all deadline events for case
    - Toggle OFF → delete all events for case
    - Respects user-level connection status (checked in sync action)
    - Non-blocking (scheduler.runAfter)
  </action>
  <verify>
    - `cd v2 && pnpm build` succeeds
    - Toggle mutation triggers appropriate sync action
  </verify>
  <done>
    toggleCalendarSync hooks calendar sync on toggle
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd v2 && pnpm build` succeeds without errors
- [ ] `cd v2 && npx convex dev` runs without errors
- [ ] Case create triggers calendar sync
- [ ] Case update with deadline changes triggers sync
- [ ] Case delete triggers event deletion
- [ ] toggleCalendarSync triggers sync/delete appropriately
- [ ] All sync operations are non-blocking (scheduler.runAfter)
</verification>

<success_criteria>
- All 3 tasks completed
- Case mutations automatically sync calendar
- Toggle mutation works for on/off
- Best-effort sync (never blocks)
- Ready for Plan 04 (Settings UI Update)
</success_criteria>

<output>
After completion, create `.planning/phases/25.1-calendar-sync/25.1-03-SUMMARY.md`:

# Phase 25.1 Plan 03: Case Mutation Hooks Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified
- `path/to/file.ts` - Description

## Decisions Made
[Key decisions and rationale, or "None"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 25.1-04-PLAN.md (Settings UI Update)
</output>
