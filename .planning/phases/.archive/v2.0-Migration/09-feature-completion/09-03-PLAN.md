---
phase: 09-feature-completion
plan: 03
type: execute
---

<objective>
Implement conflict resolution logic, sync status API, and frontend UI for calendar sync.

Purpose: Handle conflicts when events are modified in both systems and provide user visibility into sync status.
Output: Conflict detection logic, sync status endpoints, and frontend sync status UI.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-feature-completion/09-01-SUMMARY.md
@.planning/phases/09-feature-completion/09-02-SUMMARY.md

**Codebase context:**
@backend/app/services/calendar_sync_service.py
@backend/app/services/calendar_integration.py
@backend/app/api/google_services.py
@frontend/src/js/pages/settings.js

**Conflict resolution strategy (PROJECT.md open question):**
For PERM Tracker, the app should be "source of truth" for deadlines.
- App-created events reflect legal deadlines - dates shouldn't change
- If user modifies event in Google Calendar, we detect and log it
- For now: Log conflicts but don't auto-overwrite (inform user)
- Future: Could add "resync" button to push app truth back to calendar

**Phase 7 decision affecting this phase:**
- Use Sanitizer.text() or textContent for all dynamic content (XSS prevention)
- Use DOM construction pattern, NOT innerHTML with string interpolation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement conflict detection logic</name>
  <files>backend/app/services/calendar_sync_service.py</files>
  <action>
Enhance process_event_changes to detect and handle conflicts:

```python
# Add to CalendarSyncService class:

@staticmethod
async def process_event_changes(user_id: str, events: List[Dict]):
    """
    Process changed events from Google Calendar.
    Detects conflicts and creates notifications for user.
    """
    from app.services.notification_service import NotificationService
    from app.schemas.notification import NotificationCreate

    supabase = get_supabase_client()

    conflicts_found = 0
    deletions_found = 0

    for event in events:
        event_id = event.get("id")
        status = event.get("status")
        summary = event.get("summary", "")

        # Check if this is one of our PERM deadline events
        description = event.get("description", "")

        # Our events have case IDs in description like "Case: abc123-..."
        case_id = CalendarSyncService._extract_case_id_from_description(description)
        if not case_id:
            # Not our event - skip
            continue

        # Get the case to compare
        case_response = (
            supabase.table("cases")
            .select("id, employer_name, position_title, calendar_event_ids")
            .eq("id", case_id)
            .single()
            .execute()
        )

        if not case_response.data:
            logger.warning(f"Case {case_id} not found for event {event_id}")
            continue

        case = case_response.data
        calendar_event_ids = case.get("calendar_event_ids", {}) or {}

        # Find which deadline type this event represents
        deadline_type = CalendarSyncService._find_deadline_type_by_event_id(
            calendar_event_ids, event_id
        )

        if status == "cancelled":
            # Event was deleted in Google Calendar
            logger.info(
                f"Event {event_id} ({deadline_type}) deleted for case {case_id}"
            )
            deletions_found += 1

            # Remove from calendar_event_ids
            if deadline_type and deadline_type in calendar_event_ids:
                del calendar_event_ids[deadline_type]
                supabase.table("cases").update({
                    "calendar_event_ids": calendar_event_ids
                }).eq("id", case_id).execute()

            # Create notification about deletion
            notification = NotificationCreate(
                case_id=case_id,
                type="calendar_sync",
                title="Calendar Event Deleted",
                message=(
                    f"The {deadline_type.replace('_', ' ').title()} event for "
                    f"{case.get('employer_name', 'Unknown')} was deleted from "
                    "Google Calendar. Re-sync to recreate it."
                ),
                priority="normal",
            )
            NotificationService.create_notification(user_id, notification)

        else:
            # Event was modified - check for date conflicts
            event_start = event.get("start", {})
            event_date = event_start.get("date") or event_start.get("dateTime", "")[:10]

            if event_date and deadline_type:
                # Get expected date from case
                expected_date = CalendarSyncService._get_expected_date(
                    case_id, deadline_type, supabase
                )

                if expected_date and event_date != expected_date:
                    logger.warning(
                        f"Date conflict for {deadline_type}: "
                        f"Google={event_date}, App={expected_date}"
                    )
                    conflicts_found += 1

                    # Create notification about conflict
                    notification = NotificationCreate(
                        case_id=case_id,
                        type="calendar_sync",
                        title="Calendar Date Conflict",
                        message=(
                            f"The {deadline_type.replace('_', ' ').title()} event "
                            f"was changed to {event_date} in Google Calendar, but "
                            f"the app has {expected_date}. The app date is the "
                            "legal deadline - consider re-syncing."
                        ),
                        priority="high",
                    )
                    NotificationService.create_notification(user_id, notification)

    # Update last synced timestamp
    supabase.table("perm_users").update({
        "calendar_last_synced_at": datetime.utcnow().isoformat()
    }).eq("id", user_id).execute()

    if conflicts_found or deletions_found:
        logger.info(
            f"Sync complete for user {user_id}: "
            f"{conflicts_found} conflicts, {deletions_found} deletions"
        )

@staticmethod
def _extract_case_id_from_description(description: str) -> Optional[str]:
    """Extract case ID from event description"""
    import re
    # Look for UUID pattern after "Case:" or in permtracker.app URL
    patterns = [
        r"Case:\s*([a-f0-9-]{36})",
        r"permtracker\.app/cases/([a-f0-9-]{36})",
    ]
    for pattern in patterns:
        match = re.search(pattern, description, re.IGNORECASE)
        if match:
            return match.group(1)
    return None

@staticmethod
def _find_deadline_type_by_event_id(
    calendar_event_ids: Dict[str, str],
    event_id: str
) -> Optional[str]:
    """Find which deadline type an event ID corresponds to"""
    for deadline_type, stored_event_id in calendar_event_ids.items():
        if stored_event_id == event_id:
            return deadline_type
    return None

@staticmethod
def _get_expected_date(
    case_id: str,
    deadline_type: str,
    supabase
) -> Optional[str]:
    """Get expected date for a deadline type from the case"""
    # Map deadline types to case columns
    date_columns = {
        "pwd_expiration": "pwd_expiration_date",
        "eta9089_filing": "eta9089_filing_date",
        "eta9089_expiration": "eta9089_expiration_date",
        "i140_filing": "i140_filing_date",
        # Add more as needed
    }

    column = date_columns.get(deadline_type)
    if not column:
        return None

    response = (
        supabase.table("cases")
        .select(column)
        .eq("id", case_id)
        .single()
        .execute()
    )

    if response.data:
        return response.data.get(column)
    return None
```
  </action>
  <verify>Import check: `cd backend && python -c "from app.services.calendar_sync_service import CalendarSyncService; print('OK')"`</verify>
  <done>Conflict detection creates notifications for date conflicts and deletions</done>
</task>

<task type="auto">
  <name>Task 2: Add sync status endpoints</name>
  <files>backend/app/api/google_services.py</files>
  <action>
Add sync status endpoints to the existing google_services router:

```python
# Add to google_services.py:

from app.services.calendar_sync_service import CalendarSyncService

@router.get("/sync-status")
async def get_calendar_sync_status(
    current_user: User = Depends(get_current_user)
):
    """
    Get calendar sync status for current user.
    Returns channel info, last sync time, and sync health.
    """
    user_id = str(current_user.id)

    # Get channel info
    channel = CalendarSyncService.get_user_channel(user_id)

    # Get user sync timestamp
    supabase = get_supabase_client()
    user_response = (
        supabase.table("perm_users")
        .select("calendar_connected, calendar_last_synced_at")
        .eq("id", user_id)
        .single()
        .execute()
    )
    user_data = user_response.data or {}

    if not channel:
        return {
            "status": "not_subscribed",
            "calendar_connected": user_data.get("calendar_connected", False),
            "channel": None,
            "last_synced_at": user_data.get("calendar_last_synced_at"),
        }

    # Check channel health
    now_ms = int(datetime.utcnow().timestamp() * 1000)
    expiration_ms = channel["expiration_timestamp"]
    expires_in_hours = (expiration_ms - now_ms) / (1000 * 60 * 60)

    status = "healthy"
    if expires_in_hours < 24:
        status = "expiring_soon"
    elif expires_in_hours < 0:
        status = "expired"

    return {
        "status": status,
        "calendar_connected": user_data.get("calendar_connected", False),
        "channel": {
            "channel_id": channel["channel_id"],
            "calendar_id": channel["calendar_id"],
            "expires_in_hours": round(expires_in_hours, 1),
            "has_sync_token": bool(channel.get("sync_token")),
        },
        "last_synced_at": user_data.get("calendar_last_synced_at"),
        "last_notification_at": channel.get("last_notification_at"),
    }


@router.post("/enable-two-way-sync")
async def enable_two_way_sync(
    current_user: User = Depends(get_current_user)
):
    """
    Enable two-way calendar sync by creating a push notification channel.
    Requires calendar to be connected first.
    """
    user_id = str(current_user.id)

    # Check if calendar is connected
    supabase = get_supabase_client()
    user_response = (
        supabase.table("perm_users")
        .select("calendar_connected")
        .eq("id", user_id)
        .single()
        .execute()
    )

    if not user_response.data or not user_response.data.get("calendar_connected"):
        raise HTTPException(
            status_code=400,
            detail="Calendar must be connected before enabling two-way sync"
        )

    try:
        channel = await CalendarSyncService.ensure_user_has_channel(user_id)

        # Do initial sync to get sync token
        if not channel.get("sync_token"):
            sync_token = await CalendarSyncService.do_initial_sync(user_id)
            CalendarSyncService.update_sync_token(channel["channel_id"], sync_token)

        return {
            "success": True,
            "message": "Two-way sync enabled",
            "channel_id": channel["channel_id"],
        }

    except Exception as e:
        logger.error(f"Failed to enable two-way sync: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to enable two-way sync: {str(e)}"
        )


@router.post("/resync-calendar")
async def resync_calendar_events(
    current_user: User = Depends(get_current_user)
):
    """
    Force resync all calendar events for current user.
    Pushes app deadlines back to Google Calendar.
    """
    from app.services.calendar_integration import CalendarIntegration

    user_id = str(current_user.id)

    # Get all user's cases with sync enabled
    supabase = get_supabase_client()
    cases_response = (
        supabase.table("cases")
        .select("id")
        .eq("user_id", user_id)
        .eq("calendar_sync_enabled", True)
        .is_("deleted_at", "null")
        .execute()
    )

    cases = cases_response.data or []
    synced = 0
    failed = 0

    for case in cases:
        try:
            CalendarIntegration.update_case_events(user_id, case["id"])
            synced += 1
        except Exception as e:
            logger.error(f"Failed to resync case {case['id']}: {e}")
            failed += 1

    return {
        "success": True,
        "message": f"Resynced {synced} cases ({failed} failed)",
        "synced": synced,
        "failed": failed,
    }
```

Add required imports at top of file if not present:
```python
from datetime import datetime
from app.services.calendar_sync_service import CalendarSyncService
```
  </action>
  <verify>Endpoint check: `cd backend && python -c "from app.api.google_services import router; print([r.path for r in router.routes])"`</verify>
  <done>Sync status endpoints added to google_services router</done>
</task>

<task type="auto">
  <name>Task 3: Add sync status UI to settings page</name>
  <files>frontend/src/js/pages/settings.js</files>
  <action>
Add calendar sync status section to the settings page using safe DOM construction (NOT innerHTML).

Find the calendar section in settings.js and add these functions:

```javascript
// Add function to fetch and display sync status using safe DOM methods:
async function loadCalendarSyncStatus() {
    const statusContainer = document.getElementById('calendar-sync-status');
    if (!statusContainer) return;

    // Clear existing content safely
    statusContainer.textContent = '';

    try {
        const response = await fetch('/api/google/sync-status', {
            headers: { 'Authorization': `Bearer ${getToken()}` }
        });

        if (!response.ok) {
            const errorP = document.createElement('p');
            errorP.className = 'text-gray-500';
            errorP.textContent = 'Unable to load sync status';
            statusContainer.appendChild(errorP);
            return;
        }

        const data = await response.json();

        // Create status container
        const statusDiv = document.createElement('div');
        statusDiv.className = 'rounded-lg p-4';

        if (!data.calendar_connected) {
            statusDiv.className += ' bg-gray-50';
            const msg = document.createElement('p');
            msg.className = 'text-gray-600';
            msg.textContent = 'Calendar not connected.';
            statusDiv.appendChild(msg);

        } else if (data.status === 'not_subscribed') {
            statusDiv.className += ' bg-yellow-50';
            const msg = document.createElement('p');
            msg.className = 'text-yellow-700';
            msg.textContent = 'Calendar connected but two-way sync not enabled.';
            statusDiv.appendChild(msg);

            const btn = document.createElement('button');
            btn.className = 'mt-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700';
            btn.textContent = 'Enable Two-Way Sync';
            btn.addEventListener('click', enableTwoWaySync);
            statusDiv.appendChild(btn);

        } else if (data.status === 'healthy') {
            statusDiv.className += ' bg-green-50';

            // Status indicator row
            const indicatorRow = document.createElement('div');
            indicatorRow.className = 'flex items-center';

            const dot = document.createElement('div');
            dot.className = 'w-3 h-3 bg-green-500 rounded-full mr-2';
            indicatorRow.appendChild(dot);

            const statusText = document.createElement('span');
            statusText.className = 'text-green-700 font-medium';
            statusText.textContent = 'Two-way sync active';
            indicatorRow.appendChild(statusText);

            statusDiv.appendChild(indicatorRow);

            // Last synced
            const lastSynced = document.createElement('p');
            lastSynced.className = 'text-sm text-gray-600 mt-2';
            lastSynced.textContent = 'Last synced: ' + (formatDate(data.last_synced_at) || 'Never');
            statusDiv.appendChild(lastSynced);

            // Expiration info
            const expiresIn = document.createElement('p');
            expiresIn.className = 'text-sm text-gray-500';
            const hours = Math.round(data.channel?.expires_in_hours || 0);
            expiresIn.textContent = 'Channel expires in ' + hours + ' hours';
            statusDiv.appendChild(expiresIn);

            // Resync link
            const resyncBtn = document.createElement('button');
            resyncBtn.className = 'mt-2 text-sm text-blue-600 hover:underline';
            resyncBtn.textContent = 'Force Resync';
            resyncBtn.addEventListener('click', resyncCalendar);
            statusDiv.appendChild(resyncBtn);

        } else if (data.status === 'expiring_soon') {
            statusDiv.className += ' bg-yellow-50';

            const indicatorRow = document.createElement('div');
            indicatorRow.className = 'flex items-center';

            const dot = document.createElement('div');
            dot.className = 'w-3 h-3 bg-yellow-500 rounded-full mr-2';
            indicatorRow.appendChild(dot);

            const statusText = document.createElement('span');
            statusText.className = 'text-yellow-700 font-medium';
            statusText.textContent = 'Sync channel expiring soon';
            indicatorRow.appendChild(statusText);

            statusDiv.appendChild(indicatorRow);

            const msg = document.createElement('p');
            msg.className = 'text-sm text-gray-600 mt-2';
            msg.textContent = 'Will be automatically renewed.';
            statusDiv.appendChild(msg);

        } else {
            // Expired or error state
            statusDiv.className += ' bg-red-50';

            const indicatorRow = document.createElement('div');
            indicatorRow.className = 'flex items-center';

            const dot = document.createElement('div');
            dot.className = 'w-3 h-3 bg-red-500 rounded-full mr-2';
            indicatorRow.appendChild(dot);

            const statusText = document.createElement('span');
            statusText.className = 'text-red-700 font-medium';
            statusText.textContent = 'Sync channel expired';
            indicatorRow.appendChild(statusText);

            statusDiv.appendChild(indicatorRow);

            const btn = document.createElement('button');
            btn.className = 'mt-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700';
            btn.textContent = 'Re-enable Sync';
            btn.addEventListener('click', enableTwoWaySync);
            statusDiv.appendChild(btn);
        }

        statusContainer.appendChild(statusDiv);

    } catch (error) {
        logger.error('Failed to load sync status', error);
        const errorP = document.createElement('p');
        errorP.className = 'text-red-500';
        errorP.textContent = 'Error loading sync status';
        statusContainer.appendChild(errorP);
    }
}

async function enableTwoWaySync() {
    try {
        const response = await fetch('/api/google/enable-two-way-sync', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${getToken()}` }
        });

        if (response.ok) {
            showToast('Two-way sync enabled', 'success');
            loadCalendarSyncStatus();
        } else {
            const error = await response.json();
            showToast(error.detail || 'Failed to enable sync', 'error');
        }
    } catch (error) {
        logger.error('Enable two-way sync failed', error);
        showToast('Failed to enable sync', 'error');
    }
}

async function resyncCalendar() {
    try {
        const response = await fetch('/api/google/resync-calendar', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${getToken()}` }
        });

        const data = await response.json();
        if (response.ok) {
            showToast('Resynced ' + data.synced + ' cases', 'success');
            loadCalendarSyncStatus();
        } else {
            showToast(data.detail || 'Resync failed', 'error');
        }
    } catch (error) {
        logger.error('Resync failed', error);
        showToast('Resync failed', 'error');
    }
}

// Helper function
function formatDate(isoString) {
    if (!isoString) return null;
    return new Date(isoString).toLocaleString();
}
```

Add HTML element in the Google Calendar section of settings (find the existing calendar connect section):
```html
<div id="calendar-sync-status" class="mt-4">
    <!-- Populated by loadCalendarSyncStatus() -->
</div>
```

Call loadCalendarSyncStatus() when settings page loads (in init or DOMContentLoaded).
  </action>
  <verify>Manual verification needed - UI changes require visual check</verify>
  <done>Sync status UI added to settings page using safe DOM construction</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Two-way calendar sync with conflict detection, sync status API, and settings UI</what-built>
  <how-to-verify>
    1. Start backend: cd backend && ./start_test.sh
    2. Start frontend: cd frontend && npm run dev
    3. Visit http://localhost:3000/settings
    4. Verify Google Calendar section shows sync status
    5. If calendar is connected:
       - Click "Enable Two-Way Sync" button
       - Verify status changes to "Two-way sync active"
       - Check "Force Resync" button works
    6. Check backend logs for channel creation
    7. Note: Actual webhook notifications won't work locally without HTTPS tunnel

    Note: Full end-to-end testing requires:
    - HTTPS endpoint (ngrok or production)
    - Domain verification in Google Cloud Console
    - This checkpoint verifies the UI and API work, not the webhook flow
  </how-to-verify>
  <resume-signal>Type "approved" if UI works, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Conflict detection creates notifications
- [ ] Sync status endpoint returns correct data
- [ ] Settings page shows sync status UI (using safe DOM methods, no innerHTML)
- [ ] Enable/disable sync buttons work
- [ ] Backend logs show expected behavior
</verification>

<success_criteria>
- Conflict detection identifies date changes and deletions
- Sync status endpoint provides channel health info
- Settings page displays sync status with action buttons
- User can enable two-way sync and force resync
- Phase 9 complete - Google Calendar two-way sync infrastructure in place
</success_criteria>

<output>
After completion, create `.planning/phases/09-feature-completion/09-03-SUMMARY.md`
</output>
