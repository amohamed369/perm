---
phase: 28-action-layer
plan: 02
type: execute
---

<objective>
Add navigation and client-side action tools to the chatbot.

Purpose: Enable chatbot to navigate users to pages, cases, forms, and scroll to elements - visual client-side actions that enhance the assistant experience.
Output: 4 navigation tools (navigate, view_case, scroll_to, refresh_page), client action executor, extended tool icons.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-action-layer/28-CONTEXT.md
@.planning/phases/28-action-layer/28-01-SUMMARY.md

**Existing tool infrastructure (Phase 27):**
@v2/src/lib/ai/tools.ts
@v2/src/components/chat/tool-icons.tsx
@v2/src/components/chat/tool-result-summary.ts
@v2/src/app/api/chat/route.ts

**Navigation tools are AUTONOMOUS - no permission needed:**
- navigate: Go to any page
- view_case: Open specific case detail
- scroll_to: Scroll to element on page
- refresh_page: Reload current page

**Client-side execution pattern:**
- Tools return `clientAction` object
- Frontend executes via Next.js router or DOM APIs
- No Convex mutation needed

**Design system:**
Read `.planning/FRONTEND_DESIGN_SKILL.md` for UI work.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define navigation tool schemas</name>
  <files>v2/src/lib/ai/tools.ts</files>
  <exploration>
    Use Explore agent to find: existing tool definition patterns in tools.ts, how Zod schemas are structured, available pages/routes in v2.
  </exploration>
  <action>
    1. Add navigation tools to tools.ts following existing pattern:

    ```typescript
    // Navigation Tools - AUTONOMOUS (no permission needed)

    const NavigateInputSchema = z.object({
      path: z.enum([
        "/dashboard",
        "/cases",
        "/cases/new",
        "/calendar",
        "/timeline",
        "/notifications",
        "/settings",
        "/settings/profile",
        "/settings/notifications",
        "/settings/calendar",
        "/settings/account",
      ]).describe("The page path to navigate to"),
      reason: z.string().optional().describe("Why navigating (shown to user)"),
    });

    export const navigateTool = tool({
      description: `Navigate to a page in the application.

WHEN TO USE:
- User asks to "go to", "open", "show me" a page
- User wants to see dashboard, cases, calendar, timeline, notifications, or settings
- After creating/updating something, to show the result

WHEN NOT TO USE:
- User asks about a specific case (use view_case instead)
- User just wants information (answer without navigating)`,
      inputSchema: NavigateInputSchema,
    });

    const ViewCaseInputSchema = z.object({
      caseId: z.string().describe("The Convex ID of the case to view"),
      section: z.enum(["overview", "timeline", "edit"]).optional()
        .describe("Which section to show (defaults to overview)"),
    });

    export const viewCaseTool = tool({
      description: `Navigate to a specific case's detail page.

WHEN TO USE:
- User asks to "show", "open", "view" a specific case
- After querying cases, user wants to see one in detail
- User asks "take me to the Acme case"

WHEN NOT TO USE:
- User just wants case data (use queryCases)
- User wants to edit (navigate with section: "edit")`,
      inputSchema: ViewCaseInputSchema,
    });

    const ScrollToInputSchema = z.object({
      target: z.enum([
        "top",
        "bottom",
        "deadlines",
        "recent-activity",
        "form-section",
        "timeline",
      ]).describe("Where to scroll on the current page"),
      smooth: z.boolean().optional().default(true)
        .describe("Use smooth scrolling animation"),
    });

    export const scrollToTool = tool({
      description: `Scroll to a section on the current page.

WHEN TO USE:
- User asks to "scroll to", "show me", "go to" a section
- After explaining something, scroll to show it
- User says "take me to the deadlines section"

WHEN NOT TO USE:
- User wants a different page (use navigate)`,
      inputSchema: ScrollToInputSchema,
    });

    const RefreshPageInputSchema = z.object({
      reason: z.string().optional().describe("Why refreshing (shown to user)"),
    });

    export const refreshPageTool = tool({
      description: `Refresh the current page to get latest data.

WHEN TO USE:
- User reports stale data
- After external changes that need refresh
- User explicitly asks to refresh

WHEN NOT TO USE:
- Convex real-time already handles updates
- Just querying data (use queryCases)`,
      inputSchema: RefreshPageInputSchema,
    });
    ```

    2. Add to chatTools export:
    ```typescript
    export const chatTools = {
      // Existing
      queryCases: queryCasesTool,
      searchKnowledge: searchKnowledgeTool,
      searchWeb: searchWebTool,
      // Navigation (new)
      navigate: navigateTool,
      viewCase: viewCaseTool,
      scrollTo: scrollToTool,
      refreshPage: refreshPageTool,
    };
    ```

    3. Export input schemas for type safety.
  </action>
  <verify>TypeScript compiles, tools.ts exports new tools</verify>
  <done>4 navigation tools defined with Zod schemas and descriptions</done>
</task>

<task type="auto">
  <name>Task 2: Extend tool icons and result summaries</name>
  <files>v2/src/components/chat/tool-icons.tsx, v2/src/components/chat/tool-result-summary.ts</files>
  <exploration>
    Use Explore agent to find: existing TOOL_ICONS mapping, TOOL_COLORS mapping, summarizeToolResult function structure.
  </exploration>
  <action>
    1. Update tool-icons.tsx with navigation tool icons:
    ```typescript
    import {
      Database, BookOpen, Globe, Pencil, Trash2, Calendar,
      // Add navigation icons
      Navigation, Eye, ArrowDown, RefreshCw,
    } from 'lucide-react';

    export const TOOL_ICONS: Record<string, LucideIcon> = {
      // Existing
      queryCases: Database,
      searchKnowledge: BookOpen,
      searchWeb: Globe,
      updateCase: Pencil,
      deleteCase: Trash2,
      syncCalendar: Calendar,
      // Navigation (new)
      navigate: Navigation,
      viewCase: Eye,
      scrollTo: ArrowDown,
      refreshPage: RefreshCw,
    };

    export const TOOL_COLORS: Record<string, string> = {
      // Existing
      queryCases: 'text-blue-600',
      searchKnowledge: 'text-purple-600',
      searchWeb: 'text-emerald-600',
      updateCase: 'text-amber-600',
      deleteCase: 'text-red-600',
      syncCalendar: 'text-teal-600',
      // Navigation (new) - use gray/neutral for non-data actions
      navigate: 'text-slate-600',
      viewCase: 'text-blue-600',
      scrollTo: 'text-slate-500',
      refreshPage: 'text-slate-500',
    };
    ```

    2. Update TOOL_DISPLAY_NAMES:
    ```typescript
    export const TOOL_DISPLAY_NAMES: Record<string, string> = {
      queryCases: 'Query Cases',
      searchKnowledge: 'Search Knowledge',
      searchWeb: 'Web Search',
      navigate: 'Navigate',
      viewCase: 'View Case',
      scrollTo: 'Scroll To',
      refreshPage: 'Refresh Page',
    };
    ```

    3. Update getToolLoadingMessage:
    ```typescript
    navigate: 'Navigating...',
    viewCase: 'Opening case...',
    scrollTo: 'Scrolling...',
    refreshPage: 'Refreshing...',
    ```

    4. Update tool-result-summary.ts:
    ```typescript
    export function summarizeToolResult(toolName: string, result: unknown): string {
      // ... existing cases

      case 'navigate':
        return `Navigated to ${result.path}`;
      case 'viewCase':
        return `Opened case`;
      case 'scrollTo':
        return `Scrolled to ${result.target}`;
      case 'refreshPage':
        return `Page refreshed`;
    }
    ```

    5. Update getToolPriorityKeys for argument display:
    ```typescript
    navigate: ['path', 'reason'],
    viewCase: ['caseId', 'section'],
    scrollTo: ['target'],
    refreshPage: ['reason'],
    ```
  </action>
  <verify>Icons render for new tools, result summaries display correctly</verify>
  <done>Tool icons, colors, display names, and result summaries extended for navigation tools</done>
</task>

<task type="auto">
  <name>Task 3: Create client action executor and integrate tools</name>
  <files>v2/src/lib/ai/client-actions.ts, v2/src/hooks/useClientActions.ts, v2/src/app/api/chat/route.ts</files>
  <exploration>
    Use Explore agent to find: how chat API route handles tool execution, Next.js router usage patterns in v2, existing hooks structure.
  </exploration>
  <action>
    1. Create client-actions.ts - type definitions:
    ```typescript
    export type ClientActionType =
      | 'navigate'
      | 'viewCase'
      | 'scrollTo'
      | 'refreshPage';

    export interface ClientAction {
      type: ClientActionType;
      payload: Record<string, unknown>;
    }

    export interface NavigateAction extends ClientAction {
      type: 'navigate';
      payload: { path: string; reason?: string };
    }

    export interface ViewCaseAction extends ClientAction {
      type: 'viewCase';
      payload: { caseId: string; section?: string };
    }

    export interface ScrollToAction extends ClientAction {
      type: 'scrollTo';
      payload: { target: string; smooth?: boolean };
    }

    export interface RefreshPageAction extends ClientAction {
      type: 'refreshPage';
      payload: { reason?: string };
    }
    ```

    2. Create useClientActions.ts hook:
    ```typescript
    'use client';
    import { useRouter } from 'next/navigation';
    import { useCallback } from 'react';
    import type { ClientAction } from '@/lib/ai/client-actions';

    export function useClientActions() {
      const router = useRouter();

      const executeAction = useCallback(async (action: ClientAction) => {
        switch (action.type) {
          case 'navigate':
            router.push(action.payload.path as string);
            return { success: true, path: action.payload.path };

          case 'viewCase':
            const { caseId, section } = action.payload;
            const path = section === 'edit'
              ? `/cases/${caseId}/edit`
              : `/cases/${caseId}`;
            router.push(path);
            return { success: true, caseId };

          case 'scrollTo':
            const { target, smooth = true } = action.payload;
            const element = document.querySelector(`[data-scroll-target="${target}"]`);
            if (element) {
              element.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto' });
              return { success: true, target };
            }
            // Fallback for special targets
            if (target === 'top') window.scrollTo({ top: 0, behavior: smooth ? 'smooth' : 'auto' });
            if (target === 'bottom') window.scrollTo({ top: document.body.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
            return { success: true, target };

          case 'refreshPage':
            router.refresh();
            return { success: true };

          default:
            return { success: false, error: 'Unknown action type' };
        }
      }, [router]);

      return { executeAction };
    }
    ```

    3. Update API route to handle navigation tools:
    ```typescript
    // In createTools function, add execute functions for navigation tools:

    navigate: {
      description: navigateTool.description,
      inputSchema: NavigateInputSchema,
      execute: async (params: z.infer<typeof NavigateInputSchema>) => {
        // Navigation is client-side, return action for frontend
        return {
          success: true,
          clientAction: {
            type: 'navigate',
            payload: params,
          },
          message: `Navigating to ${params.path}`,
        };
      },
    },

    viewCase: {
      description: viewCaseTool.description,
      inputSchema: ViewCaseInputSchema,
      execute: async (params: z.infer<typeof ViewCaseInputSchema>) => {
        return {
          success: true,
          clientAction: {
            type: 'viewCase',
            payload: params,
          },
          message: `Opening case ${params.caseId}`,
        };
      },
    },

    // Similar for scrollTo and refreshPage
    ```

    4. Update chat message handling to detect and queue client actions from tool results.

    5. Integrate useClientActions in ChatPanel or parent component to execute queued actions.
  </action>
  <verify>Navigation tools execute and trigger router.push, scrollTo works, refresh works</verify>
  <done>Client action system working, navigation tools integrated with API route</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds in v2/
- [ ] 4 navigation tools appear in chatTools export
- [ ] Tool icons render correctly for navigation tools
- [ ] "Go to dashboard" triggers navigate tool and navigates
- [ ] "Show me case X" triggers viewCase tool
- [ ] "Scroll to deadlines" triggers scrollTo tool
- [ ] Client actions execute in browser
- [ ] No TypeScript errors
</verification>

<success_criteria>
- 4 navigation tools defined with proper Zod schemas
- Tool icons and colors configured
- Client action executor hook working
- Navigation tools integrated in API route
- Tools work end-to-end (chat → API → client action → navigation)
</success_criteria>

<output>
After completion, create `.planning/phases/28-action-layer/28-02-SUMMARY.md`:

# Phase 28 Plan 02: Navigation & Read Tools Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 28-03-PLAN.md (Case CRUD Tools)
</output>
