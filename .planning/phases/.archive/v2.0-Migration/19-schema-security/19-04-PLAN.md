---
phase: 19-schema-security
plan: 04
type: execute
---

<objective>
Implement audit logging system with field-level change tracking and security tests.

Purpose: Provide detailed change history for compliance and debugging, plus comprehensive security tests.
Output: Audit logging library, integrated logging in mutations, query functions, and TDD security tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-schema-security/19-CONTEXT.md
@.planning/phases/19-schema-security/19-01-SUMMARY.md
@.planning/phases/19-schema-security/19-02-SUMMARY.md
@.planning/phases/19-schema-security/19-03-SUMMARY.md
@v2/test-utils/convex.ts

**Prior plan context:**
- 19-01: Core tables defined (users, userProfiles, cases)
- 19-02: Supporting tables defined (notifications, conversations, auditLogs)
- 19-03: Auth helpers and secure CRUD patterns created

**Audit logging requirements from 19-CONTEXT.md:**
- Every mutation captures: userId, tableName, documentId, action
- For updates: field-level old â†’ new value tracking
- Queryable by user, table, document, date range
- Audit logs immutable (no update/delete)

**Testing requirements (TDD):**
- Unauthenticated access denied
- User A cannot access User B's data
- Soft-deleted records excluded
- Ownership verification on update/delete
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit logging library (convex/lib/audit.ts)</name>
  <files>v2/convex/lib/audit.ts</files>
  <action>
Create the audit logging utility:

```typescript
import { MutationCtx } from "../_generated/server";
import { Id } from "../_generated/dataModel";
import { getCurrentUserId } from "./auth";

export type AuditAction = "create" | "update" | "delete";

export interface FieldChange {
  field: string;
  oldValue?: unknown;
  newValue?: unknown;
}

export interface AuditMetadata {
  ipAddress?: string;
  userAgent?: string;
  source?: "web" | "api" | "chatbot";
}

/**
 * Calculate field-level changes between old and new document.
 * Only includes fields that actually changed.
 */
export function calculateChanges(
  oldDoc: Record<string, unknown> | undefined,
  newDoc: Record<string, unknown> | undefined
): FieldChange[] {
  const changes: FieldChange[] = [];

  if (!oldDoc && newDoc) {
    // Create: all fields are new
    for (const [field, value] of Object.entries(newDoc)) {
      // Skip internal fields
      if (field.startsWith("_")) continue;
      changes.push({ field, newValue: value });
    }
    return changes;
  }

  if (oldDoc && !newDoc) {
    // Delete: all fields removed
    for (const [field, value] of Object.entries(oldDoc)) {
      if (field.startsWith("_")) continue;
      changes.push({ field, oldValue: value });
    }
    return changes;
  }

  if (oldDoc && newDoc) {
    // Update: compare fields
    const allFields = new Set([
      ...Object.keys(oldDoc),
      ...Object.keys(newDoc),
    ]);

    for (const field of allFields) {
      if (field.startsWith("_")) continue;

      const oldVal = oldDoc[field];
      const newVal = newDoc[field];

      // Deep comparison for objects/arrays
      if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
        changes.push({ field, oldValue: oldVal, newValue: newVal });
      }
    }
  }

  return changes;
}

/**
 * Log an audit entry for a mutation.
 * Call this after the mutation succeeds.
 */
export async function logAudit(
  ctx: MutationCtx,
  params: {
    tableName: string;
    documentId: string;
    action: AuditAction;
    oldDoc?: Record<string, unknown>;
    newDoc?: Record<string, unknown>;
    metadata?: AuditMetadata;
  }
): Promise<Id<"auditLogs">> {
  const userId = await getCurrentUserId(ctx);
  const changes = calculateChanges(params.oldDoc, params.newDoc);

  return await ctx.db.insert("auditLogs", {
    userId,
    tableName: params.tableName,
    documentId: params.documentId,
    action: params.action,
    changes: changes.length > 0 ? changes : undefined,
    metadata: params.metadata,
    timestamp: Date.now(),
  });
}

/**
 * Helper to create audit log for document creation.
 */
export async function logCreate(
  ctx: MutationCtx,
  tableName: string,
  documentId: Id<any>,
  newDoc: Record<string, unknown>,
  metadata?: AuditMetadata
): Promise<Id<"auditLogs">> {
  return logAudit(ctx, {
    tableName,
    documentId: documentId as string,
    action: "create",
    newDoc,
    metadata,
  });
}

/**
 * Helper to create audit log for document update.
 */
export async function logUpdate(
  ctx: MutationCtx,
  tableName: string,
  documentId: Id<any>,
  oldDoc: Record<string, unknown>,
  newDoc: Record<string, unknown>,
  metadata?: AuditMetadata
): Promise<Id<"auditLogs">> {
  return logAudit(ctx, {
    tableName,
    documentId: documentId as string,
    action: "update",
    oldDoc,
    newDoc,
    metadata,
  });
}

/**
 * Helper to create audit log for document deletion.
 */
export async function logDelete(
  ctx: MutationCtx,
  tableName: string,
  documentId: Id<any>,
  oldDoc: Record<string, unknown>,
  metadata?: AuditMetadata
): Promise<Id<"auditLogs">> {
  return logAudit(ctx, {
    tableName,
    documentId: documentId as string,
    action: "delete",
    oldDoc,
    metadata,
  });
}
```

Export all functions for use in mutations.
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit in v2/ directory</verify>
  <done>Audit logging library with field-level change detection created</done>
</task>

<task type="auto">
  <name>Task 2: Integrate audit logging into cases mutations</name>
  <files>v2/convex/cases.ts</files>
  <action>
Update cases.ts to log all mutations:

1. Import audit helpers:
```typescript
import { logCreate, logUpdate, logDelete } from "./lib/audit";
```

2. Update create mutation:
```typescript
export const create = mutation({
  // ... existing args ...
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);
    const now = Date.now();

    const newCase = {
      userId,
      ...args,
      // ... defaults ...
      createdAt: now,
      updatedAt: now,
    };

    const id = await ctx.db.insert("cases", newCase);

    // Audit log
    await logCreate(ctx, "cases", id, newCase);

    return id;
  },
});
```

3. Update update mutation:
```typescript
export const update = mutation({
  // ... existing args ...
  handler: async (ctx, args) => {
    const { id, ...updates } = args;
    const oldCase = await ctx.db.get(id);

    await verifyOwnership(ctx, oldCase, "Case");

    if (oldCase!.deletedAt) {
      throw new Error("Cannot update deleted case");
    }

    const newUpdates = {
      ...updates,
      updatedAt: Date.now(),
    };

    await ctx.db.patch(id, newUpdates);

    // Audit log with field-level changes
    const newCase = await ctx.db.get(id);
    await logUpdate(ctx, "cases", id, oldCase as Record<string, unknown>, newCase as Record<string, unknown>);
  },
});
```

4. Update remove mutation (soft delete):
```typescript
export const remove = mutation({
  args: { id: v.id("cases") },
  handler: async (ctx, args) => {
    const oldCase = await ctx.db.get(args.id);

    await verifyOwnership(ctx, oldCase, "Case");

    await ctx.db.patch(args.id, {
      deletedAt: Date.now(),
      updatedAt: Date.now(),
    });

    // Audit log (action: delete for soft delete)
    await logDelete(ctx, "cases", args.id, oldCase as Record<string, unknown>);
  },
});
```

5. Update restore mutation:
```typescript
export const restore = mutation({
  args: { id: v.id("cases") },
  handler: async (ctx, args) => {
    const oldCase = await ctx.db.get(args.id);

    await verifyOwnership(ctx, oldCase, "Case");

    if (!oldCase!.deletedAt) {
      throw new Error("Case is not deleted");
    }

    await ctx.db.patch(args.id, {
      deletedAt: undefined,
      updatedAt: Date.now(),
    });

    const newCase = await ctx.db.get(args.id);
    await logUpdate(ctx, "cases", args.id, oldCase as Record<string, unknown>, newCase as Record<string, unknown>);
  },
});
```
  </action>
  <verify>npx convex dev --once succeeds, mutations log to auditLogs table</verify>
  <done>Cases mutations integrated with audit logging</done>
</task>

<task type="auto">
  <name>Task 3: Create audit log query functions and security tests</name>
  <files>v2/convex/auditLogs.ts, v2/convex/cases.test.ts</files>
  <action>
**Part A: Create auditLogs.ts with query functions:**

```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";
import { getCurrentUserId } from "./lib/auth";

// List audit logs for current user (their own changes)
export const listMine = query({
  args: {
    tableName: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);
    const limit = args.limit ?? 50;

    let q = ctx.db
      .query("auditLogs")
      .withIndex("by_user_id", (q) => q.eq("userId", userId))
      .order("desc"); // Most recent first

    const logs = await q.take(limit);

    // Filter by table name if specified
    if (args.tableName) {
      return logs.filter(log => log.tableName === args.tableName);
    }

    return logs;
  },
});

// Get audit history for a specific document
export const forDocument = query({
  args: {
    documentId: v.string(),
    tableName: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Get all audit logs for this document
    const logs = await ctx.db
      .query("auditLogs")
      .withIndex("by_document_id", (q) => q.eq("documentId", args.documentId))
      .order("desc")
      .collect();

    // Filter to only show logs for user's own documents
    // (Security: don't leak audit info about other users' documents)
    return logs.filter(log => log.userId === userId);
  },
});

// Get audit logs within a date range
export const byDateRange = query({
  args: {
    startDate: v.number(), // Unix timestamp
    endDate: v.number(),
    tableName: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Query by timestamp index, filter by user
    const logs = await ctx.db
      .query("auditLogs")
      .withIndex("by_timestamp")
      .filter((q) =>
        q.and(
          q.gte(q.field("timestamp"), args.startDate),
          q.lte(q.field("timestamp"), args.endDate),
          q.eq(q.field("userId"), userId)
        )
      )
      .order("desc")
      .collect();

    if (args.tableName) {
      return logs.filter(log => log.tableName === args.tableName);
    }

    return logs;
  },
});
```

**Part B: Create security tests in cases.test.ts:**

```typescript
import { describe, it, expect } from "vitest";
import { createTestContext, createAuthenticatedContext } from "../test-utils/convex";

describe("Cases Security", () => {
  describe("Authentication", () => {
    it("should reject unauthenticated list query", async () => {
      const t = createTestContext();
      await expect(
        t.query("cases:list", {})
      ).rejects.toThrow("Unauthorized");
    });

    it("should reject unauthenticated create mutation", async () => {
      const t = createTestContext();
      await expect(
        t.mutation("cases:create", {
          employerName: "Test Corp",
          beneficiaryIdentifier: "John D.",
          positionTitle: "Engineer",
        })
      ).rejects.toThrow("Unauthorized");
    });
  });

  describe("User Isolation", () => {
    it("should not return other user's cases", async () => {
      // User A creates a case
      const userA = createAuthenticatedContext("user-a");
      const caseId = await userA.mutation("cases:create", {
        employerName: "Company A",
        beneficiaryIdentifier: "Person A",
        positionTitle: "Role A",
      });

      // User B should not see User A's case
      const userB = createAuthenticatedContext("user-b");
      const userBCases = await userB.query("cases:list", {});

      expect(userBCases).toHaveLength(0);
    });

    it("should reject access to other user's case by ID", async () => {
      // User A creates a case
      const userA = createAuthenticatedContext("user-a");
      const caseId = await userA.mutation("cases:create", {
        employerName: "Company A",
        beneficiaryIdentifier: "Person A",
        positionTitle: "Role A",
      });

      // User B should not be able to get User A's case
      const userB = createAuthenticatedContext("user-b");
      await expect(
        userB.query("cases:get", { id: caseId })
      ).rejects.toThrow("Access denied");
    });

    it("should reject update on other user's case", async () => {
      const userA = createAuthenticatedContext("user-a");
      const caseId = await userA.mutation("cases:create", {
        employerName: "Company A",
        beneficiaryIdentifier: "Person A",
        positionTitle: "Role A",
      });

      const userB = createAuthenticatedContext("user-b");
      await expect(
        userB.mutation("cases:update", { id: caseId, employerName: "Hacked" })
      ).rejects.toThrow("Access denied");
    });

    it("should reject delete on other user's case", async () => {
      const userA = createAuthenticatedContext("user-a");
      const caseId = await userA.mutation("cases:create", {
        employerName: "Company A",
        beneficiaryIdentifier: "Person A",
        positionTitle: "Role A",
      });

      const userB = createAuthenticatedContext("user-b");
      await expect(
        userB.mutation("cases:remove", { id: caseId })
      ).rejects.toThrow("Access denied");
    });
  });

  describe("Soft Delete", () => {
    it("should exclude soft-deleted cases from list", async () => {
      const user = createAuthenticatedContext("user-1");

      const caseId = await user.mutation("cases:create", {
        employerName: "Test Corp",
        beneficiaryIdentifier: "John D.",
        positionTitle: "Engineer",
      });

      // Delete the case
      await user.mutation("cases:remove", { id: caseId });

      // List should be empty
      const cases = await user.query("cases:list", {});
      expect(cases).toHaveLength(0);
    });

    it("should return null for soft-deleted case by ID", async () => {
      const user = createAuthenticatedContext("user-1");

      const caseId = await user.mutation("cases:create", {
        employerName: "Test Corp",
        beneficiaryIdentifier: "John D.",
        positionTitle: "Engineer",
      });

      await user.mutation("cases:remove", { id: caseId });

      const result = await user.query("cases:get", { id: caseId });
      expect(result).toBeNull();
    });

    it("should restore soft-deleted case", async () => {
      const user = createAuthenticatedContext("user-1");

      const caseId = await user.mutation("cases:create", {
        employerName: "Test Corp",
        beneficiaryIdentifier: "John D.",
        positionTitle: "Engineer",
      });

      await user.mutation("cases:remove", { id: caseId });
      await user.mutation("cases:restore", { id: caseId });

      const cases = await user.query("cases:list", {});
      expect(cases).toHaveLength(1);
    });
  });
});

describe("Audit Logging", () => {
  it("should log case creation", async () => {
    const user = createAuthenticatedContext("user-1");

    await user.mutation("cases:create", {
      employerName: "Test Corp",
      beneficiaryIdentifier: "John D.",
      positionTitle: "Engineer",
    });

    const logs = await user.query("auditLogs:listMine", { tableName: "cases" });
    expect(logs).toHaveLength(1);
    expect(logs[0].action).toBe("create");
    expect(logs[0].tableName).toBe("cases");
  });

  it("should log case update with field changes", async () => {
    const user = createAuthenticatedContext("user-1");

    const caseId = await user.mutation("cases:create", {
      employerName: "Old Name",
      beneficiaryIdentifier: "John D.",
      positionTitle: "Engineer",
    });

    await user.mutation("cases:update", {
      id: caseId,
      employerName: "New Name",
    });

    const logs = await user.query("auditLogs:listMine", { tableName: "cases" });
    const updateLog = logs.find(l => l.action === "update");

    expect(updateLog).toBeDefined();
    expect(updateLog?.changes).toContainEqual(
      expect.objectContaining({
        field: "employerName",
        oldValue: "Old Name",
        newValue: "New Name",
      })
    );
  });

  it("should log case deletion", async () => {
    const user = createAuthenticatedContext("user-1");

    const caseId = await user.mutation("cases:create", {
      employerName: "Test Corp",
      beneficiaryIdentifier: "John D.",
      positionTitle: "Engineer",
    });

    await user.mutation("cases:remove", { id: caseId });

    const logs = await user.query("auditLogs:listMine", { tableName: "cases" });
    const deleteLog = logs.find(l => l.action === "delete");

    expect(deleteLog).toBeDefined();
  });

  it("should not show other user's audit logs", async () => {
    const userA = createAuthenticatedContext("user-a");
    await userA.mutation("cases:create", {
      employerName: "User A Corp",
      beneficiaryIdentifier: "Person A",
      positionTitle: "Role A",
    });

    const userB = createAuthenticatedContext("user-b");
    const userBLogs = await userB.query("auditLogs:listMine", {});

    expect(userBLogs).toHaveLength(0);
  });
});
```

Run tests to verify: `pnpm test` in v2/ directory.
  </action>
  <verify>pnpm test passes all security and audit tests</verify>
  <done>Audit log queries and comprehensive security tests implemented</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] lib/audit.ts exports calculateChanges, logAudit, logCreate, logUpdate, logDelete
- [ ] cases.ts mutations log all changes to auditLogs
- [ ] auditLogs.ts has listMine, forDocument, byDateRange queries
- [ ] All security tests pass (authentication, isolation, soft delete)
- [ ] Audit logging tests pass (create, update, delete, isolation)
- [ ] `npx convex dev --once` succeeds
- [ ] `pnpm test` passes in v2/ directory
</verification>

<success_criteria>
- Audit logging captures field-level changes
- All case mutations are logged
- Audit logs queryable by user (with isolation)
- Security tests verify authentication and isolation
- No cross-user data leakage possible
- Phase 19 complete and ready for Phase 20 (Dashboard)
</success_criteria>

<output>
After completion, create `.planning/phases/19-schema-security/19-04-SUMMARY.md`:

# Phase 19 Plan 04: Audit Logging & Security Tests Summary

**[One-liner describing what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `v2/convex/lib/audit.ts` - Audit logging library
- `v2/convex/cases.ts` - Integrated audit logging
- `v2/convex/auditLogs.ts` - Audit query functions
- `v2/convex/cases.test.ts` - Security and audit tests

## Decisions Made
- [Any decisions about audit granularity, test coverage]

## Issues Encountered
- [Problems and resolutions, or "None"]

## Phase 19 Complete
All 4 plans finished:
- 19-01: Core schema (users, userProfiles, cases)
- 19-02: Supporting schema (notifications, conversations, tokens, audit)
- 19-03: Auth helpers and security patterns
- 19-04: Audit logging and security tests

**Ready for Phase 20: Dashboard + Deadline Hub**
</output>
