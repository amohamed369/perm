---
phase: 19-schema-security
plan: 03
type: execute
---

<objective>
Create authentication helpers and security patterns for Convex queries/mutations.

Purpose: Establish reusable security utilities that enforce user data isolation (RLS equivalent).
Output: Auth helper library, updated user mutations, and secure CRUD patterns for cases.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/V2_CONVEX_SCHEMA.md
@.planning/phases/19-schema-security/19-CONTEXT.md
@.planning/phases/19-schema-security/19-01-SUMMARY.md
@.planning/phases/19-schema-security/19-02-SUMMARY.md
@v2/convex/users.ts

**Prior plan context:**
- 19-01: Core tables (users, userProfiles, cases) defined
- 19-02: Supporting tables defined

**Security requirements from 19-CONTEXT.md:**
- Every query/mutation must call getCurrentUserId(ctx) first
- Filter by userId or verify ownership for all data access
- Soft-deleted records excluded from all queries
- Architecture supports future firm/team access (firm_id ready)

**Current state:**
- users.ts has basic currentUser, currentUserProfile, ensureUserProfile
- Uses getAuthUserId from @convex-dev/auth/server
- No centralized security helpers yet
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth helper library (convex/lib/auth.ts)</name>
  <files>v2/convex/lib/auth.ts</files>
  <action>
Create the security helper library with these functions:

```typescript
import { QueryCtx, MutationCtx } from "../_generated/server";
import { Id } from "../_generated/dataModel";
import { getAuthUserId } from "@convex-dev/auth/server";

/**
 * Get current authenticated user's ID.
 * Throws if not authenticated.
 * Equivalent to v1's get_current_user_id() RLS helper.
 */
export async function getCurrentUserId(
  ctx: QueryCtx | MutationCtx
): Promise<Id<"users">> {
  const userId = await getAuthUserId(ctx);
  if (userId === null) {
    throw new Error("Unauthorized: Not authenticated");
  }
  return userId;
}

/**
 * Get current user's ID, or null if not authenticated.
 * Use for queries that should return null instead of throwing.
 */
export async function getCurrentUserIdOrNull(
  ctx: QueryCtx | MutationCtx
): Promise<Id<"users"> | null> {
  return await getAuthUserId(ctx);
}

/**
 * Get current user's profile.
 * Returns null if not authenticated or profile doesn't exist.
 */
export async function getCurrentUserProfile(ctx: QueryCtx | MutationCtx) {
  const userId = await getAuthUserId(ctx);
  if (userId === null) return null;

  return await ctx.db
    .query("userProfiles")
    .withIndex("by_user_id", (q) => q.eq("userId", userId))
    .filter((q) => q.eq(q.field("deletedAt"), undefined))
    .unique();
}

/**
 * Check if current user is a firm admin.
 * Equivalent to v1's is_firm_admin() RLS helper.
 */
export async function isFirmAdmin(
  ctx: QueryCtx | MutationCtx
): Promise<boolean> {
  const profile = await getCurrentUserProfile(ctx);
  return profile?.userType === "firm_admin";
}

/**
 * Get current user's firm ID.
 * For firm admins, returns their own user ID.
 * For firm members, returns their firm_id.
 * Equivalent to v1's get_current_user_firm_id() RLS helper.
 */
export async function getCurrentUserFirmId(
  ctx: QueryCtx | MutationCtx
): Promise<Id<"users"> | undefined> {
  const userId = await getCurrentUserId(ctx);
  const profile = await getCurrentUserProfile(ctx);

  if (!profile) return undefined;

  // Firm admins: their own ID is the firm ID
  if (profile.userType === "firm_admin") {
    return userId;
  }

  // Firm members: return their firm_id
  return profile.firmId;
}

/**
 * Verify that the current user owns a resource.
 * Throws if resource not found or not owned by current user.
 */
export async function verifyOwnership<T extends { userId: Id<"users"> }>(
  ctx: QueryCtx | MutationCtx,
  resource: T | null,
  resourceName: string = "Resource"
): Promise<void> {
  if (!resource) {
    throw new Error(`${resourceName} not found`);
  }

  const userId = await getCurrentUserId(ctx);
  if (resource.userId !== userId) {
    throw new Error(`Access denied: Not the owner of this ${resourceName.toLowerCase()}`);
  }
}

/**
 * Verify firm-level access (owner OR same firm).
 * Use for resources that can be shared within a firm.
 */
export async function verifyFirmAccess<T extends { userId: Id<"users"> }>(
  ctx: QueryCtx | MutationCtx,
  resource: T | null,
  resourceName: string = "Resource"
): Promise<void> {
  if (!resource) {
    throw new Error(`${resourceName} not found`);
  }

  const userId = await getCurrentUserId(ctx);

  // Direct ownership check
  if (resource.userId === userId) {
    return;
  }

  // Firm access check
  const currentFirmId = await getCurrentUserFirmId(ctx);
  if (!currentFirmId) {
    throw new Error(`Access denied: Not the owner of this ${resourceName.toLowerCase()}`);
  }

  // Get the resource owner's profile to check their firm
  const ownerProfile = await ctx.db
    .query("userProfiles")
    .withIndex("by_user_id", (q) => q.eq("userId", resource.userId))
    .unique();

  const ownerFirmId = ownerProfile?.userType === "firm_admin"
    ? resource.userId
    : ownerProfile?.firmId;

  if (currentFirmId !== ownerFirmId) {
    throw new Error(`Access denied: Not in the same firm`);
  }
}
```

Export all functions for use in queries/mutations.
  </action>
  <verify>TypeScript compiles without errors: npx tsc --noEmit in v2/ directory</verify>
  <done>Auth helper library created with 7 security functions</done>
</task>

<task type="auto">
  <name>Task 2: Update users.ts to use auth helpers</name>
  <files>v2/convex/users.ts</files>
  <action>
Refactor users.ts to use the new auth helper library:

1. Import from lib/auth:
   - getCurrentUserId, getCurrentUserIdOrNull, getCurrentUserProfile

2. Update currentUser query:
   - Use getCurrentUserIdOrNull instead of direct getAuthUserId call

3. Update currentUserProfile query:
   - Use getCurrentUserProfile helper

4. Update ensureUserProfile mutation:
   - Use getCurrentUserId (throws if not auth)
   - Add all default values for the expanded userProfiles schema:
     - userType: "individual"
     - All notification settings: true
     - All calendar sync settings: true
     - Quiet hours: disabled
     - UI prefs: sensible defaults (sort by updatedAt, desc, 10 per page)
     - Privacy: disabled
     - createdAt/updatedAt: Date.now()

5. Add updateUserProfile mutation:
   - Args: partial profile fields to update
   - Use getCurrentUserId
   - Verify profile exists and belongs to user
   - Patch with provided fields + updatedAt

Example structure:
```typescript
import { getCurrentUserId, getCurrentUserIdOrNull, getCurrentUserProfile } from "./lib/auth";

export const currentUser = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getCurrentUserIdOrNull(ctx);
    if (!userId) return null;
    return await ctx.db.get(userId);
  },
});

export const currentUserProfile = query({
  args: {},
  handler: async (ctx) => {
    return await getCurrentUserProfile(ctx);
  },
});
```
  </action>
  <verify>npx convex dev --once succeeds, existing auth flows still work</verify>
  <done>users.ts refactored to use auth helpers with expanded profile defaults</done>
</task>

<task type="auto">
  <name>Task 3: Create secure cases CRUD mutations</name>
  <files>v2/convex/cases.ts</files>
  <action>
Create new cases.ts with secure CRUD operations:

```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { getCurrentUserId, verifyOwnership } from "./lib/auth";

// Query: List user's cases (excluding soft-deleted)
export const list = query({
  args: {
    status: v.optional(v.union(
      v.literal("pwd"),
      v.literal("recruitment"),
      v.literal("eta9089"),
      v.literal("i140"),
      v.literal("closed")
    )),
    favoritesOnly: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    let query = ctx.db
      .query("cases")
      .withIndex("by_user_id", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("deletedAt"), undefined));

    const cases = await query.collect();

    // Apply additional filters in memory (simple approach for now)
    let filtered = cases;
    if (args.status) {
      filtered = filtered.filter(c => c.caseStatus === args.status);
    }
    if (args.favoritesOnly) {
      filtered = filtered.filter(c => c.isFavorite);
    }

    return filtered;
  },
});

// Query: Get single case by ID
export const get = query({
  args: { id: v.id("cases") },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);
    const caseDoc = await ctx.db.get(args.id);

    if (!caseDoc || caseDoc.deletedAt) {
      return null;
    }

    // Verify ownership
    if (caseDoc.userId !== userId) {
      throw new Error("Access denied");
    }

    return caseDoc;
  },
});

// Mutation: Create new case
export const create = mutation({
  args: {
    employerName: v.string(),
    beneficiaryIdentifier: v.string(),
    positionTitle: v.string(),
    // Add other required fields...
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    const now = Date.now();
    return await ctx.db.insert("cases", {
      userId,
      ...args,
      // Defaults
      caseStatus: "pwd",
      progressStatus: "working",
      priorityLevel: "normal",
      isFavorite: false,
      isProfessionalOccupation: false,
      recruitmentApplicantsCount: 0n, // int64
      additionalRecruitmentMethods: [],
      tags: [],
      calendarSyncEnabled: true,
      createdAt: now,
      updatedAt: now,
    });
  },
});

// Mutation: Update case
export const update = mutation({
  args: {
    id: v.id("cases"),
    // Partial fields - add all case fields as optional
    employerName: v.optional(v.string()),
    beneficiaryIdentifier: v.optional(v.string()),
    positionTitle: v.optional(v.string()),
    caseStatus: v.optional(v.union(
      v.literal("pwd"),
      v.literal("recruitment"),
      v.literal("eta9089"),
      v.literal("i140"),
      v.literal("closed")
    )),
    progressStatus: v.optional(v.union(
      v.literal("working"),
      v.literal("waiting_intake"),
      v.literal("filed"),
      v.literal("approved"),
      v.literal("under_review"),
      v.literal("rfi_rfe")
    )),
    isFavorite: v.optional(v.boolean()),
    priorityLevel: v.optional(v.union(
      v.literal("low"),
      v.literal("normal"),
      v.literal("high"),
      v.literal("urgent")
    )),
    // ... add more fields as needed
  },
  handler: async (ctx, args) => {
    const { id, ...updates } = args;
    const caseDoc = await ctx.db.get(id);

    await verifyOwnership(ctx, caseDoc, "Case");

    // Don't allow updating deleted cases
    if (caseDoc!.deletedAt) {
      throw new Error("Cannot update deleted case");
    }

    await ctx.db.patch(id, {
      ...updates,
      updatedAt: Date.now(),
    });
  },
});

// Mutation: Soft delete case
export const remove = mutation({
  args: { id: v.id("cases") },
  handler: async (ctx, args) => {
    const caseDoc = await ctx.db.get(args.id);

    await verifyOwnership(ctx, caseDoc, "Case");

    await ctx.db.patch(args.id, {
      deletedAt: Date.now(),
      updatedAt: Date.now(),
    });
  },
});

// Mutation: Restore soft-deleted case
export const restore = mutation({
  args: { id: v.id("cases") },
  handler: async (ctx, args) => {
    const caseDoc = await ctx.db.get(args.id);

    await verifyOwnership(ctx, caseDoc, "Case");

    if (!caseDoc!.deletedAt) {
      throw new Error("Case is not deleted");
    }

    await ctx.db.patch(args.id, {
      deletedAt: undefined,
      updatedAt: Date.now(),
    });
  },
});
```

Note: Use BigInt (0n) for int64 fields like recruitmentApplicantsCount.
  </action>
  <verify>npx convex dev --once succeeds, cases module deploys without errors</verify>
  <done>Secure cases CRUD with ownership verification implemented</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev --once` succeeds
- [ ] lib/auth.ts exports 7 security helper functions
- [ ] users.ts uses auth helpers
- [ ] ensureUserProfile creates profile with all default fields
- [ ] cases.ts has list, get, create, update, remove, restore
- [ ] All case operations verify ownership before proceeding
- [ ] Soft-deleted records excluded from queries
</verification>

<success_criteria>
- Auth helpers provide consistent security patterns
- All queries/mutations validate authentication
- Ownership verification prevents cross-user data access
- Soft delete pattern implemented correctly
- Code is ready for TDD security tests in Phase 19-04
</success_criteria>

<output>
After completion, create `.planning/phases/19-schema-security/19-03-SUMMARY.md`:

# Phase 19 Plan 03: Auth Helpers & Security Summary

**[One-liner describing what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `v2/convex/lib/auth.ts` - Security helper library
- `v2/convex/users.ts` - Refactored with auth helpers
- `v2/convex/cases.ts` - Secure CRUD operations

## Decisions Made
- [Any security pattern choices]

## Issues Encountered
- [Problems and resolutions, or "None"]

## Next Step
Ready for 19-04-PLAN.md (Audit logging system)
</output>
