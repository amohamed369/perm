---
phase: 24-notifications
plan: 05
type: execute
---

<objective>
Build scheduled functions for deadline reminders and push notification infrastructure.

Purpose: Proactively notify users of upcoming deadlines and enable real-time browser push alerts.
Output: Convex crons for daily deadline checks, push notification service worker and subscription management.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-notifications/24-CONTEXT.md
@.planning/phases/24-notifications/24-RESEARCH.md

**Depends on:** 24-01 (data layer), 24-04 (email actions)

**From RESEARCH.md:**
- Convex crons via cronJobs() in crons.ts
- Use internal functions for cron handlers
- Daily at 9 AM EST (14:00 UTC) for deadline checks
- web-push library for push notifications
- VAPID keys for push encryption

**Existing patterns:**
@v2/convex/deadlineEnforcement.ts - Deadline checking logic
@v2/convex/lib/deadlineEnforcementHelpers.ts - Deadline calculation helpers
</context>

<orchestration>
## CRITICAL: Execution & Subagent Directive

**THIS SECTION MUST PERSIST THROUGH ALL COMPACTIONS. ALL AGENTS AND SUBAGENTS MUST FOLLOW THIS.**

### Mandatory Reading (BEFORE any implementation)
All agents/subagents MUST read and understand these files:
- `.planning/phases/24-notifications/24-CONTEXT.md` - Phase vision, specifics, boundaries
- `.planning/phases/24-notifications/24-RESEARCH.md` - Tech stack, patterns, pitfalls
- `.planning/PROJECT.md` - Overall project context
- `.planning/ROADMAP.md` - Where this phase fits
- `/Users/adammohamed/cc/perm-tracker-test/perm_flow.md` - PERM workflow (SOURCE OF TRUTH)
- `.planning/phases/17-design-system/design*.md` (design-1 through design-5) - UI/design docs for any frontend work
- `.planning/FRONTEND_DESIGN_SKILL.md` - Frontend design patterns

### Execution Pattern (Orchestrator Role)
The executing agent acts as an **orchestrator**:
1. **Explore First**: Spawn Explore subagent(s) to fully understand current implementation and what's needed
2. **Review Findings**: Look over findings yourself if small, delegate if large
3. **Implement**: Spawn Task subagent(s) to implement with explicit instructions
4. **Verify & Review**: Verify implementation, run tests, review quality
5. **Follow Up**: Fix issues, iterate as needed
6. **Repeat**: Until all tasks complete

### Code Quality Standards
For each issue, fully explore to understand:
- Current implementation state
- What's needed to achieve the goal
- **NO clashing, duplicate, or non-seamless implementations**

Implementation rules:
- **Work within existing code** as much as possible
- **Keep it minimal and simple** - DRY and KISS
- **Use what's already built** - leverage existing code, built-ins, standards
- **Create new only when needed** - don't reinvent
- **Refactor as you go** - fix issues, make it easier for future
- **Ensure fixes are global** - don't repeat fixes in multiple places
- **Keep it clean** - organized, minimal, abstractable, scalable, maintainable, readable
- **Ensure all v1 features exist** - no feature regression
- **Follow perm_flow.md** - the source of truth for PERM logic

### JSON Tracking File
Create and maintain: `.planning/phases/24-notifications/tracking.json`
```json
{
  "phase": "24-notifications",
  "plan": "05",
  "lastUpdated": "ISO-timestamp",
  "issues": [
    {
      "id": "05-T1",
      "task": "Create Convex crons configuration",
      "status": "pending|in_progress|complete|blocked",
      "notes": "",
      "blockers": []
    }
  ]
}
```
Update this file throughout execution.

### Subagent Instructions Template
**ALL Task/Explore subagents MUST receive this in their prompt:**

```
CRITICAL INSTRUCTIONS FOR THIS SUBAGENT:

1. READ THESE DOCS FIRST (mandatory):
   - .planning/phases/24-notifications/24-CONTEXT.md
   - .planning/phases/24-notifications/24-RESEARCH.md
   - /Users/adammohamed/cc/perm-tracker-test/perm_flow.md
   - [For UI work: .planning/phases/17-design-system/design*.md (design-1 through design-5)]

2. EXPLORE THOROUGHLY before implementing:
   - Understand the entire v2/ directory structure
   - Understand the .planning/ directory structure
   - Find all related existing implementations
   - Identify patterns already in use

3. IMPLEMENTATION STANDARDS:
   - NO clashing or duplicate implementations
   - Work within existing code when possible
   - Keep minimal, simple, DRY, KISS
   - Use existing patterns and abstractions
   - Ensure seamless integration
   - Refactor as needed to maintain quality
   - Ensure fixes are global, not repeated

4. QUALITY CHECKLIST:
   - Clean, organized code
   - Abstractable and scalable
   - Maintainable and readable
   - All v1 features preserved
   - Follows perm_flow.md

5. CLEANUP: Remove any temporary files, unused code, or debug artifacts
```

### Cleanup Protocol
After each task completion:
- Remove temporary files
- Delete unused code
- Clean up debug artifacts
- Verify no leftover test data
- Update tracking.json

### Verification
Before marking any task complete:
- All tests pass
- No TypeScript errors
- No console errors
- Feature works as specified
- No regression in existing features

### CRITICAL: Commit Workflow (AFTER PLAN COMPLETE)
**This workflow is MANDATORY after completing ALL tasks in this plan:**

1. **STAGE** - Stage all changes: `git add -A`
2. **CODE REVIEW** - Run code reviewer agent:
   ```
   Task(subagent_type="pr-review-toolkit:code-reviewer", prompt="Review staged changes for quality, bugs, and adherence to project standards")
   ```
3. **FIX** - Address ALL issues found by code reviewer
4. **RE-REVIEW** - If significant fixes made, run code reviewer again
5. **COMMIT** - Create commit with conventional commit message:
   ```
   git commit -m "feat(notifications): <plan description>"
   ```

**DO NOT skip this workflow. The plan is NOT complete until code review passes and changes are committed.**
</orchestration>

<tasks>

<task type="auto">
  <name>Task 1: Create Convex crons configuration</name>
  <files>v2/convex/crons.ts</files>
  <exploration>
    Read Convex crons documentation pattern from RESEARCH.md.
    Check if any crons.ts file already exists in v2/convex/.
  </exploration>
  <action>
Create Convex scheduled jobs:

```typescript
// v2/convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Daily deadline reminder check at 9 AM EST (14:00 UTC)
crons.daily(
  "deadline-reminders",
  { hourUTC: 14, minuteUTC: 0 },
  internal.scheduledJobs.checkDeadlineReminders
);

// Hourly cleanup of old read notifications (older than 90 days)
crons.hourly(
  "notification-cleanup",
  { minuteUTC: 30 },
  internal.scheduledJobs.cleanupOldNotifications
);

// Weekly digest email (Mondays at 9 AM EST)
crons.weekly(
  "weekly-digest",
  { dayOfWeek: "monday", hourUTC: 14, minuteUTC: 0 },
  internal.scheduledJobs.sendWeeklyDigest
);

export default crons;
```

This creates three scheduled jobs:
1. Daily deadline reminders at 9 AM EST
2. Hourly cleanup of old notifications
3. Weekly digest (optional - can be enabled in Phase 25 settings)

The crons file must be exported as default for Convex to register.
  </action>
  <verify>npx convex dev shows crons registered in dashboard</verify>
  <done>Crons configuration with 3 scheduled jobs</done>
</task>

<task type="auto">
  <name>Task 2: Create deadline reminder scheduled job</name>
  <files>v2/convex/scheduledJobs.ts</files>
  <action>
Create the deadline reminder check logic:

```typescript
// v2/convex/scheduledJobs.ts
import { internalAction, internalQuery, internalMutation } from "./_generated/server";
import { internal } from "./_generated/api";
import { v } from "convex/values";

// Query: Get all cases with upcoming deadlines
export const getCasesNeedingReminders = internalQuery({
  args: {},
  handler: async (ctx) => {
    // Get all active cases
    const cases = await ctx.db
      .query("cases")
      .filter((q) => q.neq(q.field("status"), "closed"))
      .collect();

    const today = new Date();
    const reminderIntervals = [1, 3, 7, 14, 30]; // days before deadline

    const remindersNeeded = [];

    for (const caseDoc of cases) {
      // Check each deadline type
      const deadlines = [
        { type: "pwd_expiration", date: caseDoc.pwd_expiration_date },
        { type: "recruitment_end", date: caseDoc.recruitment_end_date },
        { type: "eta9089_filing_window", date: caseDoc.eta9089_filing_window_closes },
        { type: "i140_deadline", date: caseDoc.i140_filing_deadline },
        // RFI/RFE deadlines from related table
      ];

      for (const deadline of deadlines) {
        if (!deadline.date) continue;

        const deadlineDate = new Date(deadline.date);
        const daysUntil = Math.ceil((deadlineDate - today) / (1000 * 60 * 60 * 24));

        // Check if we should send reminder at this interval
        if (reminderIntervals.includes(daysUntil)) {
          // Check if we already sent this reminder
          const existing = await ctx.db
            .query("notifications")
            .withIndex("by_case_id", (q) => q.eq("caseId", caseDoc._id))
            .filter((q) =>
              q.and(
                q.eq(q.field("deadlineType"), deadline.type),
                q.eq(q.field("daysUntilDeadline"), daysUntil)
              )
            )
            .first();

          if (!existing) {
            remindersNeeded.push({
              caseId: caseDoc._id,
              userId: caseDoc.userId,
              deadlineType: deadline.type,
              deadlineDate: deadline.date,
              daysUntil,
              employerName: caseDoc.employer_name,
              beneficiaryName: caseDoc.beneficiary_last_name,
            });
          }
        }
      }
    }

    return remindersNeeded;
  },
});

// Action: Process all reminders
export const checkDeadlineReminders = internalAction({
  args: {},
  handler: async (ctx) => {
    const reminders = await ctx.runQuery(internal.scheduledJobs.getCasesNeedingReminders);

    console.log(`Processing ${reminders.length} deadline reminders`);

    for (const reminder of reminders) {
      // Create notification
      const notificationId = await ctx.runMutation(internal.notifications.createNotification, {
        userId: reminder.userId,
        caseId: reminder.caseId,
        type: "deadline_reminder",
        title: `${formatDeadlineType(reminder.deadlineType)} in ${reminder.daysUntil} days`,
        message: `${reminder.employerName} - ${reminder.beneficiaryName}`,
        priority: calculatePriority(reminder.daysUntil, "deadline_reminder"),
        deadlineDate: reminder.deadlineDate,
        deadlineType: reminder.deadlineType,
        daysUntilDeadline: reminder.daysUntil,
      });

      // Get user preferences and send email if enabled
      const userProfile = await ctx.runQuery(internal.userProfiles.getById, {
        userId: reminder.userId,
      });

      if (userProfile?.emailDeadlineReminders) {
        await ctx.scheduler.runAfter(0, internal.notificationActions.sendDeadlineReminderEmail, {
          to: userProfile.email,
          ...reminder,
          notificationId,
        });
      }

      // Send push if enabled
      if (userProfile?.pushNotificationsEnabled && userProfile?.pushSubscription) {
        await ctx.scheduler.runAfter(0, internal.scheduledJobs.sendPushNotification, {
          userId: reminder.userId,
          title: `${formatDeadlineType(reminder.deadlineType)} Reminder`,
          body: `Due in ${reminder.daysUntil} days: ${reminder.employerName}`,
          url: `/cases/${reminder.caseId}`,
        });
      }
    }
  },
});
```

Import helpers from notificationHelpers.ts.
  </action>
  <verify>npx convex dev deploys, cron appears in Convex dashboard</verify>
  <done>Deadline reminder cron job with email and push triggers</done>
</task>

<task type="auto">
  <name>Task 3: Create cleanup and digest scheduled jobs</name>
  <files>v2/convex/scheduledJobs.ts</files>
  <action>
Add cleanup and digest jobs:

**Cleanup job:**
```typescript
export const cleanupOldNotifications = internalAction({
  args: {},
  handler: async (ctx) => {
    const ninetyDaysAgo = Date.now() - (90 * 24 * 60 * 60 * 1000);

    // Get old read notifications
    const oldNotifications = await ctx.runQuery(internal.scheduledJobs.getOldReadNotifications, {
      olderThan: ninetyDaysAgo,
    });

    console.log(`Cleaning up ${oldNotifications.length} old notifications`);

    // Delete in batches
    for (const notification of oldNotifications) {
      await ctx.runMutation(internal.notifications.deleteNotificationInternal, {
        notificationId: notification._id,
      });
    }
  },
});

export const getOldReadNotifications = internalQuery({
  args: { olderThan: v.number() },
  handler: async (ctx, { olderThan }) => {
    return await ctx.db
      .query("notifications")
      .filter((q) =>
        q.and(
          q.eq(q.field("isRead"), true),
          q.lt(q.field("createdAt"), olderThan)
        )
      )
      .take(100); // Batch size
  },
});
```

**Weekly digest job (skeleton for Phase 25):**
```typescript
export const sendWeeklyDigest = internalAction({
  args: {},
  handler: async (ctx) => {
    // Get users with weekly digest enabled
    const users = await ctx.runQuery(internal.scheduledJobs.getUsersWithDigestEnabled);

    for (const user of users) {
      // Get upcoming deadlines for next 7 days
      const upcomingDeadlines = await ctx.runQuery(internal.scheduledJobs.getUpcomingDeadlinesForUser, {
        userId: user._id,
        daysAhead: 7,
      });

      if (upcomingDeadlines.length > 0) {
        // TODO: Create digest email template in Phase 25
        console.log(`Would send digest to ${user.email} with ${upcomingDeadlines.length} deadlines`);
      }
    }
  },
});
```

The digest job is a placeholder - full implementation in Phase 25 when settings UI is built.
  </action>
  <verify>Cleanup job runs, old notifications removed</verify>
  <done>Cleanup and digest scheduled jobs created</done>
</task>

<task type="auto">
  <name>Task 4: Install web-push and set up VAPID keys</name>
  <files>v2/package.json, v2/.env.local.example</files>
  <action>
Install web-push and configure VAPID:

```bash
cd v2 && npm install web-push
```

**Generate VAPID keys (one-time):**
```bash
npx web-push generate-vapid-keys
```

This outputs:
- Public Key: Store in NEXT_PUBLIC_VAPID_PUBLIC_KEY
- Private Key: Store in VAPID_PRIVATE_KEY (server only)

**Update .env.local.example:**
```env
# Push Notifications (VAPID)
NEXT_PUBLIC_VAPID_PUBLIC_KEY=your-public-key
VAPID_PRIVATE_KEY=your-private-key
```

**Add to schema (if not exists) - pushSubscription field in users or userProfiles:**
```typescript
// In userProfiles schema, add:
pushSubscription: v.optional(v.string()), // JSON stringified PushSubscription
```
  </action>
  <verify>web-push installed, VAPID keys documented</verify>
  <done>web-push installed, VAPID configuration documented</done>
</task>

<task type="auto">
  <name>Task 5: Create push notification service worker</name>
  <files>v2/public/sw-push.js, v2/src/lib/pushSubscription.ts</files>
  <action>
Create push notification handling:

**Service Worker (v2/public/sw-push.js):**
```javascript
// Push event handler
self.addEventListener("push", function (event) {
  if (!event.data) return;

  const data = event.data.json();

  const options = {
    body: data.body,
    icon: "/icon-192.png",
    badge: "/badge-72.png",
    tag: data.tag || "perm-tracker",
    data: { url: data.url },
    vibrate: [100, 50, 100],
    actions: [
      { action: "view", title: "View Case" },
      { action: "dismiss", title: "Dismiss" },
    ],
  };

  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});

// Notification click handler
self.addEventListener("notificationclick", function (event) {
  event.notification.close();

  if (event.action === "dismiss") return;

  const url = event.notification.data?.url || "/dashboard";

  event.waitUntil(
    clients.matchAll({ type: "window" }).then((clientList) => {
      // Focus existing tab if open
      for (const client of clientList) {
        if (client.url.includes(url) && "focus" in client) {
          return client.focus();
        }
      }
      // Open new tab
      if (clients.openWindow) {
        return clients.openWindow(url);
      }
    })
  );
});
```

**Client subscription helper (v2/src/lib/pushSubscription.ts):**
```typescript
import { useMutation } from "convex/react";
import { api } from "../../convex/_generated/api";

export function urlBase64ToUint8Array(base64String: string) {
  const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

export async function subscribeToPush() {
  if (!("serviceWorker" in navigator) || !("PushManager" in window)) {
    throw new Error("Push notifications not supported");
  }

  // Register service worker
  const registration = await navigator.serviceWorker.register("/sw-push.js");
  await navigator.serviceWorker.ready;

  // Request permission
  const permission = await Notification.requestPermission();
  if (permission !== "granted") {
    throw new Error("Push notification permission denied");
  }

  // Subscribe
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(
      process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!
    ),
  });

  return JSON.stringify(subscription);
}

export async function unsubscribeFromPush() {
  const registration = await navigator.serviceWorker.ready;
  const subscription = await registration.pushManager.getSubscription();
  if (subscription) {
    await subscription.unsubscribe();
  }
}
```
  </action>
  <verify>Service worker registers, subscription flow works</verify>
  <done>Push notification service worker and client helpers created</done>
</task>

<task type="auto">
  <name>Task 6: Create push sending action</name>
  <files>v2/convex/scheduledJobs.ts</files>
  <action>
Add push notification sending action:

```typescript
import webpush from "web-push";

// Configure VAPID (do this once at module level)
webpush.setVapidDetails(
  "mailto:support@permtracker.app",
  process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,
  process.env.VAPID_PRIVATE_KEY!
);

export const sendPushNotification = internalAction({
  args: {
    userId: v.id("users"),
    title: v.string(),
    body: v.string(),
    url: v.optional(v.string()),
    tag: v.optional(v.string()),
  },
  handler: async (ctx, { userId, title, body, url, tag }) => {
    // Get user's push subscription
    const userProfile = await ctx.runQuery(internal.userProfiles.getById, { userId });

    if (!userProfile?.pushSubscription) {
      console.log(`No push subscription for user ${userId}`);
      return;
    }

    const payload = JSON.stringify({
      title,
      body,
      url: url || "/dashboard",
      tag: tag || "perm-tracker",
    });

    try {
      await webpush.sendNotification(
        JSON.parse(userProfile.pushSubscription),
        payload
      );
      console.log(`Push sent to user ${userId}`);
    } catch (error: any) {
      // Handle expired/invalid subscriptions
      if (error.statusCode === 410 || error.statusCode === 404) {
        console.log(`Push subscription expired for user ${userId}, removing`);
        await ctx.runMutation(internal.userProfiles.removePushSubscription, { userId });
      } else {
        console.error("Push notification failed:", error);
      }
    }
  },
});
```

Also add mutation to save/remove push subscriptions:
```typescript
// In userProfiles.ts
export const savePushSubscription = mutation({
  args: { subscription: v.string() },
  handler: async (ctx, { subscription }) => {
    const userId = await getCurrentUserId(ctx);
    await ctx.db.patch(userId, {
      pushSubscription: subscription,
      pushNotificationsEnabled: true,
    });
  },
});

export const removePushSubscription = internalMutation({
  args: { userId: v.id("users") },
  handler: async (ctx, { userId }) => {
    await ctx.db.patch(userId, {
      pushSubscription: undefined,
      pushNotificationsEnabled: false,
    });
  },
});
```
  </action>
  <verify>Push action deploys, handles subscription errors gracefully</verify>
  <done>Push sending action with subscription cleanup</done>
</task>

<task type="auto">
  <name>Task 7: Write scheduled job tests</name>
  <files>v2/convex/scheduledJobs.test.ts</files>
  <action>
Create tests for scheduled jobs:

**Deadline reminder tests:**
- getCasesNeedingReminders finds cases at reminder intervals
- getCasesNeedingReminders excludes already-notified cases
- getCasesNeedingReminders excludes closed cases
- checkDeadlineReminders creates notifications
- checkDeadlineReminders sends emails when enabled
- checkDeadlineReminders skips email when disabled

**Cleanup tests:**
- getOldReadNotifications returns notifications older than threshold
- cleanupOldNotifications removes old read notifications
- cleanupOldNotifications keeps unread notifications

**Push tests:**
- sendPushNotification handles missing subscription
- sendPushNotification handles expired subscription (410)
- sendPushNotification removes expired subscription from DB

Use mocks for web-push library.
  </action>
  <verify>npm test -- scheduledJobs passes</verify>
  <done>Scheduled job tests written</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] crons.ts registered with 3 scheduled jobs
- [ ] Deadline reminder job creates notifications and sends emails
- [ ] Cleanup job removes old read notifications
- [ ] web-push installed, VAPID documented
- [ ] Service worker handles push events
- [ ] Push sending action with error handling
- [ ] Tests pass
</verification>

<success_criteria>
- Crons appear in Convex dashboard
- Daily deadline reminders work
- Push notifications can be subscribed/sent
- Old notifications are cleaned up
- Error handling for expired subscriptions
- Tests verify scheduled job logic
</success_criteria>

<output>
After completion, create `.planning/phases/24-notifications/24-05-SUMMARY.md`:

# Phase 24 Plan 05: Scheduled Functions + Push Summary

**[One-liner describing what shipped]**

## Accomplishments
- Convex crons for deadline reminders, cleanup, digest
- Push notification infrastructure (VAPID, service worker)
- Push sending with subscription management

## Files Created/Modified
- `v2/convex/crons.ts` - Scheduled job definitions
- `v2/convex/scheduledJobs.ts` - Job implementations
- `v2/public/sw-push.js` - Push service worker
- `v2/src/lib/pushSubscription.ts` - Client subscription helpers
- `v2/convex/userProfiles.ts` - Subscription mutations
- `v2/.env.local.example` - VAPID key documentation

## Decisions Made
[Any decisions during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Phase 24 complete, ready for Phase 24.1 (API Documentation) or Phase 25 (Settings)
</output>
