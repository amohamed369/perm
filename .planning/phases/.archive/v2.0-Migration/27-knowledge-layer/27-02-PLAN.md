---
phase: 27-knowledge-layer
plan: 02
type: execute
domain: web-search
---

<objective>
Implement multi-provider web search with rate limit tracking and fallback chain.

Purpose: Enable the chatbot to search the web for current PERM regulations, DOL guidance, and regulatory updates. Essential for answering questions about recent changes or specific CFR references.

Output:
- Web search action with Tavily primary, Brave fallback
- Rate limit tracking per provider per day
- Graceful degradation to knowledge-only mode
- Tests for search and fallback logic
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-knowledge-layer/27-RESEARCH.md
@.planning/phases/27-knowledge-layer/27-CONTEXT.md
@.planning/phases/27-knowledge-layer/27-01-SUMMARY.md

**Prior decisions affecting this phase:**
- All free-tier only (Tavily 1000/month, Brave 2000/month)
- Multi-provider fallback pattern from Phase 26 chat API

**From 27-RESEARCH.md:**
- Tavily: AI-optimized results, includes answer generation
- Brave: Broader coverage, good fallback
- Track daily usage to avoid hitting limits
- Return empty gracefully (use knowledge base only)

**Free tier limits:**
- Tavily: 1000/month ≈ 33/day
- Brave: 2000/month ≈ 66/day
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add API usage tracking schema and functions</name>
  <files>v2/convex/schema.ts, v2/convex/apiUsage.ts</files>
  <exploration>
    Check v2/convex/schema.ts for existing table patterns.
    Understand index conventions used in the project.
  </exploration>
  <action>
    1. Add apiUsage table to schema.ts:
       ```typescript
       apiUsage: defineTable({
         provider: v.string(),  // "tavily" | "brave"
         date: v.string(),      // YYYY-MM-DD
         count: v.number(),
       }).index("by_provider_date", ["provider", "date"])
       ```

    2. Create convex/apiUsage.ts with:
       - trackUsage internalMutation: Increment counter for provider+date
         - Upserts: creates if not exists, increments if exists
       - getUsage query: Get today's count for a provider
         - Returns 0 if no record exists
       - getDailyLimits query: Return configured limits (for display)
         - Tavily: 30/day (safe margin from 33)
         - Brave: 60/day (safe margin from 66)

    3. Make sure date uses ISO format (YYYY-MM-DD) for consistency

    AVOID: Don't expose trackUsage externally - internal only for security.
  </action>
  <verify>
    - `pnpm convex dev` runs and deploys schema
    - apiUsage table appears in Convex dashboard
    - No TypeScript errors
  </verify>
  <done>API usage tracking schema and functions ready</done>
</task>

<task type="auto">
  <name>Task 2: Create web search action with multi-provider fallback</name>
  <files>v2/convex/webSearch.ts, v2/.env.example</files>
  <action>
    1. Add to .env.example:
       - TAVILY_API_KEY=your-tavily-api-key
       - BRAVE_API_KEY=your-brave-api-key

    2. Create convex/webSearch.ts with searchWeb action:
       ```typescript
       export const searchWeb = action({
         args: { query: v.string() },
         handler: async (ctx, { query }) => {
           // Check Tavily quota first
           const tavilyUsage = await ctx.runQuery(internal.apiUsage.getUsageInternal, {
             provider: "tavily"
           });

           if (tavilyUsage < 30) {
             try {
               const result = await tavilySearch(query);
               await ctx.runMutation(internal.apiUsage.trackUsage, { provider: "tavily" });
               return result;
             } catch (e) {
               console.error("Tavily failed:", e);
             }
           }

           // Fallback to Brave
           const braveUsage = await ctx.runQuery(internal.apiUsage.getUsageInternal, {
             provider: "brave"
           });

           if (braveUsage < 60) {
             try {
               const result = await braveSearch(query);
               await ctx.runMutation(internal.apiUsage.trackUsage, { provider: "brave" });
               return result;
             } catch (e) {
               console.error("Brave failed:", e);
             }
           }

           // Graceful fallback - no web results
           return { source: "none", results: [], answer: null };
         },
       });
       ```

    3. Implement tavilySearch helper:
       - POST to https://api.tavily.com/search
       - search_depth: "basic" (faster, conserves quota)
       - include_answer: true (AI-generated summary)
       - max_results: 5
       - Return { source: "tavily", answer, results: [{title, url, content}] }

    4. Implement braveSearch helper:
       - GET to https://api.search.brave.com/res/v1/web/search
       - count: 5
       - Return { source: "brave", answer: null, results: [{title, url, content}] }

    5. Handle API errors gracefully - log and continue to next provider

    AVOID: Don't make web search a query (it has side effects - usage tracking).
  </action>
  <verify>
    - TypeScript compiles without errors
    - Action appears in Convex dashboard
    - Environment variables documented in .env.example
  </verify>
  <done>Web search action with fallback chain implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for web search and usage tracking</name>
  <files>v2/convex/__tests__/webSearch.test.ts, v2/convex/__tests__/apiUsage.test.ts</files>
  <action>
    1. Create convex/__tests__/apiUsage.test.ts:
       - Test trackUsage creates new record
       - Test trackUsage increments existing record
       - Test getUsage returns 0 for new provider/date
       - Test getUsage returns correct count
       - Test getDailyLimits returns configured values

    2. Create convex/__tests__/webSearch.test.ts:
       - Test searchWeb returns results structure
       - Test searchWeb respects rate limits (mock usage at limit)
       - Test fallback from Tavily to Brave (mock Tavily at limit)
       - Test graceful empty return when both at limit
       - Mock fetch calls to avoid actual API requests

    3. Use Vitest mocking for:
       - fetch() calls to search APIs
       - ctx.runQuery and ctx.runMutation

    AVOID: Don't make actual API calls in tests - mock everything.
  </action>
  <verify>
    - `pnpm test convex/__tests__/apiUsage.test.ts` passes
    - `pnpm test convex/__tests__/webSearch.test.ts` passes
    - All tests use mocks, no real API calls
  </verify>
  <done>Web search and usage tracking fully tested</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] apiUsage table in schema, deployed
- [ ] searchWeb action works with Tavily and Brave
- [ ] Rate limiting tracks daily usage per provider
- [ ] Graceful fallback to empty results when quota exhausted
- [ ] All tests pass
- [ ] Environment variables documented
</verification>

<success_criteria>
- Web search action with multi-provider fallback working
- Rate limit tracking prevents quota exhaustion
- Graceful degradation to knowledge-only mode
- All tests passing
- Ready for integration with chat API
</success_criteria>

<output>
After completion, create `.planning/phases/27-knowledge-layer/27-02-SUMMARY.md`:

# Phase 27 Plan 02: Web Search Summary

**[One-liner describing what shipped]**

## Accomplishments
- Multi-provider web search (Tavily → Brave)
- Daily rate limit tracking
- Graceful fallback to knowledge-only

## Files Created/Modified
- `v2/convex/schema.ts` - apiUsage table
- `v2/convex/apiUsage.ts` - Usage tracking functions
- `v2/convex/webSearch.ts` - Web search action
- `v2/.env.example` - API key documentation

## Decisions Made
[Any decisions made during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 27-03-PLAN.md (Case Data Access + Intent Detection)
</output>
