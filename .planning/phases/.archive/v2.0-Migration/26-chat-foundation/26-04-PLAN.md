# 26-04: Integration & Polish

## Objective

Connect all components together with the persistence hook, add history access, integrate into authenticated layout, and polish the experience with proper animations and mobile support.

## Execution Context

```yaml
references:
  - .planning/phases/26-chat-foundation/26-CONTEXT.md
  - .planning/phases/26-chat-foundation/26-RESEARCH.md
  - .planning/FRONTEND_DESIGN_SKILL.md
  - v2/docs/ANIMATION_STORYBOARD.md

patterns:
  - v2/src/hooks/useFormCalculations.ts  # Custom hook pattern
  - v2/src/app/(authenticated)/layout.tsx  # Layout integration
  - v2/src/components/notifications/NotificationDropdown.tsx  # Dropdown pattern
```

## Context

### What We're Building
- `useChatWithPersistence` - Hook combining AI SDK + Convex persistence
- `ChatHistory` - Slide-out panel for conversation list
- Layout integration - Add widget to authenticated layout
- Mobile responsiveness - Full-screen on mobile
- Polish - Loading states, error handling, reduced motion

### Key Integration Points
- AI SDK `useChat` hook for streaming
- Convex mutations for persistence
- Real-time subscription for conversation list
- Theme support (dark/light mode)

## Tasks

### Task 1: Create useChatWithPersistence Hook

**File:** `v2/src/hooks/useChatWithPersistence.ts`

```typescript
/**
 * useChatWithPersistence Hook
 *
 * Combines AI SDK streaming with Convex persistence.
 *
 * Features:
 * - Real-time streaming via AI SDK
 * - Automatic message persistence to Convex
 * - Conversation creation/selection
 * - Status tracking (ready, submitted, streaming, error)
 */

'use client';

import { useState, useCallback, useMemo, useEffect } from 'react';
import { useChat as useAIChat } from '@ai-sdk/react';
import { DefaultChatTransport } from 'ai';
import { useMutation, useQuery } from 'convex/react';
import { api } from '../../convex/_generated/api';
import type { Id } from '../../convex/_generated/dataModel';

interface UseChatWithPersistenceOptions {
  conversationId?: Id<'conversations'>;
  onConversationCreated?: (id: Id<'conversations'>) => void;
}

export function useChatWithPersistence(options: UseChatWithPersistenceOptions = {}) {
  const [conversationId, setConversationId] = useState<Id<'conversations'> | null>(
    options.conversationId ?? null
  );
  const [input, setInput] = useState('');

  // Convex mutations
  const createConversation = useMutation(api.conversations.create);
  const createUserMessage = useMutation(api.conversationMessages.createUserMessage);
  const createAssistantMessage = useMutation(api.conversationMessages.createAssistantMessage);

  // Convex queries
  const conversation = useQuery(
    api.conversations.get,
    conversationId ? { id: conversationId } : 'skip'
  );
  const persistedMessages = useQuery(
    api.conversationMessages.list,
    conversationId ? { conversationId } : 'skip'
  );

  // AI SDK chat hook
  const {
    messages: streamingMessages,
    sendMessage,
    status,
    error,
    reload,
    stop,
  } = useAIChat({
    id: conversationId ?? undefined,
    transport: new DefaultChatTransport({ api: '/api/chat' }),
    onFinish: async ({ message }) => {
      if (!conversationId) return;

      // Extract text content from message parts
      const content = message.parts
        .filter((p): p is { type: 'text'; text: string } => p.type === 'text')
        .map((p) => p.text)
        .join('');

      // Persist assistant message to Convex
      await createAssistantMessage({
        conversationId,
        content,
        metadata: {
          processingTimeMs: Date.now() - (streamStartTime.current ?? Date.now()),
        },
      });
    },
    onError: (err) => {
      console.error('[Chat] AI SDK error:', err);
    },
  });

  // Track streaming start time for processing duration
  const streamStartTime = { current: null as number | null };

  // Convert persisted messages to display format
  const displayMessages = useMemo(() => {
    if (!persistedMessages) return [];

    return persistedMessages.map((m) => ({
      id: m._id,
      role: m.role as 'user' | 'assistant',
      content: m.content,
      timestamp: m.createdAt,
    }));
  }, [persistedMessages]);

  // Get streaming content for in-progress message
  const streamingContent = useMemo(() => {
    if (status !== 'streaming') return undefined;

    const lastMessage = streamingMessages[streamingMessages.length - 1];
    if (!lastMessage || lastMessage.role !== 'assistant') return undefined;

    return lastMessage.parts
      .filter((p): p is { type: 'text'; text: string } => p.type === 'text')
      .map((p) => p.text)
      .join('');
  }, [streamingMessages, status]);

  // Create new conversation
  const startNewConversation = useCallback(async () => {
    const id = await createConversation({});
    setConversationId(id);
    options.onConversationCreated?.(id);
    return id;
  }, [createConversation, options]);

  // Select existing conversation
  const selectConversation = useCallback((id: Id<'conversations'>) => {
    setConversationId(id);
  }, []);

  // Send message
  const handleSend = useCallback(async () => {
    if (!input.trim()) return;

    // Create conversation if needed
    let activeConversationId = conversationId;
    if (!activeConversationId) {
      activeConversationId = await startNewConversation();
    }

    // Save user message to Convex first
    await createUserMessage({
      conversationId: activeConversationId,
      content: input.trim(),
    });

    // Track timing
    streamStartTime.current = Date.now();

    // Send to AI
    sendMessage({ text: input.trim() });
    setInput('');
  }, [input, conversationId, startNewConversation, createUserMessage, sendMessage]);

  return {
    // State
    conversationId,
    conversation,
    messages: displayMessages,
    input,
    status,
    error,
    streamingContent,

    // Actions
    setInput,
    handleSend,
    startNewConversation,
    selectConversation,
    reload,
    stop,
  };
}
```

### Task 2: Create ChatHistory Component

**File:** `v2/src/components/chat/ChatHistory.tsx`

```tsx
/**
 * ChatHistory Component
 *
 * Slide-out panel showing conversation list.
 * Allows switching between conversations and creating new ones.
 */

'use client';

import { motion, AnimatePresence } from 'motion/react';
import { useQuery, useMutation } from 'convex/react';
import { api } from '../../../convex/_generated/api';
import { Button } from '@/components/ui/button';
import { X, Plus, MessageSquare, Archive, Trash2 } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
import { springConfig } from '@/lib/animations';
import { cn } from '@/lib/utils';
import type { Id } from '../../../convex/_generated/dataModel';

interface ChatHistoryProps {
  isOpen: boolean;
  onClose: () => void;
  currentConversationId: Id<'conversations'> | null;
  onSelectConversation: (id: Id<'conversations'>) => void;
  onNewConversation: () => void;
}

export function ChatHistory({
  isOpen,
  onClose,
  currentConversationId,
  onSelectConversation,
  onNewConversation,
}: ChatHistoryProps) {
  const conversations = useQuery(api.conversations.list, {});
  const archiveConversation = useMutation(api.conversations.archive);
  const deleteConversation = useMutation(api.conversations.deleteConversation);

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black/20 z-40"
            onClick={onClose}
          />

          {/* Panel */}
          <motion.div
            initial={{ x: '100%' }}
            animate={{ x: 0 }}
            exit={{ x: '100%' }}
            transition={springConfig}
            className={cn(
              'fixed right-0 top-0 bottom-0 z-50',
              'w-80 max-w-[85vw]',
              'bg-background border-l-2 border-border shadow-hard-lg',
              'flex flex-col'
            )}
          >
            {/* Header */}
            <div className="flex items-center justify-between p-4 border-b-2 border-border">
              <h2 className="font-heading font-semibold">Chat History</h2>
              <Button
                variant="ghost"
                size="icon"
                onClick={onClose}
                aria-label="Close history"
              >
                <X className="h-4 w-4" />
              </Button>
            </div>

            {/* New Conversation Button */}
            <div className="p-4 border-b-2 border-border">
              <Button
                onClick={() => {
                  onNewConversation();
                  onClose();
                }}
                className="w-full shadow-hard-sm"
              >
                <Plus className="h-4 w-4 mr-2" />
                New Conversation
              </Button>
            </div>

            {/* Conversation List */}
            <div className="flex-1 overflow-y-auto p-4 space-y-2">
              {!conversations || conversations.length === 0 ? (
                <div className="text-center text-muted-foreground py-8">
                  <MessageSquare className="h-8 w-8 mx-auto mb-2 opacity-30" />
                  <p className="text-sm">No conversations yet</p>
                </div>
              ) : (
                conversations.map((conv) => (
                  <div
                    key={conv._id}
                    className={cn(
                      'group relative p-3 border-2 cursor-pointer',
                      'transition-all duration-150',
                      conv._id === currentConversationId
                        ? 'border-primary bg-primary/5'
                        : 'border-border hover:border-primary/50 hover:bg-muted/50'
                    )}
                    onClick={() => {
                      onSelectConversation(conv._id);
                      onClose();
                    }}
                  >
                    <div className="pr-16">
                      <p className="font-medium text-sm truncate">
                        {conv.title}
                      </p>
                      <p className="text-xs text-muted-foreground mt-1">
                        {formatDistanceToNow(conv.updatedAt, { addSuffix: true })}
                      </p>
                    </div>

                    {/* Actions */}
                    <div className="absolute right-2 top-1/2 -translate-y-1/2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-7 w-7"
                        onClick={(e) => {
                          e.stopPropagation();
                          archiveConversation({ id: conv._id });
                        }}
                        aria-label="Archive conversation"
                      >
                        <Archive className="h-3.5 w-3.5" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-7 w-7 text-destructive hover:text-destructive"
                        onClick={(e) => {
                          e.stopPropagation();
                          if (confirm('Delete this conversation permanently?')) {
                            deleteConversation({ id: conv._id });
                          }
                        }}
                        aria-label="Delete conversation"
                      >
                        <Trash2 className="h-3.5 w-3.5" />
                      </Button>
                    </div>
                  </div>
                ))
              )}
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  );
}
```

### Task 3: Create Connected ChatWidget

**File:** `v2/src/components/chat/ChatWidgetConnected.tsx`

```tsx
/**
 * ChatWidgetConnected Component
 *
 * Fully connected chat widget with:
 * - AI SDK streaming
 * - Convex persistence
 * - History access
 * - Mobile responsiveness
 */

'use client';

import { useState } from 'react';
import { useQuery } from 'convex/react';
import { api } from '../../../convex/_generated/api';
import { ChatWidget } from './ChatWidget';
import { ChatHistory } from './ChatHistory';
import { useChatWithPersistence } from '@/hooks/useChatWithPersistence';

export function ChatWidgetConnected() {
  const [isHistoryOpen, setIsHistoryOpen] = useState(false);

  // Get most recent conversation to resume
  const recentConversation = useQuery(api.conversationMessages.getMostRecent, {});

  const {
    conversationId,
    messages,
    input,
    status,
    error,
    streamingContent,
    setInput,
    handleSend,
    startNewConversation,
    selectConversation,
  } = useChatWithPersistence({
    conversationId: recentConversation?._id,
  });

  return (
    <>
      <ChatWidget
        messages={messages}
        input={input}
        onInputChange={setInput}
        onSend={handleSend}
        status={status}
        streamingContent={streamingContent}
        onOpenHistory={() => setIsHistoryOpen(true)}
      />

      <ChatHistory
        isOpen={isHistoryOpen}
        onClose={() => setIsHistoryOpen(false)}
        currentConversationId={conversationId}
        onSelectConversation={selectConversation}
        onNewConversation={startNewConversation}
      />
    </>
  );
}
```

### Task 4: Update ChatPanel with History Button

**Update:** `v2/src/components/chat/ChatPanel.tsx`

Add history button to header:

```tsx
// In header section, after the title:
<div className="flex items-center gap-1">
  <Button
    variant="ghost"
    size="icon"
    onClick={onOpenHistory}
    className="h-8 w-8"
    aria-label="View history"
  >
    <History className="h-4 w-4" />
  </Button>
  <Button
    variant="ghost"
    size="icon"
    onClick={onClose}
    className="h-8 w-8"
    aria-label="Close chat"
  >
    <X className="h-4 w-4" />
  </Button>
</div>
```

Add `onOpenHistory` prop to ChatPanel and ChatWidget interfaces.

### Task 5: Update ChatWidget Props

**Update:** `v2/src/components/chat/ChatWidget.tsx`

Add history button callback:

```tsx
interface ChatWidgetProps {
  // ... existing props
  onOpenHistory?: () => void;
}

// Pass to ChatPanel
<ChatPanel
  // ... existing props
  onOpenHistory={onOpenHistory}
/>
```

### Task 6: Add Mobile Responsiveness

**Update:** `v2/src/components/chat/ChatPanel.tsx`

```tsx
// Update className for responsive sizing
className={cn(
  'fixed z-40',
  // Mobile: full screen
  'inset-0 md:inset-auto',
  // Desktop: positioned bottom-right
  'md:bottom-20 md:right-4',
  'md:w-[380px] md:h-[560px] md:max-h-[80vh]',
  'flex flex-col',
  'bg-background border-2 border-border shadow-hard-lg',
  'overflow-hidden'
)}
```

### Task 7: Integrate into Authenticated Layout

**Update:** `v2/src/app/(authenticated)/layout.tsx`

```tsx
import { ChatWidgetConnected } from '@/components/chat/ChatWidgetConnected';

// Inside the layout, before closing </div>:
<ChatWidgetConnected />
```

### Task 8: Export Hook from Hooks Index

**Update:** `v2/src/hooks/index.ts`

```typescript
export { useChatWithPersistence } from './useChatWithPersistence';
```

### Task 9: Update Component Index

**Update:** `v2/src/components/chat/index.ts`

```typescript
export { ChatWidget } from './ChatWidget';
export { ChatWidgetConnected } from './ChatWidgetConnected';
export { ChatPanel } from './ChatPanel';
export { ChatMessage } from './ChatMessage';
export { ChatInput } from './ChatInput';
export { ChatHistory } from './ChatHistory';
export { TypingIndicator } from './TypingIndicator';
```

### Task 10: Write Integration Tests

**File:** `v2/src/hooks/__tests__/useChatWithPersistence.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';

// Mock dependencies
vi.mock('@ai-sdk/react', () => ({
  useChat: vi.fn(() => ({
    messages: [],
    sendMessage: vi.fn(),
    status: 'ready',
    error: null,
    reload: vi.fn(),
    stop: vi.fn(),
  })),
}));

vi.mock('convex/react', () => ({
  useMutation: vi.fn(() => vi.fn()),
  useQuery: vi.fn(() => null),
}));

describe('useChatWithPersistence', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('initializes with empty state', async () => {
    const { useChatWithPersistence } = await import('../useChatWithPersistence');

    const { result } = renderHook(() => useChatWithPersistence());

    expect(result.current.conversationId).toBeNull();
    expect(result.current.messages).toEqual([]);
    expect(result.current.input).toBe('');
    expect(result.current.status).toBe('ready');
  });

  it('updates input value', async () => {
    const { useChatWithPersistence } = await import('../useChatWithPersistence');

    const { result } = renderHook(() => useChatWithPersistence());

    act(() => {
      result.current.setInput('Hello');
    });

    expect(result.current.input).toBe('Hello');
  });

  it('exposes required actions', async () => {
    const { useChatWithPersistence } = await import('../useChatWithPersistence');

    const { result } = renderHook(() => useChatWithPersistence());

    expect(typeof result.current.handleSend).toBe('function');
    expect(typeof result.current.startNewConversation).toBe('function');
    expect(typeof result.current.selectConversation).toBe('function');
    expect(typeof result.current.reload).toBe('function');
    expect(typeof result.current.stop).toBe('function');
  });
});
```

## Verification

```bash
# 1. TypeScript compiles
pnpm build

# 2. Run all tests
pnpm test src/components/chat/__tests__
pnpm test src/hooks/__tests__/useChatWithPersistence.test.ts
pnpm test convex/__tests__/conversations.test.ts
pnpm test convex/__tests__/conversationMessages.test.ts

# 3. Manual verification (with dev servers running)
# - Navigate to authenticated page (dashboard)
# - Verify chat bubble appears in bottom-right
# - Click bubble to open panel
# - Type message and send
# - Verify streaming response appears
# - Verify message persists after page reload
# - Test history panel (click history icon)
# - Test mobile responsiveness (resize window)
```

## Success Criteria

- [ ] `useChatWithPersistence` hook works with AI SDK and Convex
- [ ] Messages stream in real-time
- [ ] Messages persist to Convex after completion
- [ ] History panel shows conversation list
- [ ] Can switch between conversations
- [ ] Can create new conversations
- [ ] Widget appears in authenticated layout only
- [ ] Mobile responsive (full-screen on small screens)
- [ ] All tests pass

## Output

```
v2/src/
├── hooks/
│   ├── useChatWithPersistence.ts    # Main persistence hook
│   ├── __tests__/
│   │   └── useChatWithPersistence.test.ts
│   └── index.ts                      # Updated exports
├── components/chat/
│   ├── ChatWidgetConnected.tsx       # Fully connected widget
│   ├── ChatHistory.tsx               # History slide-out panel
│   └── index.ts                      # Updated exports
└── app/(authenticated)/
    └── layout.tsx                    # Updated with ChatWidgetConnected
```

## Notes

- Widget only renders for authenticated users (layout integration)
- First message auto-creates conversation if none selected
- History uses real-time Convex subscription
- Mobile uses full-screen panel for better UX
- Error states handled gracefully with retry option

---

**Phase 26 Complete!**

After this plan, Phase 26 (Chat Foundation) is complete:
- ✅ 26-01: AI Infrastructure (providers, fallback, API route)
- ✅ 26-02: Convex Layer (conversations, messages CRUD)
- ✅ 26-03: Chat UI Core (widget, panel, input, messages)
- ✅ 26-04: Integration & Polish (history, persistence, layout)

**Next Phase:** Phase 27 (Knowledge Layer) - PERM knowledge, website how-tos, case data access
