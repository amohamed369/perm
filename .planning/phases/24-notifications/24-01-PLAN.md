---
phase: 24-notifications
plan: 01
type: execute
---

<objective>
Build the notification data layer with queries, mutations, and helper functions.

Purpose: Establish the foundation for all notification operations - CRUD, counting, filtering, and business logic helpers.
Output: Complete Convex functions for notifications with comprehensive tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-notifications/24-CONTEXT.md
@.planning/phases/24-notifications/24-RESEARCH.md

**Existing schema (already defined):**
@v2/convex/schema.ts - notifications table lines 413-459

**Existing patterns:**
@v2/convex/deadlineEnforcement.ts - auto_closure notification creation
@v2/convex/lib/deadlineEnforcementHelpers.ts - title/message generation

**Prior decisions:**
- Notification types: deadline_reminder, status_change, rfe_alert, rfi_alert, system, auto_closure
- Priority levels: low, normal, high, urgent
- Email tracking via emailSent/emailSentAt fields
- Indexes: by_user_id, by_user_and_unread, by_case_id, by_deadline_date
</context>

<orchestration>
## CRITICAL: Execution & Subagent Directive

**THIS SECTION MUST PERSIST THROUGH ALL COMPACTIONS. ALL AGENTS AND SUBAGENTS MUST FOLLOW THIS.**

### Mandatory Reading (BEFORE any implementation)
All agents/subagents MUST read and understand these files:
- `.planning/phases/24-notifications/24-CONTEXT.md` - Phase vision, specifics, boundaries
- `.planning/phases/24-notifications/24-RESEARCH.md` - Tech stack, patterns, pitfalls
- `.planning/PROJECT.md` - Overall project context
- `.planning/ROADMAP.md` - Where this phase fits
- `/Users/adammohamed/cc/perm-tracker-test/perm_flow.md` - PERM workflow (SOURCE OF TRUTH)
- `.planning/phases/17-design-system/design*.md` (design-1 through design-5) - UI/design docs for any frontend work
- `.planning/FRONTEND_DESIGN_SKILL.md` - Frontend design patterns

### Execution Pattern (Orchestrator Role)
The executing agent acts as an **orchestrator**:
1. **Explore First**: Spawn Explore subagent(s) to fully understand current implementation and what's needed
2. **Review Findings**: Look over findings yourself if small, delegate if large
3. **Implement**: Spawn Task subagent(s) to implement with explicit instructions
4. **Verify & Review**: Verify implementation, run tests, review quality
5. **Follow Up**: Fix issues, iterate as needed
6. **Repeat**: Until all tasks complete

### Code Quality Standards
For each issue, fully explore to understand:
- Current implementation state
- What's needed to achieve the goal
- **NO clashing, duplicate, or non-seamless implementations**

Implementation rules:
- **Work within existing code** as much as possible
- **Keep it minimal and simple** - DRY and KISS
- **Use what's already built** - leverage existing code, built-ins, standards
- **Create new only when needed** - don't reinvent
- **Refactor as you go** - fix issues, make it easier for future
- **Ensure fixes are global** - don't repeat fixes in multiple places
- **Keep it clean** - organized, minimal, abstractable, scalable, maintainable, readable
- **Ensure all v1 features exist** - no feature regression
- **Follow perm_flow.md** - the source of truth for PERM logic

### JSON Tracking File
Create and maintain: `.planning/phases/24-notifications/tracking.json`
```json
{
  "phase": "24-notifications",
  "plan": "01",
  "lastUpdated": "ISO-timestamp",
  "issues": [
    {
      "id": "01-T1",
      "task": "Create notification query functions",
      "status": "pending|in_progress|complete|blocked",
      "notes": "",
      "blockers": []
    }
  ]
}
```
Update this file throughout execution.

### Subagent Instructions Template
**ALL Task/Explore subagents MUST receive this in their prompt:**

```
CRITICAL INSTRUCTIONS FOR THIS SUBAGENT:

1. READ THESE DOCS FIRST (mandatory):
   - .planning/phases/24-notifications/24-CONTEXT.md
   - .planning/phases/24-notifications/24-RESEARCH.md
   - /Users/adammohamed/cc/perm-tracker-test/perm_flow.md
   - [For UI work: .planning/phases/17-design-system/design*.md]

2. EXPLORE THOROUGHLY before implementing:
   - Understand the entire v2/ directory structure
   - Understand the .planning/ directory structure
   - Find all related existing implementations
   - Identify patterns already in use

3. IMPLEMENTATION STANDARDS:
   - NO clashing or duplicate implementations
   - Work within existing code when possible
   - Keep minimal, simple, DRY, KISS
   - Use existing patterns and abstractions
   - Ensure seamless integration
   - Refactor as needed to maintain quality
   - Ensure fixes are global, not repeated

4. QUALITY CHECKLIST:
   - Clean, organized code
   - Abstractable and scalable
   - Maintainable and readable
   - All v1 features preserved
   - Follows perm_flow.md

5. CLEANUP: Remove any temporary files, unused code, or debug artifacts
```

### Cleanup Protocol
After each task completion:
- Remove temporary files
- Delete unused code
- Clean up debug artifacts
- Verify no leftover test data
- Update tracking.json

### Verification
Before marking any task complete:
- All tests pass
- No TypeScript errors
- No console errors
- Feature works as specified
- No regression in existing features

### CRITICAL: Commit Workflow (AFTER PLAN COMPLETE)
**This workflow is MANDATORY after completing ALL tasks in this plan:**

1. **STAGE** - Stage all changes: `git add -A`
2. **CODE REVIEW** - Run code reviewer agent:
   ```
   Task(subagent_type="pr-review-toolkit:code-reviewer", prompt="Review staged changes for quality, bugs, and adherence to project standards")
   ```
3. **FIX** - Address ALL issues found by code reviewer
4. **RE-REVIEW** - If significant fixes made, run code reviewer again
5. **COMMIT** - Create commit with conventional commit message:
   ```
   git commit -m "feat(notifications): <plan description>"
   ```

**DO NOT skip this workflow. The plan is NOT complete until code review passes and changes are committed.**
</orchestration>

<tasks>

<task type="auto">
  <name>Task 1: Create notification query functions</name>
  <files>v2/convex/notifications.ts</files>
  <exploration>
    Use Explore agent to find existing query patterns in v2/convex/ (cases.ts, userProfiles.ts).
    Identify pagination patterns and auth guard usage.
  </exploration>
  <action>
Create notification query functions:

1. `getUnreadCount` - Returns count of unread notifications for current user
   - Use by_user_and_unread index
   - Return number (cap display at 99+)

2. `getRecentNotifications` - Get most recent N notifications
   - Args: limit (default 5)
   - Order by createdAt desc
   - Include case details via join if caseId exists

3. `getNotifications` - Paginated list with filters
   - Args: cursor, limit (default 20), filters (type, isRead, caseId)
   - Return { notifications, nextCursor, hasMore }
   - Support filtering by type array

4. `getNotificationsByCase` - All notifications for a specific case
   - Args: caseId
   - Use by_case_id index
   - For case detail page integration

5. `getNotificationStats` - Dashboard stats
   - Return { total, unread, byType: { deadline_reminder: N, ... } }
   - For chatbot integration

All queries must:
- Check auth via getCurrentUserId helper
- Only return user's own notifications
- Handle empty results gracefully
  </action>
  <verify>npx convex dev runs without errors, queries appear in generated API</verify>
  <done>5 query functions exported, type-safe, auth-guarded</done>
</task>

<task type="auto">
  <name>Task 2: Create notification mutation functions</name>
  <files>v2/convex/notifications.ts</files>
  <action>
Add mutation functions to notifications.ts:

1. `markAsRead` - Mark single notification as read
   - Args: notificationId
   - Set isRead: true, readAt: Date.now()
   - Verify ownership before updating

2. `markAllAsRead` - Mark all user's notifications as read
   - No args (uses auth)
   - Batch update with ctx.db.patch
   - Return count of updated

3. `markMultipleAsRead` - Mark specific notifications as read
   - Args: notificationIds array
   - Verify all belong to user
   - Return count of updated

4. `deleteNotification` - Soft delete single notification
   - Args: notificationId
   - Actually delete from DB (notifications don't need soft delete)
   - Verify ownership

5. `deleteAllRead` - Delete all read notifications
   - No args (uses auth)
   - Only delete where isRead: true
   - Return count of deleted

6. `createNotification` - Internal mutation for creating notifications
   - Args: all notification fields except userId (from auth)
   - Set defaults: isRead: false, emailSent: false, timestamps
   - Return notification ID

7. `cleanupCaseNotifications` - Delete all notifications for a case
   - Args: caseId
   - Called when case is deleted
   - Internal function (internalMutation)

All mutations must verify ownership before modifying.
  </action>
  <verify>npx convex dev runs, mutations appear in generated API</verify>
  <done>7 mutation functions exported, ownership verified, type-safe</done>
</task>

<task type="auto">
  <name>Task 3: Create notification helper functions</name>
  <files>v2/convex/lib/notificationHelpers.ts</files>
  <action>
Create pure helper functions for notification logic:

1. `generateNotificationTitle(type, context)` - Generate title based on type
   - deadline_reminder: "PWD Expiration in 7 days" / "I-140 Filing Deadline Tomorrow"
   - status_change: "Case Status Updated to ETA 9089"
   - rfi_alert: "RFI Response Due in 14 days"
   - rfe_alert: "RFE Response Due Soon"
   - auto_closure: Use existing helper pattern from deadlineEnforcementHelpers.ts

2. `generateNotificationMessage(type, context)` - Generate message body
   - Include case identifier (employer + beneficiary)
   - Include relevant dates
   - Include action suggestion

3. `calculatePriority(daysUntil, type)` - Determine priority level
   - urgent: overdue or ≤7 days
   - high: 8-14 days
   - normal: 15-30 days
   - low: 30+ days
   - RFI/RFE always at least "high"

4. `getNotificationIcon(type)` - Return icon name for UI
   - deadline_reminder: "clock"
   - status_change: "arrow-right"
   - rfi_alert: "alert-circle"
   - rfe_alert: "alert-triangle"
   - auto_closure: "x-circle"
   - system: "info"

5. `formatDeadlineType(deadlineType)` - Human-readable deadline names
   - pwd_expiration → "PWD Expiration"
   - eta9089_filing_window → "ETA 9089 Filing Window"
   - i140_deadline → "I-140 Filing Deadline"
   - rfi_due → "RFI Response Due"
   - rfe_due → "RFE Response Due"

6. `shouldSendEmail(notification, userPrefs)` - Check if email should be sent
   - Check emailNotificationsEnabled
   - Check type-specific preferences (emailDeadlineReminders, etc.)
   - Check quiet hours if enabled
   - Return boolean

Export all functions with TypeScript types.
  </action>
  <verify>tsc --noEmit passes, functions importable from convex code</verify>
  <done>6 helper functions with full type coverage</done>
</task>

<task type="auto">
  <name>Task 4: Write comprehensive tests</name>
  <files>v2/convex/notifications.test.ts</files>
  <exploration>
    Use Explore agent to find existing test patterns in v2/convex/*.test.ts.
    Identify test utilities and mock patterns used.
  </exploration>
  <action>
Create comprehensive tests for notification functions:

**Query tests:**
- getUnreadCount returns correct count
- getUnreadCount returns 0 for new user
- getRecentNotifications respects limit
- getRecentNotifications orders by createdAt desc
- getNotifications pagination works correctly
- getNotifications filters by type
- getNotifications filters by isRead
- getNotificationsByCase returns only case notifications
- getNotificationStats returns correct breakdown

**Mutation tests:**
- markAsRead updates isRead and readAt
- markAsRead fails for non-owned notification
- markAllAsRead updates all user notifications
- markMultipleAsRead handles mixed ownership (only updates owned)
- deleteNotification removes notification
- deleteNotification fails for non-owned
- deleteAllRead only removes read notifications
- createNotification sets defaults correctly
- cleanupCaseNotifications removes all case notifications

**Helper tests:**
- generateNotificationTitle for each type
- generateNotificationMessage includes case info
- calculatePriority thresholds are correct
- calculatePriority RFI/RFE minimum is high
- shouldSendEmail respects user preferences
- shouldSendEmail respects quiet hours
- formatDeadlineType covers all deadline types

Use existing test utilities from v2/test-utils/.
  </action>
  <verify>npm test -- notifications passes all tests</verify>
  <done>35+ tests covering queries, mutations, helpers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx convex dev` runs without errors
- [ ] All 5 queries exported and type-safe
- [ ] All 7 mutations exported and ownership-verified
- [ ] All 6 helpers exported with types
- [ ] `npm test -- notifications` passes all tests
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All notification CRUD operations working
- Queries respect auth and ownership
- Helpers generate correct content for all types
- 35+ tests passing
- Ready for UI integration (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/24-notifications/24-01-SUMMARY.md`:

# Phase 24 Plan 01: Data Layer & Core Functions Summary

**[One-liner describing what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `v2/convex/notifications.ts` - Queries and mutations
- `v2/convex/lib/notificationHelpers.ts` - Pure helper functions
- `v2/convex/notifications.test.ts` - Comprehensive tests

## Decisions Made
[Any decisions during implementation]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 24-02-PLAN.md (Bell + Dropdown UI)
</output>
