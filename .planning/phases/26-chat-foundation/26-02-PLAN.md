# 26-02: Convex Conversations Layer

## Objective

Implement Convex CRUD operations for conversations and messages, enabling persistent chat history with real-time subscriptions. This provides the data layer for the chat UI.

## Execution Context

```yaml
references:
  - .planning/phases/26-chat-foundation/26-CONTEXT.md
  - .planning/phases/26-chat-foundation/26-RESEARCH.md
  - v2/convex/schema.ts  # Schema already defined (lines 493-577)
  - v2/CLAUDE.md

patterns:
  - v2/convex/cases.ts      # CRUD pattern reference
  - v2/convex/notifications.ts  # Query patterns
  - v2/convex/lib/auth.ts   # Auth helper pattern
```

## Context

### What We're Building
- Conversation CRUD (create, list, archive, delete)
- Message CRUD (create, list by conversation)
- Real-time subscriptions for message updates
- Auto-title generation for new conversations

### Schema Already Exists (from exploration)
```typescript
// convex/schema.ts already has:
conversations {
  userId, title, isArchived, metadata, createdAt, updatedAt
}
conversationMessages {
  conversationId, role, content, toolCalls, metadata, createdAt
}
```

### Key Design Decisions
- User isolation via `getCurrentUserId()` (RLS pattern)
- Messages ordered by `createdAt` (ascending for chat view)
- Conversations ordered by `updatedAt` (descending for recency)
- Soft-delete for conversations (isArchived = true)
- Internal mutation for AI message creation (not exposed to client)

## Tasks

### Task 1: Create Conversations Module

**File:** `v2/convex/conversations.ts`

```typescript
/**
 * Conversation CRUD Operations
 *
 * Handles conversation lifecycle:
 * - Create new conversation
 * - List user's conversations
 * - Archive/restore conversations
 * - Delete conversations
 * - Update conversation title
 */

import { v } from 'convex/values';
import { mutation, query } from './_generated/server';
import { getCurrentUserId } from './lib/auth';

/**
 * Create a new conversation
 */
export const create = mutation({
  args: {
    title: v.optional(v.string()),
    metadata: v.optional(
      v.object({
        relatedCaseId: v.optional(v.id('cases')),
        conversationType: v.optional(
          v.union(
            v.literal('general'),
            v.literal('case_inquiry'),
            v.literal('deadline_help'),
            v.literal('document_help')
          )
        ),
      })
    ),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    const conversationId = await ctx.db.insert('conversations', {
      userId,
      title: args.title ?? 'New Conversation',
      isArchived: false,
      metadata: args.metadata
        ? {
            relatedCaseId: args.metadata.relatedCaseId,
            conversationType: args.metadata.conversationType ?? 'general',
            lastActiveAt: Date.now(),
            tags: [],
          }
        : {
            conversationType: 'general',
            lastActiveAt: Date.now(),
            tags: [],
          },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });

    return conversationId;
  },
});

/**
 * Get a single conversation by ID
 */
export const get = query({
  args: { id: v.id('conversations') },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);
    const conversation = await ctx.db.get(args.id);

    // Verify ownership
    if (!conversation || conversation.userId !== userId) {
      return null;
    }

    return conversation;
  },
});

/**
 * List all conversations for the current user
 * Sorted by updatedAt (most recent first)
 */
export const list = query({
  args: {
    includeArchived: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    if (args.includeArchived) {
      // All conversations
      const conversations = await ctx.db
        .query('conversations')
        .withIndex('by_user_id', (q) => q.eq('userId', userId))
        .collect();

      return conversations.sort((a, b) => b.updatedAt - a.updatedAt);
    }

    // Only active conversations
    const conversations = await ctx.db
      .query('conversations')
      .withIndex('by_user_and_archived', (q) =>
        q.eq('userId', userId).eq('isArchived', false)
      )
      .collect();

    return conversations.sort((a, b) => b.updatedAt - a.updatedAt);
  },
});

/**
 * Update conversation title
 */
export const updateTitle = mutation({
  args: {
    id: v.id('conversations'),
    title: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);
    const conversation = await ctx.db.get(args.id);

    if (!conversation || conversation.userId !== userId) {
      throw new Error('Conversation not found');
    }

    await ctx.db.patch(args.id, {
      title: args.title,
      updatedAt: Date.now(),
    });
  },
});

/**
 * Archive a conversation (soft delete)
 */
export const archive = mutation({
  args: { id: v.id('conversations') },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);
    const conversation = await ctx.db.get(args.id);

    if (!conversation || conversation.userId !== userId) {
      throw new Error('Conversation not found');
    }

    await ctx.db.patch(args.id, {
      isArchived: true,
      updatedAt: Date.now(),
    });
  },
});

/**
 * Restore an archived conversation
 */
export const restore = mutation({
  args: { id: v.id('conversations') },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);
    const conversation = await ctx.db.get(args.id);

    if (!conversation || conversation.userId !== userId) {
      throw new Error('Conversation not found');
    }

    await ctx.db.patch(args.id, {
      isArchived: false,
      updatedAt: Date.now(),
    });
  },
});

/**
 * Permanently delete a conversation and all its messages
 */
export const deleteConversation = mutation({
  args: { id: v.id('conversations') },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);
    const conversation = await ctx.db.get(args.id);

    if (!conversation || conversation.userId !== userId) {
      throw new Error('Conversation not found');
    }

    // Delete all messages in conversation
    const messages = await ctx.db
      .query('conversationMessages')
      .withIndex('by_conversation_id', (q) => q.eq('conversationId', args.id))
      .collect();

    for (const message of messages) {
      await ctx.db.delete(message._id);
    }

    // Delete conversation
    await ctx.db.delete(args.id);
  },
});
```

### Task 2: Create Conversation Messages Module

**File:** `v2/convex/conversationMessages.ts`

```typescript
/**
 * Conversation Message CRUD Operations
 *
 * Handles message operations:
 * - Create user message
 * - Create assistant message (internal)
 * - List messages for conversation
 * - Get message count
 */

import { v } from 'convex/values';
import { mutation, query, internalMutation } from './_generated/server';
import { getCurrentUserId } from './lib/auth';

/**
 * Create a user message
 */
export const createUserMessage = mutation({
  args: {
    conversationId: v.id('conversations'),
    content: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Verify conversation ownership
    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation || conversation.userId !== userId) {
      throw new Error('Conversation not found');
    }

    // Create user message
    const messageId = await ctx.db.insert('conversationMessages', {
      conversationId: args.conversationId,
      role: 'user',
      content: args.content,
      createdAt: Date.now(),
    });

    // Update conversation's lastActiveAt
    await ctx.db.patch(args.conversationId, {
      updatedAt: Date.now(),
      metadata: {
        ...conversation.metadata,
        lastActiveAt: Date.now(),
      },
    });

    return messageId;
  },
});

/**
 * Create an assistant message
 * Can be called from client after streaming completes
 */
export const createAssistantMessage = mutation({
  args: {
    conversationId: v.id('conversations'),
    content: v.string(),
    metadata: v.optional(
      v.object({
        model: v.optional(v.string()),
        processingTimeMs: v.optional(v.number()),
        tokenCount: v.optional(v.number()),
      })
    ),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Verify conversation ownership
    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation || conversation.userId !== userId) {
      throw new Error('Conversation not found');
    }

    // Create assistant message
    const messageId = await ctx.db.insert('conversationMessages', {
      conversationId: args.conversationId,
      role: 'assistant',
      content: args.content,
      metadata: args.metadata,
      createdAt: Date.now(),
    });

    // Update conversation updatedAt
    await ctx.db.patch(args.conversationId, {
      updatedAt: Date.now(),
    });

    // Auto-generate title if this is the second message (first AI response)
    const messageCount = await ctx.db
      .query('conversationMessages')
      .withIndex('by_conversation_id', (q) =>
        q.eq('conversationId', args.conversationId)
      )
      .collect();

    if (messageCount.length === 2 && conversation.title === 'New Conversation') {
      // Generate title from first user message (truncate to 50 chars)
      const firstMessage = messageCount.find((m) => m.role === 'user');
      if (firstMessage) {
        const title =
          firstMessage.content.length > 50
            ? firstMessage.content.substring(0, 47) + '...'
            : firstMessage.content;
        await ctx.db.patch(args.conversationId, { title });
      }
    }

    return messageId;
  },
});

/**
 * List all messages for a conversation
 * Sorted by createdAt (oldest first - natural chat order)
 */
export const list = query({
  args: {
    conversationId: v.id('conversations'),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Verify conversation ownership
    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation || conversation.userId !== userId) {
      return [];
    }

    const messages = await ctx.db
      .query('conversationMessages')
      .withIndex('by_conversation_id', (q) =>
        q.eq('conversationId', args.conversationId)
      )
      .collect();

    // Sort by createdAt ascending (oldest first)
    return messages.sort((a, b) => a.createdAt - b.createdAt);
  },
});

/**
 * Get message count for a conversation
 */
export const count = query({
  args: {
    conversationId: v.id('conversations'),
  },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Verify conversation ownership
    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation || conversation.userId !== userId) {
      return 0;
    }

    const messages = await ctx.db
      .query('conversationMessages')
      .withIndex('by_conversation_id', (q) =>
        q.eq('conversationId', args.conversationId)
      )
      .collect();

    return messages.length;
  },
});

/**
 * Get the most recent conversation for quick resume
 * Returns the conversation with the most recent message
 */
export const getMostRecent = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getCurrentUserId(ctx);

    // Get active conversations
    const conversations = await ctx.db
      .query('conversations')
      .withIndex('by_user_and_archived', (q) =>
        q.eq('userId', userId).eq('isArchived', false)
      )
      .collect();

    if (conversations.length === 0) {
      return null;
    }

    // Sort by updatedAt descending and return first
    conversations.sort((a, b) => b.updatedAt - a.updatedAt);
    return conversations[0];
  },
});
```

### Task 3: Write Conversation Tests

**File:** `v2/convex/__tests__/conversations.test.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { convexTest } from 'convex-test';
import { api } from '../_generated/api';
import schema from '../schema';
import { Id } from '../_generated/dataModel';

describe('conversations', () => {
  let t: ReturnType<typeof convexTest>;
  let userId: Id<'users'>;
  let asUser: ReturnType<typeof t.withIdentity>;

  beforeEach(async () => {
    t = convexTest(schema);
    userId = await t.run(async (ctx) => {
      return await ctx.db.insert('users', { email: 'test@example.com' });
    });
    asUser = t.withIdentity({ subject: userId });
  });

  describe('create', () => {
    it('creates a new conversation', async () => {
      const id = await asUser.mutation(api.conversations.create, {});
      expect(id).toBeDefined();

      const conversation = await asUser.query(api.conversations.get, { id });
      expect(conversation).toBeDefined();
      expect(conversation?.title).toBe('New Conversation');
      expect(conversation?.isArchived).toBe(false);
    });

    it('creates with custom title', async () => {
      const id = await asUser.mutation(api.conversations.create, {
        title: 'My Chat',
      });
      const conversation = await asUser.query(api.conversations.get, { id });
      expect(conversation?.title).toBe('My Chat');
    });

    it('creates with metadata', async () => {
      const id = await asUser.mutation(api.conversations.create, {
        metadata: { conversationType: 'deadline_help' },
      });
      const conversation = await asUser.query(api.conversations.get, { id });
      expect(conversation?.metadata?.conversationType).toBe('deadline_help');
    });
  });

  describe('list', () => {
    it('lists active conversations', async () => {
      await asUser.mutation(api.conversations.create, { title: 'Chat 1' });
      await asUser.mutation(api.conversations.create, { title: 'Chat 2' });

      const conversations = await asUser.query(api.conversations.list, {});
      expect(conversations.length).toBe(2);
    });

    it('excludes archived by default', async () => {
      const id = await asUser.mutation(api.conversations.create, {});
      await asUser.mutation(api.conversations.archive, { id });

      const conversations = await asUser.query(api.conversations.list, {});
      expect(conversations.length).toBe(0);
    });

    it('includes archived when requested', async () => {
      const id = await asUser.mutation(api.conversations.create, {});
      await asUser.mutation(api.conversations.archive, { id });

      const conversations = await asUser.query(api.conversations.list, {
        includeArchived: true,
      });
      expect(conversations.length).toBe(1);
    });

    it('isolates by user', async () => {
      // Create conversation as first user
      await asUser.mutation(api.conversations.create, {});

      // Create second user
      const otherUserId = await t.run(async (ctx) => {
        return await ctx.db.insert('users', { email: 'other@example.com' });
      });
      const asOther = t.withIdentity({ subject: otherUserId });

      // Other user should not see first user's conversations
      const conversations = await asOther.query(api.conversations.list, {});
      expect(conversations.length).toBe(0);
    });
  });

  describe('archive and restore', () => {
    it('archives a conversation', async () => {
      const id = await asUser.mutation(api.conversations.create, {});
      await asUser.mutation(api.conversations.archive, { id });

      const conversation = await asUser.query(api.conversations.get, { id });
      expect(conversation?.isArchived).toBe(true);
    });

    it('restores an archived conversation', async () => {
      const id = await asUser.mutation(api.conversations.create, {});
      await asUser.mutation(api.conversations.archive, { id });
      await asUser.mutation(api.conversations.restore, { id });

      const conversation = await asUser.query(api.conversations.get, { id });
      expect(conversation?.isArchived).toBe(false);
    });
  });

  describe('delete', () => {
    it('deletes conversation and messages', async () => {
      const convId = await asUser.mutation(api.conversations.create, {});
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId: convId,
        content: 'Hello',
      });

      await asUser.mutation(api.conversations.deleteConversation, {
        id: convId,
      });

      const conversation = await asUser.query(api.conversations.get, {
        id: convId,
      });
      expect(conversation).toBeNull();

      const messages = await asUser.query(api.conversationMessages.list, {
        conversationId: convId,
      });
      expect(messages.length).toBe(0);
    });
  });
});
```

### Task 4: Write Message Tests

**File:** `v2/convex/__tests__/conversationMessages.test.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { convexTest } from 'convex-test';
import { api } from '../_generated/api';
import schema from '../schema';
import { Id } from '../_generated/dataModel';

describe('conversationMessages', () => {
  let t: ReturnType<typeof convexTest>;
  let userId: Id<'users'>;
  let asUser: ReturnType<typeof t.withIdentity>;
  let conversationId: Id<'conversations'>;

  beforeEach(async () => {
    t = convexTest(schema);
    userId = await t.run(async (ctx) => {
      return await ctx.db.insert('users', { email: 'test@example.com' });
    });
    asUser = t.withIdentity({ subject: userId });
    conversationId = await asUser.mutation(api.conversations.create, {});
  });

  describe('createUserMessage', () => {
    it('creates a user message', async () => {
      const id = await asUser.mutation(
        api.conversationMessages.createUserMessage,
        {
          conversationId,
          content: 'Hello!',
        }
      );
      expect(id).toBeDefined();

      const messages = await asUser.query(api.conversationMessages.list, {
        conversationId,
      });
      expect(messages.length).toBe(1);
      expect(messages[0].role).toBe('user');
      expect(messages[0].content).toBe('Hello!');
    });

    it('updates conversation lastActiveAt', async () => {
      const before = await asUser.query(api.conversations.get, {
        id: conversationId,
      });

      // Wait a bit to ensure time difference
      await new Promise((r) => setTimeout(r, 10));

      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId,
        content: 'Update test',
      });

      const after = await asUser.query(api.conversations.get, {
        id: conversationId,
      });
      expect(after?.updatedAt).toBeGreaterThan(before?.updatedAt ?? 0);
    });
  });

  describe('createAssistantMessage', () => {
    it('creates an assistant message', async () => {
      await asUser.mutation(api.conversationMessages.createAssistantMessage, {
        conversationId,
        content: 'Hello! How can I help?',
      });

      const messages = await asUser.query(api.conversationMessages.list, {
        conversationId,
      });
      expect(messages.length).toBe(1);
      expect(messages[0].role).toBe('assistant');
    });

    it('stores metadata', async () => {
      await asUser.mutation(api.conversationMessages.createAssistantMessage, {
        conversationId,
        content: 'Response',
        metadata: {
          model: 'gemini-2.0-flash',
          processingTimeMs: 500,
          tokenCount: 50,
        },
      });

      const messages = await asUser.query(api.conversationMessages.list, {
        conversationId,
      });
      expect(messages[0].metadata?.model).toBe('gemini-2.0-flash');
    });

    it('auto-generates title from first user message', async () => {
      // Create user message first
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId,
        content: 'What are the PERM deadlines?',
      });

      // Then assistant response (triggers title generation)
      await asUser.mutation(api.conversationMessages.createAssistantMessage, {
        conversationId,
        content: 'Here are the PERM deadlines...',
      });

      const conversation = await asUser.query(api.conversations.get, {
        id: conversationId,
      });
      expect(conversation?.title).toBe('What are the PERM deadlines?');
    });

    it('truncates long titles', async () => {
      const longMessage =
        'This is a very long message that should be truncated because it exceeds fifty characters';
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId,
        content: longMessage,
      });
      await asUser.mutation(api.conversationMessages.createAssistantMessage, {
        conversationId,
        content: 'Response',
      });

      const conversation = await asUser.query(api.conversations.get, {
        id: conversationId,
      });
      expect(conversation?.title?.length).toBeLessThanOrEqual(50);
      expect(conversation?.title?.endsWith('...')).toBe(true);
    });
  });

  describe('list', () => {
    it('returns messages in chronological order', async () => {
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId,
        content: 'First',
      });
      await asUser.mutation(api.conversationMessages.createAssistantMessage, {
        conversationId,
        content: 'Second',
      });
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId,
        content: 'Third',
      });

      const messages = await asUser.query(api.conversationMessages.list, {
        conversationId,
      });
      expect(messages[0].content).toBe('First');
      expect(messages[1].content).toBe('Second');
      expect(messages[2].content).toBe('Third');
    });

    it('returns empty array for other user', async () => {
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId,
        content: 'Hello',
      });

      const otherUserId = await t.run(async (ctx) => {
        return await ctx.db.insert('users', { email: 'other@example.com' });
      });
      const asOther = t.withIdentity({ subject: otherUserId });

      const messages = await asOther.query(api.conversationMessages.list, {
        conversationId,
      });
      expect(messages.length).toBe(0);
    });
  });

  describe('count', () => {
    it('returns message count', async () => {
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId,
        content: 'One',
      });
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId,
        content: 'Two',
      });

      const count = await asUser.query(api.conversationMessages.count, {
        conversationId,
      });
      expect(count).toBe(2);
    });
  });

  describe('getMostRecent', () => {
    it('returns most recently updated conversation', async () => {
      const older = await asUser.mutation(api.conversations.create, {
        title: 'Older',
      });
      const newer = await asUser.mutation(api.conversations.create, {
        title: 'Newer',
      });

      // Add message to newer to update its updatedAt
      await asUser.mutation(api.conversationMessages.createUserMessage, {
        conversationId: newer,
        content: 'Latest',
      });

      const recent = await asUser.query(api.conversationMessages.getMostRecent, {});
      expect(recent?._id).toBe(newer);
    });
  });
});
```

## Verification

```bash
# 1. Convex dev server regenerates types
npx convex dev
# Should show "Generated types at convex/_generated/api.d.ts"

# 2. Run tests
pnpm test convex/__tests__/conversations.test.ts
pnpm test convex/__tests__/conversationMessages.test.ts

# 3. TypeScript compiles
pnpm build
```

## Success Criteria

- [ ] `convex/conversations.ts` implements all CRUD operations
- [ ] `convex/conversationMessages.ts` implements message operations
- [ ] Auto-title generation works on first AI response
- [ ] User isolation enforced (can't see other users' data)
- [ ] All tests pass (20+ test cases)
- [ ] TypeScript compiles without errors

## Output

```
v2/convex/
├── conversations.ts           # Conversation CRUD
├── conversationMessages.ts    # Message CRUD
└── __tests__/
    ├── conversations.test.ts
    └── conversationMessages.test.ts
```

## Notes

- Schema already exists in `convex/schema.ts` - no migration needed
- Messages stored individually (not in conversation document) for real-time subscription efficiency
- `getMostRecent` helper supports "resume conversation" UX pattern
- Auto-title truncates at 50 chars with ellipsis

---

**Next Plan:** 26-03 (Chat UI Core)
