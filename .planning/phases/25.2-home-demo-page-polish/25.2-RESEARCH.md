# Phase 25.2: Home & Demo Page Polish - Research

**Researched:** 2026-01-01
**Domain:** Landing page animations, scroll effects, hero images, localStorage demo
**Confidence:** HIGH

<research_summary>
## Summary

Researched the animation ecosystem for building a premium, animated landing page with Motion (formerly Framer Motion), GSAP alternatives, and performance best practices. The project already has **Motion v12.23.26** and **lottie-react v2.4.1** installed.

Key finding: Motion (Framer Motion) is the optimal choice for this React/Next.js project - it integrates seamlessly with React's component model, supports scroll-triggered animations via `whileInView`, scroll-linked effects via `useScroll`/`useTransform`, and has built-in accessibility support with `useReducedMotion`. The existing CSS animations in globals.css provide a solid foundation for micro-interactions.

**Primary recommendation:** Use Motion for all scroll animations (whileInView, useScroll), existing CSS utilities for micro-interactions (hover effects, card-snappy), and ensure prefers-reduced-motion compliance for accessibility. Hero image should use next/image with priority loading.
</research_summary>

<standard_stack>
## Standard Stack

### Core (Already Installed)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| motion | 12.23.26 | Scroll animations, variants, gestures | Official Motion for React, MIT license, React-native integration |
| lottie-react | 2.4.1 | Complex vector animations | Optional for hero if JSON animation route chosen |
| next/image | built-in | Hero image optimization | WebP/AVIF, srcset, priority loading, blur placeholder |

### Supporting (Available)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| tw-animate-css | installed | Tailwind animation utilities | Existing keyframe utilities |
| CSS globals.css | - | Micro-interactions | hover-lift, card-snappy, bounce utilities |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Motion whileInView | GSAP ScrollTrigger | GSAP more powerful but license restrictions (Webflow), heavier bundle |
| Motion useScroll | CSS scroll-driven animations | CSS native but limited browser support (no Firefox) |
| Lottie | CSS-only hero | Lottie flexible but JSON file adds weight |

**Installation:**
Already installed - no additional packages needed for animation.
```bash
# Already in package.json:
# "motion": "^12.23.26"
# "framer-motion": "^12.23.26" (motion is the new package name)
# "lottie-react": "^2.4.1"
```
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Recommended Project Structure
```
src/
├── app/
│   ├── page.tsx           # Home page (SSG)
│   └── demo/
│       └── page.tsx       # Demo page (client-side)
├── components/
│   ├── home/              # Home page sections
│   │   ├── Hero.tsx       # Hero with image + CTA
│   │   ├── Features.tsx   # Feature grid
│   │   ├── HowItWorks.tsx # Steps section
│   │   ├── FAQ.tsx        # Accordion
│   │   └── Contact.tsx    # Form + links
│   ├── demo/              # Demo page components
│   │   ├── DemoProvider.tsx    # localStorage context
│   │   ├── DemoCases.tsx       # CRUD interface
│   │   ├── MiniCalendar.tsx    # Calendar preview
│   │   └── MiniTimeline.tsx    # Timeline preview
│   └── animations/        # Reusable animation wrappers
│       ├── FadeInWhenVisible.tsx
│       ├── StaggerChildren.tsx
│       └── ScrollProgress.tsx
└── hooks/
    ├── useDemoCases.ts    # localStorage CRUD hook
    └── useScrollProgress.ts
```

### Pattern 1: Scroll-Triggered Animation with whileInView
**What:** Animate elements when they enter the viewport
**When to use:** Feature cards, section reveals, any content entering view
**Example:**
```typescript
// Source: motion.dev official docs
import { motion } from 'motion/react';

function FeatureCard({ title, description }) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      whileInView={{ opacity: 1, y: 0 }}
      viewport={{ once: true, margin: "-100px" }}
      transition={{ duration: 0.5, ease: "easeOut" }}
      className="card-snappy"
    >
      <h3>{title}</h3>
      <p>{description}</p>
    </motion.div>
  );
}
```

### Pattern 2: Stagger Children for Sequential Reveals
**What:** Animate children elements one-by-one with delay
**When to use:** Feature grids, FAQ items, any list of elements
**Example:**
```typescript
// Source: motion.dev official docs
import { motion, stagger } from 'motion/react';

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.1,
      delayChildren: 0.2
    }
  }
};

const item = {
  hidden: { opacity: 0, y: 20 },
  show: { opacity: 1, y: 0 }
};

function FeatureGrid({ features }) {
  return (
    <motion.div
      variants={container}
      initial="hidden"
      whileInView="show"
      viewport={{ once: true }}
    >
      {features.map((feature) => (
        <motion.div key={feature.id} variants={item}>
          {feature.content}
        </motion.div>
      ))}
    </motion.div>
  );
}
```

### Pattern 3: Scroll-Linked Parallax with useScroll/useTransform
**What:** Link element properties directly to scroll position
**When to use:** Hero parallax, progress bars, background effects
**Example:**
```typescript
// Source: motion.dev official docs
import { motion, useScroll, useTransform, useReducedMotion } from 'motion/react';
import { useRef } from 'react';

function ParallaxSection() {
  const ref = useRef(null);
  const shouldReduceMotion = useReducedMotion();

  const { scrollYProgress } = useScroll({
    target: ref,
    offset: ["start end", "end start"]
  });

  // Disable parallax for reduced motion
  const y = useTransform(
    scrollYProgress,
    [0, 1],
    shouldReduceMotion ? [0, 0] : [0, -100]
  );

  return (
    <div ref={ref}>
      <motion.div style={{ y }} className="bg-element" />
    </div>
  );
}
```

### Pattern 4: localStorage Demo State
**What:** Persist demo case data in localStorage for client-side demo
**When to use:** Demo page CRUD operations
**Example:**
```typescript
// Source: Next.js best practices - client-side only
'use client';
import { useState, useEffect } from 'react';

const STORAGE_KEY = 'perm-demo-cases';
const DEFAULT_CASES = [...]; // 5 default cases

function useDemoCases() {
  const [cases, setCases] = useState([]);
  const [isLoaded, setIsLoaded] = useState(false);

  // Load from localStorage on mount (client-side only)
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const stored = localStorage.getItem(STORAGE_KEY);
      setCases(stored ? JSON.parse(stored) : DEFAULT_CASES);
      setIsLoaded(true);
    }
  }, []);

  // Persist changes
  useEffect(() => {
    if (isLoaded && typeof window !== 'undefined') {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(cases));
    }
  }, [cases, isLoaded]);

  const addCase = (newCase) => setCases([...cases, newCase]);
  const updateCase = (id, updates) => setCases(
    cases.map(c => c.id === id ? { ...c, ...updates } : c)
  );
  const deleteCase = (id) => setCases(cases.filter(c => c.id !== id));
  const resetDemo = () => setCases(DEFAULT_CASES);

  return { cases, isLoaded, addCase, updateCase, deleteCase, resetDemo };
}
```

### Pattern 5: Hero Image with Next.js Optimization
**What:** Optimized hero image with priority loading, responsive sizes
**When to use:** Above-the-fold hero images
**Example:**
```typescript
// Source: Next.js 14+ docs
import Image from 'next/image';

function Hero() {
  return (
    <div className="relative">
      <Image
        src="/images/hero-showcase.webp"
        alt="PERM Tracker Dashboard Showcase"
        width={1920}
        height={1080}
        priority
        quality={85}
        placeholder="blur"
        blurDataURL="data:image/jpeg;base64,..."
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px"
        className="w-full h-auto"
      />
    </div>
  );
}
```

### Anti-Patterns to Avoid
- **Animating width/height/top/left:** Use transform/opacity only for GPU acceleration
- **Multiple scroll listeners:** Use one useScroll per scroll context, share values
- **Ignoring useReducedMotion:** Always check and provide static fallback
- **JS-driven micro-interactions:** Use CSS utilities (card-snappy) for hover effects
- **Loading Motion eagerly:** Code-split heavy animation components
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Scroll-triggered reveal | Manual IntersectionObserver | Motion whileInView | Built-in, cleaner API, handles edge cases |
| Stagger animations | Manual delay loops | Motion variants + staggerChildren | Orchestration handled automatically |
| Parallax effects | Manual scroll listeners | Motion useScroll + useTransform | GPU-accelerated, Spring physics available |
| Reduced motion check | Manual matchMedia | Motion useReducedMotion | Reactive, re-renders on change |
| Hero image optimization | Manual srcset | next/image | WebP/AVIF auto-conversion, lazy loading |
| Card hover effects | JS onClick/onHover | CSS card-snappy utility | Zero JS, better performance |
| Smooth scroll progress | Manual scroll % calc | Motion useScroll scrollYProgress | Handles edge cases, container vs page |

**Key insight:** Motion already includes everything needed for scroll animations - don't add GSAP ScrollTrigger (adds 23KB+ gzip, license issues). The existing CSS animations in globals.css are GPU-accelerated and should be used for micro-interactions.
</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Animation Performance on Mobile
**What goes wrong:** Janky animations, battery drain, dropped frames
**Why it happens:** Too many animated elements, non-GPU properties, no reduced motion
**How to avoid:**
- Only animate `transform` and `opacity` (GPU-accelerated)
- Reduce animation complexity on mobile (check viewport width)
- Always implement `useReducedMotion` check
- Limit stagger to 5-8 elements max
**Warning signs:** FPS drops visible in DevTools, hot device

### Pitfall 2: Hydration Mismatch with localStorage
**What goes wrong:** Server/client content mismatch errors
**Why it happens:** localStorage not available during SSR
**How to avoid:**
- Use `isLoaded` state pattern, show skeleton until hydrated
- Wrap localStorage access in `typeof window !== 'undefined'` check
- Use `'use client'` directive on demo components
**Warning signs:** "Hydration failed" console errors, content flashing

### Pitfall 3: whileInView Firing Too Late
**What goes wrong:** Animation starts when element already centered, feels laggy
**Why it happens:** Default viewport detection is at element edge
**How to avoid:**
- Use `viewport={{ margin: "-100px" }}` to trigger earlier (10-20% in view)
- Or `viewport={{ amount: 0.3 }}` for 30% visible trigger
**Warning signs:** User already scrolled past by animation start

### Pitfall 4: Missing once: true Causing Re-Animation
**What goes wrong:** Elements re-animate when scrolling back up
**Why it happens:** Default whileInView re-triggers on every intersection
**How to avoid:**
- Add `viewport={{ once: true }}` for one-time reveals
- Only omit `once` for intentional bidirectional animations
**Warning signs:** Same content animating repeatedly on scroll

### Pitfall 5: Hero Image LCP Impact
**What goes wrong:** Slow Largest Contentful Paint, poor Core Web Vitals
**Why it happens:** Large hero image not prioritized, wrong format, no placeholder
**How to avoid:**
- Use `priority` prop on hero Image component
- Convert to WebP, target <200KB for largest version
- Add `placeholder="blur"` with blurDataURL
- Use correct `sizes` attribute for responsive
**Warning signs:** LCP > 2.5s in PageSpeed Insights

### Pitfall 6: Scroll Animation Causing Scroll Jank
**What goes wrong:** Page scrolls erratically or hesitates
**Why it happens:** Too many scroll listeners, layout thrashing
**How to avoid:**
- Use single useScroll, share MotionValues
- Avoid reading/writing DOM in scroll callbacks
- Use `will-change: transform` sparingly
**Warning signs:** Scrollbar jumping, browser freezing mid-scroll
</common_pitfalls>

<code_examples>
## Code Examples

Verified patterns from official sources:

### Accessibility-First Animation Wrapper
```typescript
// Source: motion.dev accessibility docs
'use client';
import { motion, useReducedMotion, Variants } from 'motion/react';
import { ReactNode } from 'react';

interface FadeInWhenVisibleProps {
  children: ReactNode;
  delay?: number;
  className?: string;
}

export function FadeInWhenVisible({
  children,
  delay = 0,
  className
}: FadeInWhenVisibleProps) {
  const shouldReduceMotion = useReducedMotion();

  const variants: Variants = {
    hidden: {
      opacity: 0,
      y: shouldReduceMotion ? 0 : 20
    },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: shouldReduceMotion ? 0.01 : 0.5,
        delay: shouldReduceMotion ? 0 : delay,
        ease: 'easeOut'
      }
    }
  };

  return (
    <motion.div
      initial="hidden"
      whileInView="visible"
      viewport={{ once: true, margin: "-50px" }}
      variants={variants}
      className={className}
    >
      {children}
    </motion.div>
  );
}
```

### Staggered Grid Container
```typescript
// Source: motion.dev variants tutorial
'use client';
import { motion, stagger } from 'motion/react';
import { ReactNode } from 'react';

interface StaggerGridProps {
  children: ReactNode;
  className?: string;
  staggerDelay?: number;
}

const containerVariants = {
  hidden: { opacity: 0 },
  visible: (staggerDelay: number) => ({
    opacity: 1,
    transition: {
      staggerChildren: staggerDelay,
      delayChildren: 0.2
    }
  })
};

export const itemVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: {
    opacity: 1,
    y: 0,
    transition: { duration: 0.4, ease: 'easeOut' }
  }
};

export function StaggerGrid({
  children,
  className,
  staggerDelay = 0.1
}: StaggerGridProps) {
  return (
    <motion.div
      variants={containerVariants}
      initial="hidden"
      whileInView="visible"
      viewport={{ once: true, amount: 0.2 }}
      custom={staggerDelay}
      className={className}
    >
      {children}
    </motion.div>
  );
}

// Usage with items
export function StaggerItem({ children, className }) {
  return (
    <motion.div variants={itemVariants} className={className}>
      {children}
    </motion.div>
  );
}
```

### Scroll Progress Indicator
```typescript
// Source: motion.dev useScroll docs
'use client';
import { motion, useScroll, useSpring } from 'motion/react';

export function ScrollProgressBar() {
  const { scrollYProgress } = useScroll();
  const scaleX = useSpring(scrollYProgress, {
    stiffness: 100,
    damping: 30,
    restDelta: 0.001
  });

  return (
    <motion.div
      className="fixed top-0 left-0 right-0 h-1 bg-primary origin-left z-50"
      style={{ scaleX }}
    />
  );
}
```

### localStorage Demo Hook
```typescript
// Source: Next.js best practices
'use client';
import { useState, useEffect, useCallback } from 'react';

const STORAGE_KEY = 'perm-demo-cases';

interface DemoCase {
  id: string;
  beneficiaryName: string;
  employerName: string;
  caseStatus: string;
  pwdDeterminationDate?: string;
  // ... other fields
}

const DEFAULT_CASES: DemoCase[] = [
  // 5 default demo cases here
];

export function useDemoCases() {
  const [cases, setCases] = useState<DemoCase[]>([]);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    if (typeof window === 'undefined') return;

    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      setCases(stored ? JSON.parse(stored) : DEFAULT_CASES);
    } catch {
      setCases(DEFAULT_CASES);
    }
    setIsLoaded(true);
  }, []);

  useEffect(() => {
    if (!isLoaded || typeof window === 'undefined') return;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(cases));
  }, [cases, isLoaded]);

  const addCase = useCallback((newCase: Omit<DemoCase, 'id'>) => {
    const id = crypto.randomUUID();
    setCases(prev => [...prev, { ...newCase, id }]);
    return id;
  }, []);

  const updateCase = useCallback((id: string, updates: Partial<DemoCase>) => {
    setCases(prev => prev.map(c => c.id === id ? { ...c, ...updates } : c));
  }, []);

  const deleteCase = useCallback((id: string) => {
    setCases(prev => prev.filter(c => c.id !== id));
  }, []);

  const resetDemo = useCallback(() => {
    setCases(DEFAULT_CASES);
  }, []);

  return { cases, isLoaded, addCase, updateCase, deleteCase, resetDemo };
}
```
</code_examples>

<sota_updates>
## State of the Art (2024-2025)

What's changed recently:

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| framer-motion package | motion package (motion/react) | 2024 | New import path, same API, cleaner package |
| Manual Intersection Observer | whileInView prop | Stable since Motion 4 | Declarative, less boilerplate |
| GSAP for everything | Motion for React, GSAP for vanilla/complex | 2024 | Motion better React integration, GSAP license issues |
| CSS scroll-timeline | Still experimental | 2024-2025 | Firefox no support, use Motion useScroll instead |

**New tools/patterns to consider:**
- **Motion 12.x:** Latest stable, improved performance, new AnimatePresence modes
- **View Transitions API:** Native browser page transitions (Chrome only, experimental)
- **CSS @starting-style:** Native entry animations (limited support, not ready)

**Deprecated/outdated:**
- **react-scroll:** Use native CSS scroll-behavior or Motion
- **react-intersection-observer + manual state:** Use whileInView instead
- **GSAP in React without useGSAP hook:** Causes memory leaks, use hook or Motion
</sota_updates>

<open_questions>
## Open Questions

Things that couldn't be fully resolved:

1. **Hero Image Animation Style**
   - What we know: User wants "Linear-style" not "3D tilt"
   - What's unclear: Exact animation - subtle float, parallax, or static with surrounding motion
   - Recommendation: Start with subtle float (translateY pulse), easy to adjust

2. **Magnetic Cursor Implementation**
   - What we know: User wants Stripe-style magnetic effect on buttons
   - What's unclear: Whether to use existing library (magnet-mouse.js, mouse-follower) or custom
   - Recommendation: Custom lightweight implementation with Motion useMotionValue for React integration, avoid heavy libraries

3. **Exact Scroll Animation Timing**
   - What we know: Early reveal (10-20%), center reveal (40-50%), stagger cascade
   - What's unclear: Specific timing for each section
   - Recommendation: Document in ANIMATION_STORYBOARD.md during implementation, iterate visually
</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- /websites/motion-dev-docs - whileInView, useScroll, useTransform, useReducedMotion patterns
- /websites/gsap_v3 - ScrollTrigger comparison, parallax patterns
- /gamote/lottie-react - Scroll-based Lottie interactivity
- Next.js official docs - Image optimization, priority loading, sizes attribute

### Secondary (MEDIUM confidence)
- [motion.dev/docs/react-scroll-animations](https://motion.dev/docs/react-scroll-animations) - Scroll animation patterns
- [motion.dev/docs/gsap-vs-motion](https://motion.dev/docs/gsap-vs-motion) - Library comparison
- [web.dev/prefers-reduced-motion](https://web.dev/articles/prefers-reduced-motion) - Accessibility best practices
- [MDN prefers-reduced-motion](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@media/prefers-reduced-motion) - Media query usage

### Tertiary (LOW confidence - needs validation)
- Community patterns for magnetic cursor (validate during implementation)
- Specific scroll timing recommendations (validate visually)
</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: Motion (Framer Motion) v12.23.26 (already installed)
- Ecosystem: next/image, CSS animations, lottie-react
- Patterns: whileInView, useScroll, variants, stagger
- Pitfalls: Performance, hydration, accessibility

**Confidence breakdown:**
- Standard stack: HIGH - already installed, well-documented
- Architecture: HIGH - from official Motion docs
- Pitfalls: HIGH - documented in guides, verified with best practices
- Code examples: HIGH - from Context7/official sources

**Research date:** 2026-01-01
**Valid until:** 2026-02-01 (30 days - Motion ecosystem stable)
</metadata>

---

*Phase: 25.2-home-demo-page-polish*
*Research completed: 2026-01-01*
*Ready for planning: yes*
