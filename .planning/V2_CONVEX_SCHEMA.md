# V2 Convex Schema Documentation

**Purpose:** Comprehensive schema reference for Convex migration with PostgreSQL → Convex type mappings.

**Status:** Phase 14 documentation | Generated: 2025-12-20 | Updated: 2025-12-22

> **Reference:** See `V2_ORIGINAL_VISION.md` for complete requirements

---

## Table of Contents

1. [Type Mapping Rules](#type-mapping-rules)
2. [Schema Tables](#schema-tables)
3. [Critical Schema Issues](#critical-schema-issues)
4. [Relationships](#relationships)
5. [Security Rules (RLS → Convex)](#security-rules-rls--convex)
6. [Migration Notes](#migration-notes)

---

## Type Mapping Rules

### PostgreSQL → Convex Type Mappings

| PostgreSQL Type | Convex Type | Notes |
|----------------|-------------|-------|
| `UUID` (Primary Key) | `Id<"tableName">` | Auto-generated by Convex |
| `UUID` (Foreign Key) | `Id<"tableName">` | References to other tables |
| `UUID` (External) | `v.string()` | External IDs (e.g., auth_user_id) |
| `VARCHAR(N)` | `v.string()` | |
| `TEXT` | `v.string()` | |
| `INTEGER` | `v.int64()` | Use int64 for all integers |
| `BOOLEAN` | `v.boolean()` | |
| `TIMESTAMP WITH TIME ZONE` | `v.number()` | Unix timestamp (milliseconds) |
| `DATE` | `v.string()` | ISO 8601 format (YYYY-MM-DD) |
| `JSONB` | `v.any()` or specific object | Define schema when structure is known |
| `DECIMAL(10, 2)` | `v.int64()` | Store as cents (multiply by 100) |
| `TEXT[]` | `v.array(v.string())` | |
| `TIME` | `v.string()` | HH:MM:SS format |

### Default Value Handling

Convex uses validators with defaults instead of database defaults:

```typescript
// PostgreSQL: DEFAULT 'normal'
// Convex:
priority_level: v.optional(v.union(
  v.literal("low"),
  v.literal("normal"),
  v.literal("high"),
  v.literal("urgent")
)), // Default in mutation/query logic
```

---

## Schema Tables

### 1. users

**Source:** Migration 001 (created as `users`), but later migrations reference as `perm_users`

**Purpose:** User accounts and authentication

**Convex Schema:**

```typescript
users: defineTable({
  // === Identity ===
  auth_user_id: v.string(), // References auth.users(id) in Supabase
  email: v.string(),
  full_name: v.optional(v.string()),

  // === Organization ===
  user_type: v.union(
    v.literal("individual"),
    v.literal("firm_admin"),
    v.literal("firm_member")
  ),
  firm_name: v.optional(v.string()),
  firm_id: v.optional(v.id("users")), // Self-reference for firm members

  // === Notification Settings ===
  notification_preferences: v.any(), // JSONB structure defined below

  // === Google Calendar Integration ===
  google_calendar_connected: v.boolean(),
  google_calendar_refresh_token: v.optional(v.string()),
  calendar_sync_enabled: v.boolean(),
  calendar_sync_preferences: v.any(), // JSONB structure defined below

  // === Google OAuth (from perm_users) ===
  google_refresh_token: v.optional(v.string()),
  google_access_token: v.optional(v.string()),
  google_token_expiry: v.optional(v.number()), // Unix timestamp
  google_scopes: v.optional(v.array(v.string())),
  google_email: v.optional(v.string()),
  gmail_connected: v.boolean(),
  calendar_connected: v.boolean(),

  // === Calendar Sync Preferences ===
  calendar_sync_recruitment: v.boolean(),
  calendar_sync_filing_window: v.boolean(),
  calendar_sync_rfi: v.boolean(),

  // === Privacy ===
  privacy_mode_enabled: v.boolean(),

  // === Timestamps ===
  created_at: v.number(), // Unix timestamp
  updated_at: v.number(),
  last_login_at: v.optional(v.number()),
  deleted_at: v.optional(v.number()), // Soft delete
})
.index("by_auth_user_id", ["auth_user_id"])
.index("by_email", ["email"])
.index("by_firm_id", ["firm_id"])
.index("by_deleted_at", ["deleted_at"]) // For soft delete queries
```

**JSONB Structures:**

```typescript
// notification_preferences structure
{
  email_enabled: boolean,
  deadline_reminders: boolean,
  status_updates: boolean,
  rfe_alerts: boolean
}

// calendar_sync_preferences structure
{
  sync_recruitment: boolean,
  sync_filing_windows: boolean,
  sync_rfi_deadlines: boolean
}
```

---

### 2. cases

**Source:** Migration 001, modified in migrations 009, 010, 013, 015, 016, 017, 020

**Purpose:** PERM case tracking and deadlines

**Convex Schema:**

```typescript
cases: defineTable({
  // === Core Identity ===
  user_id: v.id("users"),
  case_number: v.optional(v.string()), // DOL case number
  internal_case_number: v.optional(v.string()), // Attorney's internal reference (v2.0)

  // === Employer Information ===
  employer_name: v.string(),
  employer_fein: v.optional(v.string()),

  // === Beneficiary Information ===
  beneficiary_identifier: v.string(), // Privacy-safe identifier

  // === Position Information ===
  position_title: v.string(),
  job_title: v.optional(v.string()),
  soc_code: v.optional(v.string()),
  soc_title: v.optional(v.string()),
  job_order_state: v.optional(v.string()), // 2-letter state code

  // === Case Status (v2.0: Two-Tier System) ===
  // See V2_ORIGINAL_VISION.md for complete requirements
  case_status: v.union(
    v.literal("pwd"),
    v.literal("recruitment"),
    v.literal("eta9089"),
    v.literal("i140"),
    v.literal("closed")
  ),
  progress_status: v.union(
    v.literal("working"),
    v.literal("waiting_intake"),
    v.literal("filed"),
    v.literal("approved"),
    v.literal("under_review"),
    v.literal("rfi_rfe")
  ),
  progress_status_override: v.optional(v.boolean()), // True if manually set

  // === PWD Phase ===
  pwd_filing_date: v.optional(v.string()), // ISO date
  pwd_determination_date: v.optional(v.string()),
  pwd_expiration_date: v.optional(v.string()), // Auto-calculated
  pwd_case_number: v.optional(v.string()), // DOL PWD tracking number (v2.0)
  pwd_wage_amount: v.optional(v.int64()), // Stored as cents
  pwd_wage_level: v.optional(v.string()),

  // === Recruitment Phase - Job Order ===
  job_order_start_date: v.optional(v.string()),
  job_order_end_date: v.optional(v.string()),

  // === Recruitment Phase - Sunday Ads ===
  sunday_ad_first_date: v.optional(v.string()),
  sunday_ad_second_date: v.optional(v.string()),
  sunday_ad_newspaper: v.optional(v.string()),

  // === Recruitment Phase - Additional Methods ===
  additional_recruitment_start_date: v.optional(v.string()),
  additional_recruitment_end_date: v.optional(v.string()),
  additional_recruitment_methods: v.array(v.any()), // Array of method objects
  recruitment_notes: v.optional(v.string()),
  recruitment_applicants_count: v.int64(),
  recruitment_summary_custom: v.optional(v.string()),

  // === Professional Occupation Flag ===
  is_professional_occupation: v.boolean(), // Requires Bachelor's degree

  // === Notice of Filing ===
  notice_of_filing_start_date: v.optional(v.string()),
  notice_of_filing_end_date: v.optional(v.string()),

  // === ETA 9089 Phase ===
  eta9089_filing_date: v.optional(v.string()),
  eta9089_audit_date: v.optional(v.string()),
  eta9089_certification_date: v.optional(v.string()),
  eta9089_expiration_date: v.optional(v.string()),
  eta9089_case_number: v.optional(v.string()),

  // === RFI (Request for Information) ===
  rfi_received_date: v.optional(v.string()),
  rfi_response_due_date: v.optional(v.string()),
  rfi_response_submitted_date: v.optional(v.string()),

  // === RFE (Request for Evidence) ===
  rfe_received_date: v.optional(v.string()),
  rfe_response_due_date: v.optional(v.string()),
  rfe_response_submitted_date: v.optional(v.string()),

  // === I-140 Phase ===
  i140_filing_date: v.optional(v.string()),
  i140_receipt_date: v.optional(v.string()),
  i140_receipt_number: v.optional(v.string()),
  i140_approval_date: v.optional(v.string()),
  i140_denial_date: v.optional(v.string()),

  // === Organization & Metadata ===
  priority_level: v.union(
    v.literal("low"),
    v.literal("normal"),
    v.literal("high"),
    v.literal("urgent")
  ),
  is_favorite: v.boolean(),
  // === Notes (v2.0: Structured timestamped entries) ===
  notes: v.optional(v.array(v.object({
    id: v.string(),
    content: v.string(),
    created_at: v.number(), // Unix timestamp
    status: v.union(v.literal("pending"), v.literal("done"), v.literal("deleted"))
  }))),
  tags: v.array(v.string()),

  // === Documents & Calendar ===
  documents: v.array(v.any()), // Array of document objects
  calendar_event_ids: v.any(), // Map of event type → Google Calendar event ID
  calendar_sync_enabled: v.boolean(),

  // === Timestamps ===
  created_at: v.number(),
  updated_at: v.number(),
  deleted_at: v.optional(v.number()), // Soft delete
})
.index("by_user_id", ["user_id"])
.index("by_user_and_status", ["user_id", "case_status"])
.index("by_user_and_favorite", ["user_id", "is_favorite"])
.index("by_user_and_priority", ["user_id", "priority_level"])
.index("by_deleted_at", ["deleted_at"])
```

**JSONB Structures:**

```typescript
// additional_recruitment_methods array items
{
  method: string, // e.g., "job_fair", "website", "professional_organization"
  date: string, // ISO date
  description: string
}

// documents array items
{
  id: string,
  name: string,
  type: string, // e.g., "pwd", "job_order", "recruitment_proof"
  url: string,
  uploaded_at: number // Unix timestamp
}

// calendar_event_ids structure
{
  pwd_expiration: string, // Google Calendar event ID
  job_order_end: string,
  eta9089_window_open: string,
  eta9089_window_close: string,
  rfi_due: string,
  // ... other event types
}
```

---

### 3. notifications

**Source:** Migration 005

**Purpose:** User notifications and deadline reminders

**Convex Schema:**

```typescript
notifications: defineTable({
  // === Relationships ===
  user_id: v.id("users"),
  case_id: v.optional(v.id("cases")),

  // === Notification Content ===
  type: v.union(
    v.literal("deadline_reminder"),
    v.literal("status_change"),
    v.literal("rfe_alert"),
    v.literal("system")
  ),
  title: v.string(),
  message: v.string(),

  // === Priority ===
  priority: v.union(
    v.literal("low"),
    v.literal("normal"),
    v.literal("high"),
    v.literal("urgent")
  ),

  // === Deadline Information ===
  deadline_date: v.optional(v.string()), // ISO date
  deadline_type: v.optional(v.string()), // e.g., "pwd_expiration", "rfi_due"
  days_until_deadline: v.optional(v.int64()),

  // === Read Status ===
  is_read: v.boolean(),
  read_at: v.optional(v.number()), // Unix timestamp

  // === Email Status ===
  email_sent: v.boolean(),
  email_sent_at: v.optional(v.number()),

  // === Timestamps ===
  created_at: v.number(),
  updated_at: v.number(),
})
.index("by_user_id", ["user_id"])
.index("by_user_and_unread", ["user_id", "is_read"])
.index("by_case_id", ["case_id"])
.index("by_deadline_date", ["deadline_date"])
```

---

### 4. user_settings

**Source:** Migration 005

**Purpose:** User notification and email preferences

**Convex Schema:**

```typescript
user_settings: defineTable({
  // === User Reference ===
  user_id: v.id("users"), // Unique constraint enforced in application logic

  // === Email Notification Toggles ===
  email_notifications_enabled: v.boolean(),
  email_deadline_reminders: v.boolean(),
  email_status_updates: v.boolean(),
  email_rfe_alerts: v.boolean(),

  // === Reminder Timing ===
  reminder_days_before: v.array(v.int64()), // e.g., [1, 3, 7, 14, 30]

  // === Quiet Hours ===
  quiet_hours_enabled: v.boolean(),
  quiet_hours_start: v.string(), // HH:MM:SS format
  quiet_hours_end: v.string(),

  // === Localization ===
  timezone: v.string(), // IANA timezone string

  // === Email Routing ===
  preferred_notification_email: v.union(
    v.literal("signup"),
    v.literal("google"),
    v.literal("both")
  ),

  // === Dismissed Deadlines ===
  dismissed_deadlines: v.array(v.any()), // Array of {case_id, deadline_type}

  // === Timestamps ===
  created_at: v.number(),
  updated_at: v.number(),
})
.index("by_user_id", ["user_id"])
```

**JSONB Structures:**

```typescript
// dismissed_deadlines array items
{
  case_id: string, // Convex ID
  deadline_type: string, // e.g., "pwd_expiration"
  dismissed_at: number // Unix timestamp
}
```

---

### 5. refresh_tokens

**Source:** Migration 008

**Purpose:** JWT refresh token management

**Convex Schema:**

```typescript
refresh_tokens: defineTable({
  // === User Reference ===
  user_id: v.id("users"),

  // === Token Data ===
  token: v.string(), // Unique constraint enforced in application logic
  expires_at: v.number(), // Unix timestamp

  // === Revocation ===
  revoked_at: v.optional(v.number()),
  revoked_reason: v.optional(v.union(
    v.literal("rotation"),
    v.literal("logout"),
    v.literal("security"),
    v.literal("expired")
  )),

  // === Security Metadata ===
  ip_address: v.optional(v.string()),
  user_agent: v.optional(v.string()),

  // === Timestamps ===
  created_at: v.number(),
  updated_at: v.number(),
})
.index("by_user_id", ["user_id"])
.index("by_token", ["token"])
.index("by_expires_at", ["expires_at"])
```

---

### 6. user_preferences

**Source:** Migration 011

**Purpose:** UI/UX preferences for case list display

**Convex Schema:**

```typescript
user_preferences: defineTable({
  // === User Reference ===
  user_id: v.id("users"), // Unique constraint enforced in application logic

  // === Case List Sorting ===
  cases_sort_by: v.string(), // e.g., "updated_at", "priority_level"
  cases_sort_order: v.union(v.literal("asc"), v.literal("desc")),

  // === Pagination ===
  cases_per_page: v.int64(), // Validate 6-50 in application logic

  // === Dismissed Items ===
  dismissed_deadlines: v.array(v.any()), // Same structure as user_settings

  // === Timestamps ===
  created_at: v.number(),
  updated_at: v.number(),
})
.index("by_user_id", ["user_id"])
```

**Note:** This table duplicates `dismissed_deadlines` from `user_settings`. Consider consolidating during migration.

---

### 7. permission_states

**Source:** Migration 012

**Purpose:** Chatbot permission workflow state management

**Convex Schema:**

```typescript
permission_states: defineTable({
  // === Identity ===
  state_id: v.string(), // Unique constraint enforced in application logic
  user_id: v.id("users"),
  conversation_id: v.string(),

  // === Conversation State ===
  messages: v.array(v.any()), // Array of message objects
  pending_tool_call: v.any(), // Tool call awaiting permission
  tools_executed: v.array(v.string()), // History of executed tools

  // === Expiration ===
  created_at: v.number(),
  expires_at: v.number(), // 1 hour from creation
})
.index("by_state_id", ["state_id"])
.index("by_user_id", ["user_id"])
.index("by_expires_at", ["expires_at"]) // For cleanup
```

**JSONB Structures:**

```typescript
// messages array items
{
  role: "user" | "assistant" | "system",
  content: string,
  timestamp: number
}

// pending_tool_call structure
{
  tool: string,
  arguments: Record<string, any>,
  requires_permission: boolean
}
```

---

### 8. conversations

**Source:** Migration 019

**Purpose:** Chatbot conversation threads

**Convex Schema:**

```typescript
conversations: defineTable({
  // === User Reference ===
  user_id: v.id("users"),

  // === Conversation Data ===
  title: v.string(),
  is_archived: v.boolean(),

  // === Metadata ===
  metadata: v.any(), // Flexible metadata storage

  // === Timestamps ===
  created_at: v.number(),
  updated_at: v.number(),
})
.index("by_user_id", ["user_id"])
.index("by_user_and_archived", ["user_id", "is_archived"])
```

---

### 9. conversation_messages

**Source:** Migration 019

**Purpose:** Individual messages within conversations

**Convex Schema:**

```typescript
conversation_messages: defineTable({
  // === Conversation Reference ===
  conversation_id: v.id("conversations"),

  // === Message Data ===
  role: v.union(
    v.literal("user"),
    v.literal("assistant"),
    v.literal("system")
  ),
  content: v.string(),

  // === Tool Execution ===
  tool_calls: v.optional(v.any()), // Array of tool call objects

  // === Metadata ===
  metadata: v.any(),

  // === Timestamps ===
  created_at: v.number(),
})
.index("by_conversation_id", ["conversation_id"])
.index("by_created_at", ["created_at"]) // For chronological ordering
```

**JSONB Structures:**

```typescript
// tool_calls array items
{
  tool: string,
  arguments: Record<string, any>,
  result: any,
  executed_at: number
}
```

---

## Critical Schema Issues

### 1. Table Naming Inconsistency: `users` vs `perm_users`

**Problem:**
- Migration 001 creates table named `users`
- Migrations 002, 003, 005, 008, 012 reference `perm_users`
- Foreign keys point to non-existent table

**Impact:**
- Foreign key constraints fail
- Referential integrity broken
- Queries may fail depending on actual production state

**Evidence:**
```sql
-- Migration 001
CREATE TABLE users (...);

-- Migration 005 (notifications)
FOREIGN KEY (user_id) REFERENCES perm_users(id)  -- ❌ Table doesn't exist

-- Migration 008 (refresh_tokens)
FOREIGN KEY (user_id) REFERENCES perm_users(id)  -- ❌ Table doesn't exist
```

**Resolution for Convex:**
- Use consistent name `users` in all Convex schemas
- Verify actual PostgreSQL table name before migration
- May need to rename table or update all foreign keys

### 2. Duplicate Fields Across Tables

**Problem:**
- `dismissed_deadlines` appears in both `user_settings` and `user_preferences`
- Both use identical JSONB structure
- Unclear which is source of truth

**Resolution:**
- Consolidate into single table (likely `user_settings`)
- Remove from `user_preferences` during migration
- Update application code to read from single source

### 3. Soft Delete Implementation

**Problem:**
- `deleted_at` timestamp used for soft deletes
- No consistent indexing strategy
- Some tables have index, others don't

**Tables with soft delete:**
- `users.deleted_at`
- `cases.deleted_at`

**Resolution:**
- Add `deleted_at` index to all soft-delete tables
- Implement consistent query pattern in Convex (filter where `deleted_at === undefined`)
- Consider Convex-native archival patterns

### 4. JSONB Field Structure Ambiguity

**Problem:**
- Many JSONB fields lack documented structure
- Examples: `notification_preferences`, `calendar_sync_preferences`, `metadata`
- Makes validation difficult

**Resolution:**
- Define explicit TypeScript interfaces for all JSONB structures
- Use `v.object({...})` with specific schema instead of `v.any()`
- Document allowed structures in code comments

### 5. Currency Storage

**Problem:**
- `pwd_wage_amount` stored as `DECIMAL(10, 2)`
- No explicit documentation of precision handling

**Resolution:**
- Convert to cents (multiply by 100) for Convex storage
- Use `v.int64()` for storage
- Document conversion in application logic

---

## Relationships

### User → Cases (One-to-Many)
```typescript
// Query all cases for a user
ctx.db.query("cases")
  .withIndex("by_user_id", q => q.eq("user_id", userId))
  .collect()
```

### User → Notifications (One-to-Many)
```typescript
// Query unread notifications
ctx.db.query("notifications")
  .withIndex("by_user_and_unread", q =>
    q.eq("user_id", userId).eq("is_read", false)
  )
  .collect()
```

### Case → Notifications (One-to-Many)
```typescript
// Query notifications for a case
ctx.db.query("notifications")
  .withIndex("by_case_id", q => q.eq("case_id", caseId))
  .collect()
```

### User → Settings (One-to-One)
```typescript
// Get user settings
const settings = await ctx.db.query("user_settings")
  .withIndex("by_user_id", q => q.eq("user_id", userId))
  .unique()
```

### User → Preferences (One-to-One)
```typescript
// Get user preferences
const prefs = await ctx.db.query("user_preferences")
  .withIndex("by_user_id", q => q.eq("user_id", userId))
  .unique()
```

### User → RefreshTokens (One-to-Many)
```typescript
// Get active tokens for user
ctx.db.query("refresh_tokens")
  .withIndex("by_user_id", q => q.eq("user_id", userId))
  .filter(q => q.eq(q.field("revoked_at"), undefined))
  .collect()
```

### User → Conversations (One-to-Many)
```typescript
// Get active conversations
ctx.db.query("conversations")
  .withIndex("by_user_and_archived", q =>
    q.eq("user_id", userId).eq("is_archived", false)
  )
  .collect()
```

### Conversation → Messages (One-to-Many)
```typescript
// Get messages in chronological order
ctx.db.query("conversation_messages")
  .withIndex("by_conversation_id", q => q.eq("conversation_id", convId))
  .order("asc") // By created_at
  .collect()
```

### User → Firm (Self-Reference)
```typescript
// Get firm members (for firm admin)
ctx.db.query("users")
  .withIndex("by_firm_id", q => q.eq("firm_id", adminUserId))
  .collect()
```

---

## Security Rules (RLS → Convex)

### Overview

**v1 Architecture:** PostgreSQL Row-Level Security (RLS) policies enforce data isolation at the database layer.

**v2 Architecture:** Convex uses function-level access control. Security is enforced in queries/mutations through authentication context.

**Critical Principle:** Every Convex query/mutation MUST validate user identity and filter data accordingly.

---

### v1 RLS Helper Functions

The v1 PostgreSQL schema uses three security helper functions:

#### 1. `get_current_user_id()`
```sql
-- Returns internal UUID from Supabase auth.uid()
CREATE FUNCTION get_current_user_id()
RETURNS UUID AS $$
  SELECT id FROM users WHERE auth_user_id = auth.uid() LIMIT 1
$$ LANGUAGE SQL SECURITY DEFINER STABLE;
```

**Convex Equivalent:**
```typescript
// Get user ID from auth context
const identity = await ctx.auth.getUserIdentity();
if (!identity) throw new Error("Unauthorized");

const user = await ctx.db.query("users")
  .withIndex("by_auth_user_id", q => q.eq("auth_user_id", identity.subject))
  .unique();

if (!user) throw new Error("User not found");
return user._id;
```

#### 2. `is_firm_admin()`
```sql
-- Returns true if current user is a firm admin
CREATE FUNCTION is_firm_admin()
RETURNS BOOLEAN AS $$
  SELECT user_type = 'firm_admin' FROM users WHERE auth_user_id = auth.uid()
$$ LANGUAGE SQL SECURITY DEFINER STABLE;
```

**Convex Equivalent:**
```typescript
// Check if user is firm admin
const userId = await getCurrentUserId(ctx);
const user = await ctx.db.get(userId);
return user.user_type === "firm_admin";
```

#### 3. `get_current_user_firm_id()`
```sql
-- Returns the firm_id of current user
CREATE FUNCTION get_current_user_firm_id()
RETURNS UUID AS $$
  SELECT firm_id FROM users WHERE auth_user_id = auth.uid()
$$ LANGUAGE SQL SECURITY DEFINER STABLE;
```

**Convex Equivalent:**
```typescript
// Get user's firm ID
const userId = await getCurrentUserId(ctx);
const user = await ctx.db.get(userId);
return user.firm_id;
```

---

### v1 → v2 Policy Mapping

| Table | v1 RLS Policy | v2 Convex Pattern |
|-------|---------------|-------------------|
| **users** | `user_id = auth.uid()` | Filter by `identity.subject` |
| **users (firm)** | Firm admin can view members | Check `is_firm_admin()` + `firm_id` match |
| **cases** | `user_id = auth.uid()` | Filter by `getCurrentUserId()` |
| **cases (firm)** | Firm members can view firm cases | Join through `users.firm_id` |
| **notifications** | `user_id = auth.uid()` | Filter by `getCurrentUserId()` |
| **user_settings** | `user_id = auth.uid()` | Filter by `getCurrentUserId()` |
| **user_preferences** | `user_id = auth.uid()` | Filter by `getCurrentUserId()` |
| **refresh_tokens** | `user_id` via `perm_users` lookup | Filter by `getCurrentUserId()` |
| **permission_states** | Service role only | Backend mutations only (no direct access) |
| **conversations** | `user_id = auth.uid()` | Filter by `getCurrentUserId()` |
| **conversation_messages** | `conversation_id IN (user's conversations)` | Join through `conversations` table |

---

### Convex Security Implementation Patterns

#### Pattern 1: Basic User Isolation (SELECT)

**v1 RLS Policy:**
```sql
CREATE POLICY "Users can view own cases" ON cases
FOR SELECT USING (user_id = get_current_user_id());
```

**v2 Convex Query:**
```typescript
export const listCases = query({
  handler: async (ctx) => {
    const userId = await getCurrentUserId(ctx);

    return await ctx.db.query("cases")
      .withIndex("by_user_id", q => q.eq("user_id", userId))
      .filter(q => q.eq(q.field("deleted_at"), undefined)) // Exclude soft-deleted
      .collect();
  }
});
```

#### Pattern 2: Basic User Isolation (INSERT)

**v1 RLS Policy:**
```sql
CREATE POLICY "Users can insert own cases" ON cases
FOR INSERT WITH CHECK (user_id = get_current_user_id());
```

**v2 Convex Mutation:**
```typescript
export const createCase = mutation({
  args: { /* case fields */ },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Enforce user_id match
    return await ctx.db.insert("cases", {
      ...args,
      user_id: userId, // Always set to authenticated user
      created_at: Date.now(),
      updated_at: Date.now(),
    });
  }
});
```

#### Pattern 3: Basic User Isolation (UPDATE)

**v1 RLS Policy:**
```sql
CREATE POLICY "Users can update own cases" ON cases
FOR UPDATE USING (user_id = get_current_user_id());
```

**v2 Convex Mutation:**
```typescript
export const updateCase = mutation({
  args: { caseId: v.id("cases"), /* update fields */ },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Verify ownership
    const existingCase = await ctx.db.get(args.caseId);
    if (!existingCase || existingCase.user_id !== userId) {
      throw new Error("Case not found or access denied");
    }

    // Apply update
    await ctx.db.patch(args.caseId, {
      /* updated fields */
      updated_at: Date.now(),
    });
  }
});
```

#### Pattern 4: Basic User Isolation (DELETE)

**v1 RLS Policy:**
```sql
CREATE POLICY "Users can delete own cases" ON cases
FOR DELETE USING (user_id = get_current_user_id());
```

**v2 Convex Mutation (Soft Delete):**
```typescript
export const deleteCase = mutation({
  args: { caseId: v.id("cases") },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Verify ownership
    const existingCase = await ctx.db.get(args.caseId);
    if (!existingCase || existingCase.user_id !== userId) {
      throw new Error("Case not found or access denied");
    }

    // Soft delete
    await ctx.db.patch(args.caseId, {
      deleted_at: Date.now(),
      updated_at: Date.now(),
    });
  }
});
```

#### Pattern 5: Firm Admin Access (Multi-User)

**v1 RLS Policy:**
```sql
CREATE POLICY "Firm admins can view firm members" ON users
FOR SELECT USING (
  id = get_current_user_id() OR
  (is_firm_admin() AND firm_id = get_current_user_firm_id())
);
```

**v2 Convex Query:**
```typescript
export const listFirmMembers = query({
  handler: async (ctx) => {
    const userId = await getCurrentUserId(ctx);
    const currentUser = await ctx.db.get(userId);

    // Must be firm admin
    if (currentUser.user_type !== "firm_admin") {
      throw new Error("Access denied: Firm admin only");
    }

    // Return all users in the same firm
    return await ctx.db.query("users")
      .withIndex("by_firm_id", q => q.eq("firm_id", userId))
      .filter(q => q.eq(q.field("deleted_at"), undefined))
      .collect();
  }
});
```

#### Pattern 6: Firm Case Access (Relational)

**v1 RLS Policy:**
```sql
CREATE POLICY "Firm members can view firm cases" ON cases
FOR SELECT USING (
  user_id = get_current_user_id() OR
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = cases.user_id
    AND users.firm_id = get_current_user_firm_id()
  )
);
```

**v2 Convex Query:**
```typescript
export const listFirmCases = query({
  handler: async (ctx) => {
    const userId = await getCurrentUserId(ctx);
    const currentUser = await ctx.db.get(userId);

    // Individual users: own cases only
    if (currentUser.user_type === "individual") {
      return await ctx.db.query("cases")
        .withIndex("by_user_id", q => q.eq("user_id", userId))
        .filter(q => q.eq(q.field("deleted_at"), undefined))
        .collect();
    }

    // Firm members/admins: all firm cases
    const firmId = currentUser.firm_id || userId;
    const firmMembers = await ctx.db.query("users")
      .withIndex("by_firm_id", q => q.eq("firm_id", firmId))
      .collect();

    const memberIds = firmMembers.map(m => m._id);

    // Query cases for all firm members
    const allCases = await Promise.all(
      memberIds.map(memberId =>
        ctx.db.query("cases")
          .withIndex("by_user_id", q => q.eq("user_id", memberId))
          .filter(q => q.eq(q.field("deleted_at"), undefined))
          .collect()
      )
    );

    return allCases.flat();
  }
});
```

#### Pattern 7: Conversation Messages (Nested Ownership)

**v1 RLS Policy:**
```sql
CREATE POLICY "Users can view own conversation messages" ON conversation_messages
FOR SELECT USING (
  conversation_id IN (
    SELECT id FROM conversations WHERE user_id = get_current_user_id()
  )
);
```

**v2 Convex Query:**
```typescript
export const listMessages = query({
  args: { conversationId: v.id("conversations") },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Verify conversation ownership
    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation || conversation.user_id !== userId) {
      throw new Error("Conversation not found or access denied");
    }

    // Return messages
    return await ctx.db.query("conversation_messages")
      .withIndex("by_conversation_id", q => q.eq("conversation_id", args.conversationId))
      .order("asc")
      .collect();
  }
});
```

#### Pattern 8: System-Only Access (Backend Mutations)

**v1 RLS Policy:**
```sql
-- permission_states: Service role only
ALTER TABLE permission_states ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Service role only" ON permission_states
USING (auth.role() = 'service_role');
```

**v2 Convex Pattern:**
```typescript
// Internal mutation (not exposed to client)
export const createPermissionState = internalMutation({
  args: { /* state fields */ },
  handler: async (ctx, args) => {
    // No auth check - only callable from backend actions
    return await ctx.db.insert("permission_states", {
      ...args,
      created_at: Date.now(),
      expires_at: Date.now() + 3600000, // 1 hour
    });
  }
});

// Public action that calls internal mutation
export const initChatbotSession = action({
  args: { /* session args */ },
  handler: async (ctx, args) => {
    const userId = await getCurrentUserId(ctx);

    // Call internal mutation via ctx.runMutation
    const stateId = await ctx.runMutation(internal.permissionStates.createPermissionState, {
      user_id: userId,
      ...args,
    });

    return stateId;
  }
});
```

---

### Helper Functions Library

Create a shared utilities file for common security patterns:

```typescript
// convex/lib/auth.ts

import { QueryCtx, MutationCtx } from "./_generated/server";

/**
 * Get current authenticated user ID (equivalent to get_current_user_id())
 */
export async function getCurrentUserId(
  ctx: QueryCtx | MutationCtx
): Promise<Id<"users">> {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) {
    throw new Error("Unauthorized: No authentication");
  }

  const user = await ctx.db
    .query("users")
    .withIndex("by_auth_user_id", q => q.eq("auth_user_id", identity.subject))
    .unique();

  if (!user) {
    throw new Error("User not found");
  }

  return user._id;
}

/**
 * Check if current user is a firm admin (equivalent to is_firm_admin())
 */
export async function isFirmAdmin(
  ctx: QueryCtx | MutationCtx
): Promise<boolean> {
  const userId = await getCurrentUserId(ctx);
  const user = await ctx.db.get(userId);
  return user?.user_type === "firm_admin";
}

/**
 * Get current user's firm ID (equivalent to get_current_user_firm_id())
 */
export async function getCurrentUserFirmId(
  ctx: QueryCtx | MutationCtx
): Promise<Id<"users"> | undefined> {
  const userId = await getCurrentUserId(ctx);
  const user = await ctx.db.get(userId);
  return user?.firm_id;
}

/**
 * Verify ownership of a resource
 */
export async function verifyOwnership<T extends { user_id: Id<"users"> }>(
  ctx: QueryCtx | MutationCtx,
  resource: T | null
): Promise<void> {
  if (!resource) {
    throw new Error("Resource not found");
  }

  const userId = await getCurrentUserId(ctx);
  if (resource.user_id !== userId) {
    throw new Error("Access denied: Not the owner");
  }
}

/**
 * Verify firm access (owner OR firm member)
 */
export async function verifyFirmAccess<T extends { user_id: Id<"users"> }>(
  ctx: QueryCtx | MutationCtx,
  resource: T | null
): Promise<void> {
  if (!resource) {
    throw new Error("Resource not found");
  }

  const userId = await getCurrentUserId(ctx);

  // Owner check
  if (resource.user_id === userId) {
    return;
  }

  // Firm member check
  const currentUser = await ctx.db.get(userId);
  const resourceOwner = await ctx.db.get(resource.user_id);

  if (!currentUser || !resourceOwner) {
    throw new Error("Access denied");
  }

  // Check if in same firm
  const currentFirmId = currentUser.firm_id || userId;
  const resourceFirmId = resourceOwner.firm_id || resource.user_id;

  if (currentFirmId !== resourceFirmId) {
    throw new Error("Access denied: Not in same firm");
  }
}
```

---

### Security Checklist for v2

#### Authentication
- [ ] Every query/mutation calls `getCurrentUserId()` first
- [ ] Unauthenticated requests throw meaningful errors
- [ ] No direct access to `ctx.db` without auth validation

#### Data Isolation
- [ ] All queries filter by `user_id`
- [ ] Soft deletes filter `deleted_at === undefined`
- [ ] No data leakage across users

#### Firm Access
- [ ] Firm admin can view/manage firm members
- [ ] Firm members can access shared cases
- [ ] Individual users isolated from firm data

#### Nested Resources
- [ ] Conversation messages validate conversation ownership
- [ ] Notifications validate case ownership (if case_id present)
- [ ] Cascading deletes handled in application logic

#### Backend-Only Operations
- [ ] `permission_states` only via internal mutations
- [ ] System notifications use internal mutations
- [ ] No direct client access to sensitive tables

#### Token Security
- [ ] Refresh tokens hashed before storage
- [ ] Token revocation enforced in queries
- [ ] Expired tokens filtered automatically

#### Testing
- [ ] Unit tests for each security helper function
- [ ] Integration tests for all access patterns
- [ ] Negative tests for unauthorized access attempts
- [ ] Firm isolation tests

---

### Migration Security Validation

During migration, verify security parity:

```typescript
// Test script to validate RLS → Convex migration
async function validateSecurityParity() {
  const testCases = [
    {
      test: "User can only access own cases",
      v1Query: "SELECT * FROM cases WHERE user_id = get_current_user_id()",
      v2Query: () => ctx.db.query("cases").withIndex("by_user_id", q => q.eq("user_id", userId)).collect(),
    },
    {
      test: "Firm admin can view firm members",
      v1Query: "SELECT * FROM users WHERE firm_id = get_current_user_firm_id()",
      v2Query: () => ctx.db.query("users").withIndex("by_firm_id", q => q.eq("firm_id", firmId)).collect(),
    },
    // ... more test cases
  ];

  for (const testCase of testCases) {
    const v1Results = await runPostgreSQLQuery(testCase.v1Query);
    const v2Results = await testCase.v2Query();

    assert.deepEqual(v1Results, v2Results, `Security parity failed: ${testCase.test}`);
  }
}
```

---

### Performance Considerations

**Index Strategy:**
- All `user_id` foreign keys must have indexes
- Composite indexes for common query patterns (e.g., `by_user_and_status`)
- Firm queries may require denormalization for performance

**Caching:**
- Cache current user lookup in request context
- Cache firm membership for duration of request
- Invalidate caches on user/firm updates

**Pagination:**
- Always use `.paginate()` for large result sets
- Apply security filters BEFORE pagination
- Never fetch all records then filter client-side

---

## Migration Notes

### Data Type Conversions Required

1. **Timestamps:**
   - Convert `TIMESTAMP WITH TIME ZONE` → Unix milliseconds
   - Use `new Date(pgTimestamp).getTime()`

2. **Dates:**
   - Convert `DATE` → ISO string (YYYY-MM-DD)
   - Preserve existing format

3. **Currency:**
   - Convert `pwd_wage_amount` → cents
   - Multiply by 100, store as `int64`

4. **Arrays:**
   - Convert PostgreSQL arrays to JavaScript arrays
   - Maintain element types

5. **JSONB:**
   - Parse JSONB strings to objects
   - Validate structure during migration

### Index Strategy

**Primary Indexes:**
- All `user_id` foreign keys
- All `case_id` foreign keys
- Unique constraints (email, auth_user_id, state_id, token)

**Composite Indexes:**
- `by_user_and_status` (cases)
- `by_user_and_favorite` (cases)
- `by_user_and_unread` (notifications)
- `by_user_and_archived` (conversations)

**Temporal Indexes:**
- `by_expires_at` (refresh_tokens, permission_states)
- `by_deadline_date` (notifications)
- `by_created_at` (conversation_messages)

### Validation Requirements

**Cases Table:**
- PWD expiration calculation (20 CFR § 656.40(c))
- ETA 9089 filing window (30-180 days)
- I-140 filing window (≤180 days after certification)
- Sunday ad dates must be Sundays
- Job order duration ≥30 days

**Users Table:**
- Email format validation
- Firm hierarchy validation (no circular references)
- Google token expiry validation

**Notifications Table:**
- Deadline date must be future date
- Days until deadline must be positive

### Security Considerations

**Row-Level Security (RLS) Equivalent:**
- Convex uses function-level access control
- Every query must filter by `ctx.auth.getUserIdentity()`
- No shared data across users (except firm members)

**Soft Deletes:**
- Filter `deleted_at === undefined` in all queries
- Implement "hard delete" for GDPR compliance

**Token Security:**
- Hash refresh tokens before storage
- Implement token rotation on refresh
- Revoke tokens on logout

---

## References

- **PostgreSQL Migrations:** `backend/migrations/*.sql`
- **Current Schema:** Run `pg_dump --schema-only` on production database
- **Convex Docs:** https://docs.convex.dev/database/schemas
- **Type Validation:** https://docs.convex.dev/database/document-schemas

---

**Next Steps:**
1. Verify actual PostgreSQL table names in production
2. Resolve `users` vs `perm_users` naming conflict
3. Consolidate duplicate fields (`dismissed_deadlines`)
4. Define explicit schemas for all JSONB fields
5. Create migration scripts for data type conversions
